//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

namespace Main;

////////
//
function add2(x: Nat, y: Nat): Nat {
    return x + y;
}

chktest function add2_1(): Bool {
    return add2(2n, 3n) == 5n;
}

chktest function add2_2(): Bool {
    return add2(x=2n, y=3n) == 5n;
}

chktest function add2_3(): Bool {
    return add2(y=2n, 5n) == 7n;
}

chktest function add2_x(x: Nat): Bool {
    return add2(2n, x) > x;
}

__chktest function add2_x_fail(x: Nat): Bool {
    return add2(5n, x) > 5n;
}

////////
//
function allPositive(...args: List<Int>): Bool {
    return args.allOf(fn(x) => x >= 0i);
}

chktest function allpositive_1(): Bool {
    return allPositive(1, 3, 4);
}

chktest function allpositive_2(): Bool {
    return !allPositive(1, 3, -1);
}

__chktest function allpositive_x_fail(x: Int): Bool {
    return allPositive(1, x, 4);
}

////////
//
function structural_types(tup: [Int, Bool], rec: {f: String, g: Int}): Int {
    return tup.0 + rec.g;
}

chktest function structural_types_1(): Bool {
    return structural_types([1, false], {f="ok", g=3}) == 4i;
}

__chktest function structural_types_fail(tup: [Int, Bool], rec: {f: String, g: Int}): Bool {
    return structural_types(tup, rec) != 4i;
}

////////
//
function sign(x?: Int=0i): Int {
    var y: Int;

    if(x == 0i) {
        y = 0i;
    }
    else {
        y = (x > 0i) ? 1i : -1i;
    }

    return y;
}

chktest function sign_pos(): Bool {
    return sign(5i) == 1i;
}

chktest function sign_neg(): Bool {
    return sign(-5i) == -1i;
}

chktest function sign_default(): Bool {
    return sign() == 0i;
}

__chktest function sign_fail_pos(x: Int): Bool {
    return sign(x) > 0i;
}

__chktest function sign_fail_0(x: Int): Bool {
    return sign(x) != 0i;
}

////////
//
concept WithName {
    invariant $name !== "";

    field name: String;
}

concept Greeting {
    abstract method sayHello(): String;

    virtual method sayGoodbye(): String {
        return "goodbye";
    }
}

entity GenericGreeting provides Greeting {
    const instance: GenericGreeting = GenericGreeting{};

    override method sayHello(): String {
        return "hello world";
    }
}

entity NamedGreeting provides WithName, Greeting {
    override method sayHello(): String {
        return String::concat("hello ", this.name);
    }
}

chktest function genericGreeting_1(): Bool {
    return GenericGreeting{}.sayHello() === "hello world";
}

chktest function genericGreeting_2(): Bool {
    return GenericGreeting::instance.sayHello() === "hello world";
}

chktest function genericGreeting_3(): Bool {
    return NamedGreeting{"bob"}.sayHello() === "hello bob";
}

__chktest function genericGreeting_fail_bob(n: String): Bool {
    return NamedGreeting{n}.sayHello() !== "hello bob";
}

////////
//
typedecl BoolOp provides APIType using {
    line: Nat
} of
LConst { val: Bool }
| NotOp { arg: BoolOp }
| AndOp { larg: BoolOp, rarg: BoolOp }
| OrOp { larg: BoolOp, rarg: BoolOp }
& {
    recursive method evaluate(): Bool {
        match(this) {
            LConst                  => return this.val;
            | NotOp                 => return !this.arg.evaluate[recursive]();
            | AndOp{_, larg, rarg} => return larg.evaluate[recursive]() && rarg.evaluate[recursive]();
            | OrOp{_, larg, rarg}  => return larg.evaluate[recursive]() || rarg.evaluate[recursive]();
        }
    } 
}

chktest function logiceval_1(): Bool {
    return !AndOp{2, LConst{1, true}, LConst{1, false}}.evaluate[recursive]();
}

chktest function logiceval_2(): Bool {
    return OrOp{2, LConst{1, true}, LConst{1, false}}.evaluate[recursive]();
}