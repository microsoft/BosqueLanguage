//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

namespace Expressions;

////
//Logical Operators

const lfalse: Bool = false;
const ltrue: Bool = true;

chktest function logical_negation_false_sc_lit(): Bool {
    return (!false);
}

chktest function logical_negation_true_list(): Bool {
    return !(!true);
}

chktest function logical_negation_false(): Bool {
    return (!Expressions::lfalse);
}

chktest function logical_negation_true(): Bool {
    return !(!Expressions::ltrue);
}

chktest function logical_and_true_sc_lt(): Bool {
    return !(false && true);
}

chktest function logical_and_tf(): Bool {
    return !(Expressions::ltrue && Expressions::lfalse);
}

chktest function logical_and_tt(): Bool {
    return (Expressions::ltrue && Expressions::ltrue);
}

chktest function logical_and_sc(): Bool {
    return !(Expressions::lfalse && (1n / 0n == 1n));
}

chktest function logical_or_false_sc_lit(): Bool {
    return (false || true);
}

chktest function logical_or_tf(): Bool {
    return (Expressions::ltrue || Expressions::lfalse);
}

chktest function logical_or_ff(): Bool {
    return !(Expressions::lfalse || Expressions::lfalse);
}

chktest function logical_or_sc(): Bool {
    return (Expressions::ltrue || (1n / 0n == 1n));
}

chktest function logical_implies_false_lit(): Bool {
    return (false ==> true);
}

chktest function logical_implies_tf(): Bool {
    return !(Expressions::ltrue ==> Expressions::lfalse);
}

chktest function logical_impliestt(): Bool {
    return (Expressions::ltrue ==> Expressions::ltrue);
}

chktest function logical_implies_ft(): Bool {
    return (Expressions::lfalse ==> Expressions::ltrue);
}

chktest function logical_implies_sc(): Bool {
    return (Expressions::lfalse ==> (1n / 0n == 1n));
}

chktest function logical_land_tft(): Bool {
    return !(/\(true, false, true)); 
}

chktest function logical_land_ttt(): Bool {
    return /\(true, true, true); 
}

chktest function logical_lor_tft(): Bool {
    return \/(true, false, true); 
}

chktest function logical_lor_fff(): Bool {
    return !(\/(false, false, false)); 
}

////
//Numeric Comparison

//Equal
chktest function compare_eq_nat_true(): Bool {
    return (3n == 3n); 
}

chktest function compare_eq_nat_false(): Bool {
    return !(1n == 3n);
}

chktest function compare_neq_nat_true(): Bool {
    return (5n != 3n);  
}

chktest function compare_neq_nat_false(): Bool {
    return !(3n != 3n);  
}

chktest function compare_eq_int_true(): Bool {
    return (3i == 3i); 
}

chktest function compare_eq_int_false(): Bool {
    return !(1i == 3i);
}

chktest function compare_neq_int_true(): Bool {
    return (5i != 3i);  
}

chktest function compare_neq_int_false(): Bool {
    return !(3i != 3i);  
}

chktest function compare_eq_bignat_true(): Bool {
    return (3N == 3N); 
}

chktest function compare_eq_bignat_false(): Bool {
    return !(1N == 3N);
}

chktest function compare_neq_bitnat_true(): Bool {
    return (5N != 3N);  
}

chktest function compare_neq_bignat_false(): Bool {
    return !(3N != 3N);  
}

chktest function compare_eq_bigint_true(): Bool {
    return (3I == 3I); 
}

chktest function compare_eq_bigint_false(): Bool {
    return !(1I == 3I);
}

chktest function compare_neq_bitint_true(): Bool {
    return (5I != 3I);  
}

chktest function compare_neq_bigint_false(): Bool {
    return !(3I != 3I);  
}

chktest function compare_eq_float_true(): Bool {
    return (3.0f == 3.0f); 
}

chktest function compare_eq_float_false(): Bool {
    return !(1.0f == 3.0f);
}

chktest function compare_neq_float_true(): Bool {
    return (5.0f != 3.0f);  
}

chktest function compare_neq_float_false(): Bool {
    return !(3.0f != 3.0f);  
}

chktest function compare_eq_decimal_true(): Bool {
    return (3.0d == 3.0d); 
}

chktest function compare_eq_decimal_false(): Bool {
    return !(1.0d == 3.0d);
}

chktest function compare_neq_decimal_true(): Bool {
    return (5.0d != 3.0d);  
}

chktest function compare_neq_decimal_false(): Bool {
    return !(3.0d != 3.0d);  
}

/*
TODO: enable once rationals are implemented
chktest function compare_eq_rational_true(): Bool {
    return (6/2R == 6/2R); 
}

chktest function compare_eq_rational_false(): Bool {
    return !(1/1R == 6/2R);
}

chktest function compare_neq_rational_true(): Bool {
    return (10/2R != 6/2R);  
}

chktest function compare_neq_rational_false(): Bool {
    return !(6/2R != 6/2R);  
}
*/

//Less
chktest function compare_less_nat_true(): Bool {
    return (1n < 3n); 
}

chktest function compare_less_nat_false(): Bool {
    return !(3n < 1n);
}

chktest function compare_less_nat_false_eq(): Bool {
    return !(3n < 3n);
}

chktest function compare_less_int_true(): Bool {
    return (-3i < 1i); 
}

chktest function compare_less_int_false(): Bool {
    return !(3i < 1i);
}

chktest function compare_less_int_false_eq(): Bool {
    return !(3i < 3i);
}

chktest function compare_less_bignat_true(): Bool {
    return (0N < 3N); 
}

chktest function compare_less_bignat_false(): Bool {
    return !(2N < 0N);
}

chktest function compare_less_bignat_false_eq(): Bool {
    return !(0N < 0N);
}

chktest function compare_less_bigint_true(): Bool {
    return (-3I < 0I); 
}

chktest function compare_less_bigint_false(): Bool {
    return !(-1I < -3I);
}

chktest function compare_less_bigint_false_eq(): Bool {
    return !(-1I < -1I);
}

chktest function compare_less_float_true(): Bool {
    return (1.0f < 3.0f); 
}

chktest function compare_less_float_false(): Bool {
    return !(3.0f < -1.0f);
}

chktest function compare_less_float_false_eq(): Bool {
    return !(1.0f < 1.0f);
}

chktest function compare_less_decimal_true(): Bool {
    return (-5.0d < -3.0d); 
}

chktest function compare_less_decimal_false(): Bool {
    return !(-3.0d < -5.0d);
}

chktest function compare_less_decimal_false_eq(): Bool {
    return !(3.0d < 3.0d);
}

/*
TODO: enable once rationals are implemented
*/

//Greater
chktest function compare_greater_nat_true(): Bool {
    return (3n > 1n); 
}

chktest function compare_greater_nat_false(): Bool {
    return !(1n > 3n);
}

chktest function compare_greater_nat_false_eq(): Bool {
    return !(3n > 3n);
}

chktest function compare_greater_int_true(): Bool {
    return (1i > -3i); 
}

chktest function compare_greater_int_false(): Bool {
    return !(1i > 3i);
}

chktest function compare_greater_int_false_eq(): Bool {
    return !(3i > 3i);
}

chktest function compare_greater_bignat_true(): Bool {
    return (3N > 0N); 
}

chktest function compare_greater_bignat_false(): Bool {
    return !(0N > 2N);
}

chktest function compare_greater_bignat_false_eq(): Bool {
    return !(0N > 0N);
}

chktest function compare_greater_bigint_true(): Bool {
    return (0I > -3I); 
}

chktest function compare_greater_bigint_false(): Bool {
    return !(-3I > -1I);
}

chktest function compare_greater_bigint_false_eq(): Bool {
    return !(-1I > -1I);
}

chktest function compare_greater_float_true(): Bool {
    return (3.0f > 1.0f); 
}

chktest function compare_greater_float_false(): Bool {
    return !(-1.0f > 3.0f);
}

chktest function compare_greater_float_false_eq(): Bool {
    return !(1.0f > 1.0f);
}

chktest function compare_greater_decimal_true(): Bool {
    return (-3.0d > -5.0d); 
}

chktest function compare_greater_decimal_false(): Bool {
    return !(-5.0d > -3.0d);
}

chktest function compare_greater_decimal_false_eq(): Bool {
    return !(3.0d > 3.0d);
}

/*
TODO: enable once rationals are implemented
*/

////
//Static Namespace Operators

abstract operator %ns_operator%(a: Any, b: Any): Any;

operator %ns_operator%(a: Int, b: Int): Int {
    return a + b;
}

operator %ns_operator%(a: Nat, b: Bool): Nat {
    if(b) {
        return a;
    }
    else {
        return 0n;
    }
}

chktest function operator_ii(): Bool {
    return %ns_operator%(1i, 2i) == 3i;
}

chktest function operator_nb(): Bool {
    return %ns_operator%(1n, true) == 1n;
}
