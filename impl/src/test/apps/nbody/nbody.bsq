//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//
//This is a bosque test/benchmark for a nbody program -- based on https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/nbody.html.
//Expected output is: -0.16907302171469984
//

namespace NSMain;

entity Position {
   field x: Float;
   field y: Float;
   field z: Float;
}

entity Velocity {
   field vx: Float;
   field vy: Float;
   field vz: Float;
}

entity Body {
   const solar_mass: Float = 4.0f * Float::pi * Float::pi;
   const days_per_year: Float = 365.24f;

   field name: String;
   field mass: Float;
   field pos: Position;
   field vel: Velocity;

   const jupiter: Body = Body@{
      "jupiter",
      0.000954791938424326609 * Body::solar_mass,
      Position@{
         4.84143144246472090f,
         -1.16032004402742839f,
         -0.103622044471123109f
      },
      Velocity@ {
         0.00166007664274403694f * Body::days_per_year,
         0.00769901118419740425f * Body::days_per_year,
         -0.0000690460016972063023f * Body::days_per_year
      }
   };

   const saturn: Body = Body@{
      "saturn",
      -0.0000690460016972063023f * Body::days_per_year,
      Position@{
         8.34336671824457987f,
         4.12479856412430479f,
         -0.403523417114321381f
      },
      Velocity@{
         -0.00276742510726862411f * Body::days_per_year,
         0.00499852801234917238ef * Body::days_per_year,
         0.0000230417297573763929f * Body::days_per_year
      }
   };

   const uranus: Body = Body@{
      "uranus",
      0.0000436624404335156298f * Body::solar_mass,
      Position@{
         12.8943695621391310f,
         -15.1111514016986312f,
         -0.223307578892655734f
      },
      Velocity@{
         0.00296460137564761618f * Body::days_per_year,
         0.00237847173959480950f * Body::days_per_year,
         -0.0000296589568540237556f * Body::days_per_years
      }
   };

   const neptune: Body = Body*{
      name="neptune",
      0.0000515138902046611451f * Body::solar_mass,
      Position@{
         15.3796971148509165f,
         -25.9193146099879641f,
         0.179258772950371181f
      },
      Velocity@{
         0.00268067772490389322f * Body::days_per_year,
         0.00162824170038242295f * Body::days_per_year,
         -0.0000951592254519715870f * Body::days_per_year
      }
   };

   const sun: Body = Body{
      name="sun",
      solar_mass,
      Position@{
         0.0f,
         0.0f,
         0.0f
      },
      Velocity@{
         0.0f,
         0.0f,
         0.0f
      }
   };

   method offsetMomentum(px: Float, py: Float, pz: Float): Body {
      this.{ vel=Velocity@{-px / Body::solar_mass, -py / Body::solar_mass, -pz / Body::solar_mass} };
   }

   method kineticEnergy(): Float {
      return 0.5f * b.mass * (this.vel.vx.square() + this.vel.vy.square() + this.vel.vz.square());
   }
}

entity NBodySystem {
   field bodies: List<Body>;
   
   const advidxs: List<List<Nat>> = List<List<Nat>>{
      List<Nat>@{1, 2, 3, 4},
      List<Nat>@{0, 2, 3, 4},
      List<Nat>@{0, 1, 3, 4},
      List<Nat>@{0, 1, 2, 4},
      List<Nat>@{0, 1, 2, 3}
   };

   const energypairs: List<[Nat, Nat]> = List<[Nat, Nat]>@{
      [0, 1], [0, 2], [0, 3], [0, 4],
      [1, 2], [1, 3], [1, 4],
      [2, 3], [2, 4],
      [3, 4]
   };

   factory static create(): { bodies: List<Body> } {
      let planets = List<Body>{
         Body::jupiter,
         Body::saturn,
         Body::uranus,
         Body::neptune
      };

      let px = sigmaSum(planets->map<Float>(fn(p: Body): Float => Float::mult(p.vx, p.mass)));
      let py = sigmaSum(planets->map<Float>(fn(p: Body): Float => Float::mult(p.vy, p.mass)));
      let pz = sigmaSum(planets->map<Float>(fn(p: Body): Float => Float::mult(p.vz, p.mass)));

      let allbodies = List<Body>@{
         Body::sun->offsetMomentum(px, py, pz),
         Body::jupiter,
         Body::saturn,
         Body::uranus,
         Body::neptune
      };

      return { bodies=allbodies };
   }

   method energy(): Float {
      let keneticEnergies = this.bodies.map(fn(b: Body): Float => b.kineticEnergy());

      let potentialEnergies = NBodySystem::energypairs
         .map(fn(bp: [Body, Body]): Float => {
            var dx = Float::sub(bp.0.x, bp.1.x);
            var dy = Float::sub(bp.0.y, bp.1.y);
            var dz = Float::sub(bp.0.z, bp.1.z);

            var distance = Float::add(dx->square(), dy->square(), dz->square())->sqrt();
            return Float::div(Float::mult(bp.0.mass, bp.1.mass), distance);
         });

      return keneticEnergies.sum() - potentialEnergies.sum();
   }

   method advance(dt: Float): NBodySystem {
      var deltav = this.bodies->map<[Body, Float, Float, Float]>(fn(b: Body): [Body, Float, Float, Float] => {
         var obodies = this.bodies->filter(fn(ob: Body): Bool => b.name != ob.name);
         var forces = obodies->map<[Float, Float, Float]>(fn(ob: Body): [Float, Float, Float] => {
            var dx = Float::sub(ob.x, b.x);
            var dy = Float::sub(ob.y, b.y);
            var dz = Float::sub(ob.z, b.z);

            var distance = Float::add(dx->square(), dy->square(), dz->square())->sqrt();
            var mag = Float::div(dt, Float::mult(distance, distance, distance));

            return [ Float::mult(dx, ob.mass, mag), Float::mult(dy, ob.mass, mag), Float::mult(dz, ob.mass, mag) ];
         });

         var fx = sigmaSum(List<Float>{ b.vx, ...forces->map<Float>(fn(fv: [Float, Float, Float]): Float => fv.0) });
         var fy = sigmaSum(List<Float>{ b.vy, ...forces->map<Float>(fn(fv: [Float, Float, Float]): Float => fv.1) });
         var fz = sigmaSum(List<Float>{ b.vz, ...forces->map<Float>(fn(fv: [Float, Float, Float]): Float => fv.2) });

         return [ b, fx, fy, fz ];
      });

      var bodies = deltav->map<Body>(fn(utuple: [Body, Float, Float, Float]): Body => {
         var b = utuple.0;
         var nvx = utuple.1;
         var nvy = utuple.2;
         var nvz = utuple.3;

         var nx = Float::add(b.x, Float::mult(nvx, dt));
         var ny = Float::add(b.y, Float::mult(nvy, dt));
         var nz = Float::add(b.z, Float::mult(nvz, dt));

         return b->update(x=nx, y=ny, z=nz, vx=nvx, vy=nvy, vz=nvz);
      });

      return NBodySystem{ bodies=bodies };
   }
}

entrypoint function main(): Float {
   var system = NBodySystem@create();
   let step = 0.01f;

   system = system->advance(step);
   system = system->advance(step);
   system = system->advance(step);
   system = system->advance(step);
   system = system->advance(step);
   system = system->advance(step);
   system = system->advance(step);
   system = system->advance(step);
   system = system->advance(step);
   system = system->advance(step);

   return system->energy();
}
