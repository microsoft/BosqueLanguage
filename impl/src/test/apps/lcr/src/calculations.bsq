namespace NSCalculations;

import NSBasics;
import NSCountry;
import NSCurrency;
import NSCounterparty;
import NSFlows;
import NSInflows;
import NSOutflows;
import NSProduct;
import NSRules;

function lcr(toCounterparty: Map<NSCounterParty::CounterpartyId, NSCounterParty::Counterparty>, product: Map<NSProduct::ProductId, NSProduct::Product>, t: DateTime, flowsForDate: List<[DateTime, NSFlows::Flow]>, reserveBalanceRequirement: NSBasics::Balance): NSBasics::Ratio {
    let relevantFlows = flowsForDate.filter(pred(fdp) => datesEqual(fdp.0, t)).map(fn(pdp) => fdp.1);
    let hqla = hqlaAmount(product, relevantFlows, reserveBalanceRequirement);

    let totalNetCashOutflow = totalNetCashOutflowAmount(toCounterparty, t, flowsForDate);
    return hqla / totalNetCashOutflow;
}

function hqlaAmount(product: Map<NSProduct::ProductId, NSProduct::Product>, t0Flows: List<NSFlows::Flow>, reserveBalanceRequirement: NSBasics::Balance): NSBasics::Balance {
    let level1LiquidAssetsThatAreEligibleHQLA = t0Flows
            .filter(pred(flow) => flow.assetType === NSBasics::AssetCategoryCodes::Level1Assets && isHQLA(product, flow))
            .map(fn(flow) => flow.amount)
            .sum();

    let level1LiquidAssetAmount = level1LiquidAssetsThatAreEligibleHQLA - reserveBalanceRequirement;

    let level2aLiquidAssetsThatAreEligibleHQLA = t0Flows
            .filter(pred(flow) => flow.assetType === NSBasics::AssetCategoryCodes::Level2aAssets && isHQLA(product, flow))
            .map(fn(flow) => flow.amount)
            .sum();

    let level2aLiquidAssetAmount = 0.85f * level2aLiquidAssetsThatAreEligibleHQLA;

    let level2bLiquidAssetsThatAreEligibleHQLA = t0Flows
            .filter(pred(flow) => flow.assetType === NSBasics::AssetCategoryCodes::Level2bAssets && isHQLA(product, flow))
            .map(fn(flow) => flow.amount)
            .sum();

    let level2bLiquidAssetAmount = 0.5f * level2bLiquidAssetsThatAreEligibleHQLA;

    let level2CapExcessAmount = Float::max(level2aLiquidAssetAmount + level2bLiquidAssetAmount - 0.6667f * level1LiquidAssetAmount, 0.0f);
    let level2bCapExcessAmount = Float::max(level2bLiquidAssetAmount - level2CapExcessAmount - 0.1765f * (level1LiquidAssetAmount + level2aLiquidAssetAmount), 0.0f);
    let unadjustedExcessHQLAAmount = level2CapExcessAmount + level2bCapExcessAmount;

    let adjustedLevel1LiquidAssetAmount = level1LiquidAssetAmount;
    let adjustedlevel2aLiquidAssetAmount = level2aLiquidAssetAmount * 0.85f;
    let adjustedlevel2bLiquidAssetAmount = level2bLiquidAssetAmount * 0.5f;
    let adjustedLevel2CapExcessAmount = Float::max(adjustedlevel2aLiquidAssetAmount + adjustedlevel2bLiquidAssetAmount - 0.6667f * adjustedLevel1LiquidAssetAmount, 0.0f);
    let adjustedlevel2bCapExcessAmount = Float::max(adjustedlevel2bLiquidAssetAmount - adjustedLevel2CapExcessAmount - 0.1765f * (adjustedLevel1LiquidAssetAmount + adjustedlevel2aLiquidAssetAmount), 0.0f);

    let adjustedExcessHQLAAmount = adjustedLevel2CapExcessAmount + adjustedlevel2bCapExcessAmount;
    
    return level1LiquidAssetAmount + level2aLiquidAssetAmount + level2bLiquidAssetAmount - max(unadjustedExcessHQLAAmount, adjustedExcessHQLAAmount);
}

function spanDates(dates: List<DateTime>, flowsForDate: List<[DateTime, NSFlows::Flow]>, flowFilter: pred(flow: NSFlows::Flow) -> Bool): List<NSBasics::Balance> {
    return dates
        .map(fn(t) => flowsForDate.filter(pred(fdp) => datesEqual(fdp.0, t)).map(fn(pdp) => fdp.1)
        .map(fn(flows) => aggregateDaily(flows, flowFilter));
}

function aggregateSpan(dates: List<DateTime>, flowsForDate: List<[DateTime, NSFlows::Flow]>, flowFilter: pred(flow: NSFlows::Flow) -> Bool): NSBasics::Balance {
    return spanDates(dates, flowsForDate, flowFilter).sum();
}

function aggregateDaily(flows: List<NSFlows::Flow>, flowFilter: pred(flow: NSFlows::Flow) -> Bool): NSBasics::Balance {
    return flows.filter(flowFilter).map(fn(flow) => flow.amount).sum();
}

function nonMaturityOutflowRules(toCounterparty: Map<NSCounterParty::CounterpartyId, NSCounterParty::Counterparty>, t: DateTime): NSRules::Rule {
    let rrules = List<String>{
        "32(a)(1)",
        "32(a)(2)",
        "32(a)(3)",
        "32(a)(4)",
        "32(a)(5)",
        "32(b)",
        "32(c)",
        "32(d)",
        "32(e)",
        "32(f)",
        "32(i)"
    };
    
    return NSRules::findAll(rrules, NSOutflows::outflowRules(toCounterparty, date));
}

function nonMaturityInflowRules : LocalDate -> List (Rules.Rule Flow)
        nonMaturityInflowRules date =
            Rules.findAll
                [ "33(b)", "33(g)" ]
                (Inflows.inflowRules toCounterparty date)

function totalNetCashOutflowAmount(toCounterparty: Map<NSCounterParty::CounterpartyId, NSCounterParty::Counterparty>, t: DateTime, flowsForDate: List<[DateTime, Flow]>): Balance {
    let dates = List<Int>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}
        .map(fn(i) => addDays(i, t));

        nonMaturityOutflowAmount : Balance
        nonMaturityOutflowAmount =
            aggregateSpan (Rules.isAnyApplicable (nonMaturityOutflowRules t))

        nonMaturityInflowAmount : Balance
        nonMaturityInflowAmount =
            aggregateSpan (Rules.isAnyApplicable (nonMaturityInflowRules t))

        -- Maturity
        maturityMismatchOutflowRules : LocalDate -> List (Rules.Rule Flow)
        maturityMismatchOutflowRules =
            \date ->
                Rules.findAll
                    [ "32(g)(1)"
                    , "32(g)(2)"
                    , "32(g)(3)"
                    , "32(g)(4)"
                    , "32(g)(5)"
                    , "32(g)(6)"
                    , "32(g)(7)"
                    , "32(g)(8)"
                    , "32(g)(9)"
                    , "32(h)(1)"
                    , "32(h)(2)"
                    , "32(h)(5)"
                    , "32(j)"
                    , "32(k)"
                    , "32(l)"
                    ]
                    (Outflows.outflowRules toCounterparty date)

        maturityOutflows : List Balance
        maturityOutflows =
            spanDates (Rules.isAnyApplicable (maturityMismatchOutflowRules t))

        maturityOutflowAmount : Balance
        maturityOutflowAmount =
            maturityOutflows |> List.sum

        maturityMismatchInflowRules : LocalDate -> List (Rules.Rule Flow)
        maturityMismatchInflowRules =
            \date ->
                Rules.findAll [ "33(c)", "33(d)", "33(e)", "33(f)" ] (Inflows.inflowRules toCounterparty date)

        maturityInflows : List Balance
        maturityInflows =
            spanDates (Rules.isAnyApplicable (maturityMismatchInflowRules t))

        maturityInflowAmount : Balance
        maturityInflowAmount =
            maturityInflows |> List.sum

        -- Aggregate it all together
        aggregatedOutflowAmount : Balance
        aggregatedOutflowAmount =
            nonMaturityOutflowAmount + maturityOutflowAmount

        aggregatedInflowAmount : Balance
        aggregatedInflowAmount =
            nonMaturityInflowAmount + maturityInflowAmount

        -- This add-on was added later
        maturityMismatchAddOn : Balance
        maturityMismatchAddOn =
            let
                netCumulativeMaturityOutflowAmount : Balance
                netCumulativeMaturityOutflowAmount =
                    List.map2 Tuple.pair (accumulate 0 maturityOutflows) (accumulate 0 maturityInflows)
                        |> List.map (\( o, i ) -> o - i)
                        |> List.maximum
                        |> Maybe.withDefault 0

                netDay30CumulativeMaturityOutflowAmount : Balance
                netDay30CumulativeMaturityOutflowAmount =
                    List.sum maturityOutflows - List.sum maturityInflows

                maxNext30DaysOfCumulativeMaturityOutflowAmountFloor : Balance
                maxNext30DaysOfCumulativeMaturityOutflowAmountFloor =
                    max 0.0 netCumulativeMaturityOutflowAmount

                netDay30CumulativeMaturityOutflowAmountFloor : Balance
                netDay30CumulativeMaturityOutflowAmountFloor =
                    max 0.0 netDay30CumulativeMaturityOutflowAmount
            in
            maxNext30DaysOfCumulativeMaturityOutflowAmountFloor - netDay30CumulativeMaturityOutflowAmountFloor

        cappedInflows : Balance
        cappedInflows =
            min (0.75 * aggregatedOutflowAmount) aggregatedInflowAmount
    in
    aggregatedOutflowAmount - cappedInflows + maturityMismatchAddOn
}

isMember : Maybe a -> List a -> Bool
isMember ruleM rules =
    ruleM
        |> Maybe.map (\r -> List.member r rules)
        |> Maybe.withDefault False


isHQLA : (ProductId -> Product) -> Flow -> Bool
isHQLA product flow =
    product flow.productId |> .isHQLA


{-| Helper function to accumulated steps of a sum across a list. This is used in calculating the maturity mismatch add-on.
-}
accumulate : number -> List number -> List number
accumulate starter list =
    let
        ( sum, acc ) =
            List.foldl (\y ( x, xs ) -> ( x + y, (x + y) :: xs )) ( starter, [] ) list
    in
    List.reverse acc

