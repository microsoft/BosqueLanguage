//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

__internal entity Map<K grounded KeyType, V> provides Some, Expandoable<[K, V]>, APIType when K grounded APIType && V grounded APIType {
    private function s_into(l: ListRepr<T>): List<T> # special_inject
    method value(): ListRepr<T> # special_extract

    method empty(): Bool {
        return MapOps::s_empty<K, V>(this.value());
    }

    method size(): Nat {
        return MapOps::s_size<K, V>(this.value());
    }

    method has(key: K): Bool {
        return MapOps::s_has<K, V>(this.value(), key);
    }

    method get(key: K): V {
        let e = MapOps::s_find<K, V>(this.value(), key);

        check e !== none;
        return e.1;
    }

    method getOrNone(key: K): V? {
        let e = MapOps::s_find<K, V>(this.value(), key);
        if(e === none) {
            return none;
        }
        else {
            return e.1;
        }
    }

    method getOption(key: K): Option<V> {
        let e = MapOps::s_find<K, V>(this.value(), key);
        if(e === none) {
            return nothing;
        }
        else {
            return something(e.1);
        }
    }

    method getTry(key: K, out? v: V): Bool {
        let e = MapOps::s_find<K, V>(this.value(), key);
        if(e === none) {
            return false;
        }
        else {
            v = e.1;
            return true;
        }
    }

    method union(m: Map<K, V>): Map<K, V> {
        let am = ListOps::s_concat2<[K, V]>(this.value(), m.value());
        check ListOps::s_chk_kv_unique<K, V>(am);
        
        return Map<K, V>::s_safecreate(am);
    }

    recursive? method submap(p: recursive? pred(v: [K, V]) -> Bool): Map<K, V> {
        let sm = ListOps::s_filter<[K, V]>(this.value(), p);
        return Map<K, V>::s_safecreate(sm);
    }

    recursive? method remap(f: recursive? fn(v: [K, V]) -> V): Map<K, V> {
        let rm = ListOps::s_map<[K, V]>(this.value(), recursive? fn(v: [K, V]): [K, V] => [v.0, f[recursive?](v)]);
        return Map<K, V>::s_safecreate(rm);
    }

    method add(k: K, v: V): Map<K, V> {
        if(this.empty()) {
            return Map<K, V>{ k => v };
        }
        else {
            return Map<K, V>::s_into(MapOps::s_add<K, V>(this.value(), k, v));
        }
    }

    method set(k: K, v: V): Map<K, V> {
        check !this.empty();
        return Map<K, V>::s_into(MapOps::s_set<K, V>(this.value(), k, v));
    }

    method remove(k: K): Map<K, V> {
        check !this.empty();
        return Map<K, V>::s_into(MapOps::s_remove<K, V>(this.value(), k));
    }

    //
    //TODO: ref versions of the add/remove/set operators
    //
}

