//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if EXEC_LIBS
internal function __map_literal_cons0<K grounded KeyType, V>(): MapRepr<K, V> {
    return none;
}

internal function __map_literal_cons1<K grounded KeyType, V>(e: [K, V]): MapRepr<K, V> {
    return return BTree<K, V>{count, BTreeNode<K, V>{e.0, e.1, none, none}};
}

internal function __map_literal_cons_add<K grounded KeyType, V>(e: [K, V], mm: BTreeNode<K, V>): BTreeNode<K, V> {
    return mm.add[recursive](e.0, e.1);
}

internal function __map_literal_cons_add_done<K grounded KeyType, V>(count: Nat, mm: BTreeNode<K, V>): MapRepr<K, V> {
    return BTree<K, V>{count, mm};
}

internal function __map_literal_cons_append<K grounded KeyType, V>(m1: MapRepr<K, V>, m2: MapRepr<K, V>): MapRepr<K, V> {
    return MapOps::s_union<K, V>(m1, m2);
}

internal entity MapOps provides Some {
    function s_size_ne<K grounded KeyType, V>(m: MapRepr<K, V>): Nat = s_map_size_ne;

    function s_has_ne<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): Bool = s_map_has_ne;
    function s_find_ne<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): V = s_map_find_ne;

    function s_union_ne<K grounded KeyType, V>(m1: MapRepr<K, V>, m2: MapRepr<K, V>): MapRepr<K, V> = s_map_union_ne;

    recursive? function s_submap_ne<K grounded KeyType, V>(m: MapRepr<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapRepr<K, V> = s_map_submap_ne;
    recursive? function s_remap_ne<K grounded KeyType, V, U>(m: MapRepr<K, V>, f: recursive? fn(k: K, v: V) -> U): MapRepr<K, U> = s_map_remap_ne;

    function s_add_ne<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> = s_map_add_ne;
    function s_set_ne<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> = s_map_set_ne;
    function s_remove_ne<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): MapRepr<K, V> = s_map_remove_ne;

    function s_empty<K grounded KeyType, V>(m: MapRepr<T>): Bool {
        return m === none;
    }

    function s_size<K grounded KeyType, V>(m: MapRepr<T>): Nat {
        if(m === none) {
            return 0n;
        }
        else {
            return MapOps::s_size_ne<K, V>(m);
        }
    }

    function s_has<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): Bool {
        if(m === none) {
            return false;
        }
        else {
            return MapOps::s_has_ne<K, V>(m, k);
        }
    }

    function s_find<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): [K, V]? {
        if(m === none) {
            return none;
        }
        else {
            if(!MapOps::s_has_ne<K, V>(m, k))
            {
                return none;
            }
            else
            {
                return [k, MapOps::s_find_ne<K, V>(m, k)];
            }
        }
    }

    function s_union<K grounded KeyType, V>(m1: MapRepr<K, V>, m2: MapRepr<K, V>): MapRepr<K, V> {
        if(/\(m1 === none, m2 === none)) {
            return none;
        }
        elif(m1 === none) {
            return m2;
        }
        elif(m2 === none) {
            return m1;
        }
        else {
            return MapOps::s_union_ne<K, V>(m1, m2)
        }
    }

    recursive? function s_submap<K grounded KeyType, V>(m: MapRepr<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapRepr<K, V> {
        if(m === none) {
            return none;
        }
        else {
            return m.submap[recursive?](p); 
        }
    }

    recursive? function s_remap<K grounded KeyType, V, U>(m: MapRepr<K, V>, f: recursive? fn(k: K, v: V) -> U): MapRepr<K, U> {
        if(m === none) {
            return none;
        }
        else {
            return m.remap<U>[recursive?](f);
        }
    }

    function s_add<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        if(m === none) {
            return BTree<K, V>{1n, BTreeNode<K, V>{k, v, none, none}};
        }
        else {
            return m.add(k, v);
        }
    }

    function s_set<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        return s_safeAs<MapRepr<K, V>, BTree<K, V>>(m).set(k, v);
    }

    function s_remove<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): MapRepr<K, V> {
        return s_safeAs<MapRepr<K, V>, BTree<K, V>>(m).remove(k);
    }
}

__internal entity MapTree<T> provides Some {
    //Dummy placeholder
}

internal typedef MapRepr<K grounded KeyType, V> = None | MapTree<K, V>;

#endif
