//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if EXEC_LIBS
internal function __map_literal_cons0<K grounded KeyType, V>(): MapRepr<K, V> {
    return none;
}

internal function __map_literal_cons1<K grounded KeyType, V>(e: [K, V]): MapRepr<K, V> {
    return return BTree<K, V>{count, BTreeNode<K, V>{e.0, e.1, none, none}};
}

internal function __map_literal_cons_add<K grounded KeyType, V>(e: [K, V], mm: BTreeNode<K, V>): BTreeNode<K, V> {
    return mm.add[recursive](e.0, e.1);
}

internal function __map_literal_cons_add_done<K grounded KeyType, V>(count: Nat, mm: BTreeNode<K, V>): MapRepr<K, V> {
    return BTree<K, V>{count, mm};
}

internal function __map_literal_cons_append<K grounded KeyType, V>(m1: MapRepr<K, V>, m2: MapRepr<K, V>): MapRepr<K, V> {
    return MapOps::s_union<K, V>(m1, m2);
}

internal entity MapOps provides Some {
    __assume_safe function s_safeAs<T, U>(v: T): U = map_safeas;

    function s_empty<K grounded KeyType, V>(m: MapRepr<T>): Bool {
        return m === none;
    }

    function s_size<K grounded KeyType, V>(m: MapRepr<T>): Nat {
        if(m === none) {
            return 0n;
        }
        else {
            return m.count;
        }
    }

    function s_has<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): Bool {
        if(m === none) {
            return false;
        }
        else {
            return m.has(k);
        }
    }

    function s_find<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): [K, V]? {
        if(m === none) {
            return none;
        }
        else {
            return m.find(k);
        }
    }

    function s_union<K grounded KeyType, V>(m1: MapRepr<K, V>, m2: MapRepr<K, V>): MapRepr<K, V> {
        if(/\(m1 === none, m2 === none)) {
            return none;
        }
        elif(m1 === none) {
            return m2;
        }
        elif(m2 === none) {
            return m1;
        }
        else {
            return BTree<K, V>::union(m1, m2); 
        }
    }

    recursive? function s_submap<K grounded KeyType, V>(m: MapRepr<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapRepr<K, V> {
        if(m === none) {
            return none;
        }
        else {
            return m.submap[recursive?](p); 
        }
    }

    recursive? function s_remap<K grounded KeyType, V, U>(m: MapRepr<K, V>, f: recursive? fn(k: K, v: V) -> U): MapRepr<K, U> {
        if(m === none) {
            return none;
        }
        else {
            return m.remap<U>[recursive?](f);
        }
    }

    function s_add<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        if(m === none) {
            return BTree<K, V>{1n, BTreeNode<K, V>{k, v, none, none}};
        }
        else {
            return m.add(k, v);
        }
    }

    function s_set<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        return MapOps::s_safeAs<MapRepr<K, V>, BTree<K, V>>(m).set(k, v);
    }

    function s_remove<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): MapRepr<K, V> {
        return MapOps::s_safeAs<MapRepr<K, V>, BTree<K, V>>(m).remove(k);
    }
}

internal entity BTree<K grounded KeyType, V> {
    field count: Nat;
    field t: BTreeNode<K, V>;

    method has(k: K): Bool {
        return this.t.has[recursive](k);
    }

    method find(k: K): [K, V]? {
        return this.t.find[recursive](k);
    }

    function union(m1: BTree<K, V>, m2: BTree<K, V>): BTree<K, V> {
        let uu = BTreeNode<K, V>::union[recursive](m1.t, m2.t);
        return BTree<K, V>{m1.count + m2.count, uu};
    }

    recursive? method submap(p: recursive? pred(k: K, v: V) -> Bool): BTree<K, V>? {
        let uu, us = this.t.submap[recursive](p);
        if(uu === none) {
            return none;
        }
        else {
            return BTree<K, V>{us, uu};
        }
    }

    recursive? method remap<U>(f: recursive? fn(k: K, v: V) -> U): BTree<K, U> {
        let rmp = this.t.remap[recursive](f);
        return BTree<K, U>{this.count, rmp};
    }

    method add(k: K, v: V): BTree<K, V> {
        return BTree<K, V>{this.count + 1, this.t.add[recursive](k, v)};
    }

    recursive method set(m: MapRepr<K, V>, k: K, v: V): BTree<K, V> {
        return BTree<K, V>{this.count, this.t.set[recursive](k, v)};
    }

    recursive method remove(k: K): MapRepr<K, V> {
        let rt = this.t.remove[recursive](k);
        if(rt === none) {
            return none;
        }
        else {
            return BTree<K, V>{this.count - 1n, rt};
        }
    }
}

internal entity BTreeNode<K grounded KeyType, V> {
    field key: K;
    field val: V;
    field l: BTree<K, V>?;
    field r: BTree<K, V>?;

    method isLeaf() {
        return /\(this.l === none, this.r === none);
    }

    recursive has(k: K): Bool {
        let kk = this.key;
        if(KeyType::equal<K>(k, kk)) {
            return true;
        }
        
        if(KeyType::less<K>(k, kk)) {
            let ll = this.l;
            if(ll === none) {
                return false;
            }
            else {
                return ll.has[recursive](k);
            }
        }
        else {
            let rr = this.r;
            if(rr === none) {
                return false;
            }
            else {
                return rr.has[recursive](k);
            }
        }
    }

    recursive find(k: K): [K, V]? {
        let kk = this.key;
        if(KeyType::equal<K>(k, kk)) {
            return [kk, this.val];
        }
        
        if(KeyType::less<K>(k, kk)) {
            let ll = this.l;
            if(ll === none) {
                return none;
            }
            else {
                return ll.has[recursive](k);
            }
        }
        else {
            let rr = this.r;
            if(rr === none) {
                return none;
            }
            else {
                return rr.has[recursive](k);
            }
        }
    }

    recursive function union(m1: BTreeNode<K, V>, m2: BTreeNode<K, V>): BTreeNode<K, V> {
        if(m2.isLeaf()) {
            return m1.add[recursive](m2.key, m2.val);
        }
        elif(m1.isLeaf()) {
            return m2.add[recursive](m1.key, m1.val);
        }
        else {
            let m1min = m1.s_min[recursive]();
            let m1max = m1.s_max[recursive]();
            let m2min = m2.s_min[recursive]();
            let m2max = m2.s_max[recursive]();

            if(KeyType::less<K>(m1max, m2min)) {
                let m2mt, m2me, = m2.s_remove_min[recursive]();
                return BTreeNode<K, V>{m2me.key, m2me.val, m1, m2mt};
            }
            elif(KeyType::less<K>(m2max, m1min)) {
                let m1mt, m1me, = m1.s_remove_min[recursive]();
                return BTreeNode<K, V>{m1me.key, m1me.val, m2, m1mt};
            }
            else {
                var rml = m2;

                let ll = m1.l;
                if(ll !== none) {
                    rml = BTreeNode<K, V>::union(ll, rml);
                }

                let rr = m1.r;
                if(rr !== none) {
                    rml = BTreeNode<K, V>::union(rr, rml);
                }

                return rml.add(m1.key, m1.val);
            }
        }
    }

    recursive method s_min(): K {
        let ll = this.l;
        if(ll === none) {
            return this.key;
        }
        else {
            return ll.s_min();
        }
    }

    recursive method s_max(): K {
        let rr = this.r;
        if(rr === none) {
            return this.key;
        }
        else {
            return rr.s_max();
        }
    }

    recursive method submap(p: recursive? pred(k: K, v: V) -> Bool): BTreeNode<K, V>?, Nat {
        let ll = this.l;
        var nll: BTreeNode<K, V>? = none;
        var nls = 0n;
        if(ll !== none) {
            nll, nls = ll.submap[recursive](p);
        }

        let rr = this.r;
        var nrr: BTreeNode<K, V>? = none;
        var nrs = 0n;
        if(rr !== none) {
            nrr, nrs = rr.submap[recursive](p);
        }

        if(p[recursive?](this.key, this.val)) {
            return BTreeNode<K, V>{this.key, this.val, nll, nrr}, nls + nrs + 1;
        }
        else {
            if(/\(nll === none, nrr === none)) {
                return none, 0n;
            }
            elif(nll === none) {
                return nrr, nrs;
            }
            elif(nrr === none) {
                return nll, nls;
            }
            else {
                let nrrx, ne = nrr.s_remove_min[recursive]();
                return BTreeNode<K, V>{ne.0, ne.1, nll, nrrx}, nls + nrs;
            }
        }
    }

    recursive method remap<U>(f: recursive? fn(k: K, v: V) -> U): BTreeNode<K, U> {
        let ll = this.l;
        var nll: BTreeNode<K, U>? = none;
        if(ll !== none) {
            nll = ll.remap<U>[recursive](f);
        }

        let rr = this.r;
        var nrr: BTreeNode<K, U>? = none;
        if(rr !== none) {
            nrr = rr.remap<U>[recursive](f);
        }

        let uu = f[recursive?](this.key, this.val);
        return BTreeNode<K, U>{this.key, uu, nll, nrr};
    }

    recursive method add(k: K, v: V): BTreeNode<K, V> {
        let kk = this.key;
        check !KeyType::equal<K>(k, kk);
        
        var nll: BTreeNode<K, V>?;
        var nrr: BTreeNode<K, V>?;
        if(KeyType::less<K>(k, kk)) {
            let ll = this.l;
            if(ll === none) {
                nll = BTreeNode<K, V>{k, v, none, none};
            }
            else {
                nll = ll.add[recursive](k, v);
            }

            nrr = this.r;
        }
        else {
            let rr = this.r;
            if(rr === none) {
                nrr = BTreeNode<K, V>{k, v, none, none};
            }
            else {
                nrr = rr.add[recursive](k, v);
            }

            nll = this.l;
        }

        return BTreeNode<K, V>{kk, this.val, nll, nrr};
    }

    recursive method set(m: MapRepr<K, V>, k: K, v: V): BTreeNode<K, V> {
        let kk = this.key;
        if(KeyType::equal<K>(k, kk)) {
            return BTreeNode<K, V>{kk, v, nll, nrr};
        }
        else {
            var nll: BTreeNode<K, V>?;
            var nrr: BTreeNode<K, V>?;
            if(KeyType::less<K>(k, kk)) {
                let ll = this.l;
                check ll !== none;

                nll = ll.set[recursive](k, v);
                nrr = this.r;
            }
            else {
                let rr = this.r;
                check rr !== none;

                nrr = rr.set[recursive](k, v);
                nll = this.l;
            }

            return BTreeNode<K, V>{kk, this.val, nll, nrr};
        }
    }

    recursive method remove(k: K): BTreeNode<K, V>? {
        let kk = this.key;
        let ll = this.l;
        let rr = this.r;

        if(KeyType::equal<K>(k, kk)) {
            if(/\(ll === none, rr === none)) {
                return none;
            }
            elif(ll === none) {
                return rr;
            }
            elif(rr === none) {
                return ll;
            }
            else {
                let nrr, ne = rr.s_remove_min[recursive]();
                return BTreeNode<K, V>{ne.0, ne.1, ll, nrr};
            }
        }
        else {
            var nll: BTreeNode<K, V>?;
            var nrr: BTreeNode<K, V>?;
            if(KeyType::less<K>(k, kk)) {
                check ll !== none;

                nll = ll.remove[recursive](k);
                nrr = this.r;
            }
            else {
                check rr !== none;

                nrr = rr.remove[recursive](k);
                nll = this.l;
            }

            return BTreeNode<K, V>{kk, this.val, nll, nrr};
        }
    }

    recursive method s_remove_min(): BTreeNode<K, V>?, [K, V] {
        let ll = this.l;
        if(ll === none) {
            return this.r, [this.key, this.val];
        }
        else {
            let nll, ee = ll.s_min_helper();
            return BTreeNode<K, V>{kk, this.val, nll, this.r}, ee;
        }
    }
}

internal typedef MapRepr<K grounded KeyType, V> = None | BTree<K, V>;

#endif
