//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if CHECK_LIBS
internal entity MapOps provides Some {
    internal function s_blockingfailure<T>(): T = s_blockingfailure; 

    function s_empty<K grounded KeyType, V>(m: MapRepr<T>): Bool {
        return m === none;
    }

    function s_size<K grounded KeyType, V>(m: MapRepr<T>): Nat {
        if(m === none) {
            return 0n;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            return 1n;
        }
        elif(m.is<Vector2<[K, V]>>()) {
            return 2n;
        }
        elif(m.is<Vector3<[K, V]>>()) {
            return 3n;
        }
        elif(m.is<Vector4<[K, V]>>()) {
            return 4n;
        }
        elif(m.is<Vector5<[K, V]>>()) {
            return 5n;
        }
        else {
            return m.count();
        }
    }

    function s_has<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): Bool {
        if(m === none) {
            return false;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);
            return KeyType::equal<K>(mm.v0.0, k);
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k));
        }
        elif(m.is<Vector3<T>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k), KeyType::equal<K>(mm.v2.0, k));
        }
        elif(m.is<Vector4<T>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector4<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k), KeyType::equal<K>(mm.v2.0, k), KeyType::equal<K>(mm.v3.0, k));
        }
        elif(m.is<Vector5<T>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector5<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k), KeyType::equal<K>(mm.v2.0, k), KeyType::equal<K>(mm.v3.0, k), KeyType::equal<K>(mm.v4.0, k));
        }
        else {
            return m.has(k);
        }
    }

    function s_find<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): [K, V]? {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);
            if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);
            if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector3<T>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);
             if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            elif(KeyType::equal<K>(mm.v2.0, k)) {
                return m.v2;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector4<T>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector4<[K, V]>>(m);
             if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            elif(KeyType::equal<K>(mm.v2.0, k)) {
                return m.v2;
            }
            elif(KeyType::equal<K>(mm.v3.0, k)) {
                return m.v3;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector5<T>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector5<[K, V]>>(m);
             if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            elif(KeyType::equal<K>(mm.v2.0, k)) {
                return m.v2;
            }
            elif(KeyType::equal<K>(mm.v3.0, k)) {
                return m.v3;
            }
            elif(KeyType::equal<K>(mm.v4.0, k)) {
                return m.v4;
            }
            else {
                return none;
            }
        }
        else {
            return m.find(k);
        }
    }

xxxx;
    function s_union<K grounded KeyType, V>(m1: MapRepr<K, V>, m2: MapRepr<K, V>): Map<K, V> {
        if(/\(m1 === none, m2 === none)) {
            return none;
        }
        elif(m1 === none) {
            return m2;
        }
        elif(m2 === none) {
            return m1;
        }
        elif(/\(m1.is<Vector1<[K, V]>>(), m2.is<Vector1<[K, V]>>())) {
            let mm1 = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m1);
            let mm2 = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m2);

            let kl0 = mm1.v0.0;
            let kr0 = mm2.v0.0;
            assert !KeyType::equal<T>(kl0, kr0);

            if(KeyType::less<K>(kl0, kr0)) {
                return Vector2<[K, V]>{mm1.v0, mm2.v0};
            }
            else {
                return Vector2<[K, V]>{mm1.v0, mm2.v0};
            }
        }
        elif(/\(m1.is<Vector1<[K, V]>>(), m2.is<Vector2<[K, V]>>())) {
            let mm1 = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m1);
            let mm2 = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m2);

            let kl0 = mm1.v0.0;
            let kr0 = mm2.v0.0;
            let kr1 = mm2.v1.0;
            assert /\(!KeyType::equal<T>(kl0, kr0), !KeyType::equal<T>(kl0, kr1));

            if(KeyType::less<K>(kl0, kr0)) {
                return Vector3<[K, V]>{mm1.v0, mm2.v0, mm2.v1};
            }
            elif(KeyType::less<K>(kl0, kr1)) {
                return Vector3<[K, V]>{mm2.v0, mm1.v0, mm2.v1};
            }
            else {
                return Vector3<[K, V]>{mm2.v0, mm2.v1, mm1.v0};
            }
        }
        elif(/\(m1.is<Vector2<[K, V]>>(), m2.is<Vector1<[K, V]>>())) {
            let mm1 = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m1);
            let mm2 = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m2);

            let kl0 = mm1.v0.0;
            let kl1 = mm1.v1.0;
            let kr0 = mm2.v0.0;
            assert /\(!KeyType::equal<T>(kr0, kl0), !KeyType::equal<T>(kr0, kr1));

            if(KeyType::less<K>(kr0, kl0)) {
                return Vector3<[K, V]>{mm2.v0, mm1.v0, mm1.v1};
            }
            elif(KeyType::less<K>(kr0, kl1)) {
                return Vector3<[K, V]>{mm1.v0, mm2.v0, mm1.v1};
            }
            else {
                return Vector3<[K, V]>{mm1.v0, mm1.v1, mm2.v0};
            }
        }
        else {
            return LargeMap<K, V>::union(m1, m2); 
        }
    }

xxxx;
    recursive? function s_submap<K grounded KeyType, V>(m: MapRepr<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapRepr<K, V> {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);

            let v0 = mm.v0;
            let p0 = p[recursive?](v0.0, v0.1);

            if(p0) {
                return m;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);

            let v0 = mm.v0;
            let p0 = p[recursive?](v0.0, v0.1);
            let v1 = mm.v1;
            let p1 = p[recursive?](v1.0, v1.1);

            if(/\(p0, p1)) {
                return m;
            }
            elif(p0) {
                return Vector1<[K, V]>{v0};
            }
            elif(p1) {
                return Vector1<[K, V]>{v1};
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector3<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);

            let v0 = mm.v0;
            let p0 = p[recursive?](v0.0, v0.1);
            let v1 = mm.v1;
            let p1 = p[recursive?](v1.0, v1.1);
            let v2 = mm.v2;
            let p2 = p[recursive?](v2.0, v2.1);

            if(/\(p0, p1, p2)) {
                return m;
            }
            elif(/\(p0, p1)) {
                return Vector2<[K, V]>{v0, v1};
            }
            elif(/\(p0, p2)) {
                return Vector2<[K, V]>{v0, v2};
            }
            elif(/\(p1, p2)) {
                return Vector2<[K, V]>{v1, v2};
            }
            elif(p0) {
                return Vector1<[K, V]>{v0};
            }
            elif(p1) {
                return Vector1<[K, V]>{v1};
            }
            elif(p2) {
                return Vector1<[K, V]>{v2};
            }
            else {
                return none;
            }
        }
        else {
            return m.submap[recursive?](p);
        }
    }

    recursive? function s_remap<K grounded KeyType, V, U>(m: MapRepr<K, V>, f: recursive? fn(k: K, v: V) -> U): MapRepr<K, U> {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);

            let v0 = mm.v0;
            return Vector1<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)]};
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            return Vector2<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)]};
        }
        elif(m.is<Vector3<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            let v2 = mm.v2;
            return Vector3<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)], [v2.0, f[recursive?](v2.0, v2.1)]};
        }
        elif(m.is<Vector4<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector4<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            let v2 = mm.v2;
            return Vector4<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)], [v2.0, f[recursive?](v2.0, v2.1)], [v3.0, f[recursive?](v3.0, v3.1)]};
        }
        elif(m.is<Vector5<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector5<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            let v2 = mm.v2;
            return Vector5<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)], [v2.0, f[recursive?](v2.0, v2.1)], [v3.0, f[recursive?](v3.0, v3.1)], [v4.0, f[recursive?](v4.0, v4.1)]};
        }
        else {
            return m.remap<U>[recursive?](f);
        }
    }

xxxx;
    function s_add<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        if(m === none) {
            return Vector1<[K, V]>{[k, v]};
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);
            assert !KeyType::equal<K>(mm.v0.0, k);

            if(KeyType::less<K>(k, mm.v0.0)) {
                return Vector2<[K, V]>{[k, v], mm.v0};
            }
            else {
                return Vector2<[K, V]>{mm.v0, [k, v]};
            }
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);
            assert !(\/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k)));

            if(KeyType::less<K>(k, mm.v0.0)) {
                return Vector3<[K, V]>{[k, v], mm.v0, mm.v1};
            }
            elif(KeyType::less<K>(k, mm.v1.0)) {
                return Vector3<[K, V]>{mm.v0, [k, v], mm.v1};
            }
            else {
                return Vector3<[K, V]>{mm.v0, mm.v1, [k, v]};
            }
        }
        elif(m.is<Vector3<[K, V]>>()) {
            return MapOps::s_blockingfailure<MapRepr<[K, V]>>();
        }
        else {
            return m.add(k, v);
        }
    }

xxxx;
    function s_set<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);
            assert KeyType::equal<K>(mm.v0.0, k);

            return Vector1<[K, V]>{[k, v]};
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);

            if(KeyType::equal<K>(mm.v0.0, k)) {
                return Vector2<[K, V]>{[k, v], mm.v1};
            }
            else {
                assert KeyType::equal<K>(mm.v1.0, k);

                return Vector2<[K, V]>{mm.v0, [k, v]};
            }
        }
        elif(m.is<Vector3<T>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);

            if(KeyType::equal<K>(mm.v0.0, k)) {
                return Vector3<[K, V]>{[k, v], mm.v1, mm.v2};
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return Vector3<[K, V]>{mm.v0, [k, v], mm.v2};
            }
            else {
                assert KeyType::equal<K>(mm.v2.0, k);

                return Vector3<[K, V]>{mm.v0, mm.v1, [k, v]};
            }
        }
        else {
            return m.set(k, v);
        }
    }

xxxx;
    function s_remove<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): MapRepr<K, V> {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);
            assert KeyType::equal<K>(mm.v0.0, k);

            return none;
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);

            if(KeyType::equal<K>(mm.v0.0, k)) {
                return Vector1<[K, V]>{mm.v1};
            }
            else {
                assert KeyType::equal<K>(mm.v1.0, k);

                return Vector1<[K, V]>{mm.v0};
            }
        }
        elif(m.is<Vector3<T>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);

            if(KeyType::equal<K>(mm.v0.0, k)) {
                return Vector2<[K, V]>{m.v1, m.v2};
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return Vector2<[K, V]>{mm.v0, mm.v2};
            }
            else {
                assert KeyType::equal<K>(mm.v2.0, k);

                return Vector2<[K, V]>{mm.v0, mm.v1};
            }
        }
        else {
            return m.remove(k);
        }
    }
}

entity LargeMap<K grounded KeyType, V> provides Some {
    //TODO: what repr do we want here
    //  field v1: Vector3<T>;
    //  field v2: Vector1<T> | Vector2<T> | Vector3<T>;
    //Or something else

    method count(): Nat {
        return MapOps::s_blockingfailure<Nat>();
    }

    method has(k: K): Bool {
        return MapOps::s_blockingfailure<Bool>();
    }

    method find(k: K): [K, V]? {
        return MapOps::s_blockingfailure<[K, V]?>();
    }

    function union(m1: MapRepr<K, V>, m2: MapRepr<K, V>): MapRepr<K, V> {
        return MapOps::s_blockingfailure<MapRepr<K, V>>();
    }

    recursive? method submap(p: recursive? pred(k: K, v: V) -> Bool): MapRepr<K, V> {
         return MapOps::s_blockingfailure<MapRepr<K, V>>();
    }

    recursive? method remap<U>(f: recursive? fn(k: K, v: V) -> U): LargeMap<K, U> {
        return MapOps::s_blockingfailure<LargeMap<K, V>>();
    }

    method add(k: K, v: V): LargeMap<K, V> {
        return MapOps::s_blockingfailure<LargeMap<K, V>>();
    }

    method set(k: K, v: V): LargeMap<K, V> {
        return MapOps::s_blockingfailure<LargeMap<K, V>>();
    }

    method remove(k: K): MapRepr<K, V> {
        return MapOps::s_blockingfailure<MapRepr<K, V>>();
    }
}

internal typedef MapRepr<K grounded KeyType, V> = None | Vector1<[K, V]> | Vector2<[K, V]> | Vector3<[K, V]> | LargeMap<[K, V]>;

#endif
