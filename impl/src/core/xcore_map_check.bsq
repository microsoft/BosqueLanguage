//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if CHECK_LIBS
internal typedef MapVector<K grounded KeyType, V> = Vector1<[K, V]> | Vector2<[K, V]> | Vector3<[K, V]> | Vector4<[K, V]> | Vector5<[K, V]>;

internal typedef MapRepr<K grounded KeyType, V> = None | MapVector<K, V> | LargeMap<K, V>;

internal entity MapOps provides Some {
    internal function s_blockingfailure<T>(): T = s_blockingfailure; 

    function s_split_vector_4<K, V>(m: Vector4<[K, V]>): (|Vector2<[K, V]>, Vector2<[K, V]>|) {
        return (|Vector2<[K, V]>{l.v0, l.v1}, Vector2<[K, V]>{l.v2, l.v3}|);
    }

    function s_split_vector_5<K, V>(l: Vector5<[K, V]>): (|Vector2<[K, V]>, Vector3<[K, V]>|) {
        return (|Vector2<[K, V]>{l.v0, l.v1}, Vector3<[K, V]>{l.v2, l.v3, l.v4}|);
    }

    function s_append_map_vector_safe_helper<K, V>(l: MapVector<K, V> | None, r: MapVector<K, V> | None): MapVector<K, V> | None {
        if(/\(l === none, r === none)) {
            return none;
        }
        elif(l === none) {
            return r;
        }
        elif(r === none) {
            return l;
        }
        else {
            if(/\(l.is<Vector1<[K, V]>>(), r.is<Vector1<[K, V]>>())) {
                let ll = s_safeAs<MapVector<[K, V]>, Vector1<[K, V]>>(l);
                let rr = s_safeAs<MapVector<[K, V]>, Vector1<[K, V]>>(r);
                return Vector2<[K, V]>{ll.v0, rr.v0};
            }
            elif(/\(l.is<Vector1<[K, V]>>(), r.is<Vector2<[K, V]>>())) {
                let ll = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(l);
                let rr = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(r);
                return Vector3<[K, V]>{ll.v0, rr.v0, rr.v1};
            }
            elif(/\(l.is<Vector1<[K, V]>>(), r.is<Vector3<[K, V]>>())) {
                let ll = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(l);
                let rr = s_safeAs<MapVector<K, V>, Vector3<[K, V]>>(r);
                return Vector4<[K, V]>{ll.v0, rr.v0, rr.v1, rr.v2};
            }
            elif(/\(l.is<Vector2<[K, V]>>(), r.is<Vector1<[K, V]>>())) {
                let ll = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(l);
                let rr = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(r);
                return Vector2<[K, V]>{ll.v0, ll.v1, rr.v0};
            }
            elif(/\(l.is<Vector2<[K, V]>>(), r.is<Vector2<[K, V]>>())) {
                let ll = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(l);
                let rr = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(r);
                return Vector2<[K, V]>{ll.v0, ll.v1, rr.v0, rr.v1};
            }
            else {
                let ll = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(l);
                let rr = s_safeAs<MapVector<K, V>, Vector3<[K, V]>>(r);
                return Vector2<[K, V]>{ll.v0, ll.v1, rr.v0, rr.v1, rr.v2};
            }
        }
    }

    function s_merge_vector_helper<K, V>(l: MapVector<K, V>, r: MapVector<K, V>): MapVector<K, V> | LargeMap<K, V> {
        if(/\(l.is<Vector1<[K, V]>>(), r.is<Vector1<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_1<K, V>(ll, rr.v0);
        }
        elif(/\(l.is<Vector1<[K, V]>>(), r.is<Vector2<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_2<K, V>(rr, ll.v0);
        }
        elif(/\(l.is<Vector1<[K, V]>>(), r.is<Vector3<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector3<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_3<K, V>(rr, ll.v0);
        }
        elif(/\(l.is<Vector1<[K, V]>>(), r.is<Vector4<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector4<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_4<K, V>(rr, ll.v0);
        }
        elif(/\(l.is<Vector2<[K, V]>>(), r.is<Vector1<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_2<K, V>(ll, rr.v0);
        }
        elif(/\(l.is<Vector2<[K, V]>>(), r.is<Vector2<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_3<K, V>(MapOps::s_safe_insert_vector_2<K, V>(ll, rr.v0), rr.v0);
        }
        elif(/\(l.is<Vector2<[K, V]>>(), r.is<Vector3<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector3<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_4<K, V>(MapOps::s_safe_insert_vector_3<K, V>(rr, ll.v0), ll.v0);
        }
        elif(/\(l.is<Vector3<[K, V]>>(), r.is<Vector1<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector3<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_3<K, V>(rr, ll.v0);
        }
        elif(/\(l.is<Vector3<[K, V]>>(), r.is<Vector2<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector3<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_4<K, V>(MapOps::s_safe_insert_vector_3<K, V>(ll, rr.v0), rr.v0);
        }
        elif(/\(l.is<Vector4<[K, V]>>(), r.is<Vector1<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector4<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_4<K, V>(ll, rr.v0);
        }
        else {
            return LargeList<T>::s_append(l, r); 
        }
    }

    function s_empty<K grounded KeyType, V>(m: MapRepr<T>): Bool {
        return m === none;
    }

    function s_size<K grounded KeyType, V>(m: MapRepr<T>): Nat {
        if(m === none) {
            return 0n;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            return 1n;
        }
        elif(m.is<Vector2<[K, V]>>()) {
            return 2n;
        }
        elif(m.is<Vector3<[K, V]>>()) {
            return 3n;
        }
        elif(m.is<Vector4<[K, V]>>()) {
            return 4n;
        }
        elif(m.is<Vector5<[K, V]>>()) {
            return 5n;
        }
        else {
            return m.count();
        }
    }

    function s_has<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): Bool {
        if(m === none) {
            return false;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);
            return KeyType::equal<K>(mm.v0.0, k);
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k));
        }
        elif(m.is<Vector3<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k), KeyType::equal<K>(mm.v2.0, k));
        }
        elif(m.is<Vector4<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector4<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k), KeyType::equal<K>(mm.v2.0, k), KeyType::equal<K>(mm.v3.0, k));
        }
        elif(m.is<Vector5<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector5<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k), KeyType::equal<K>(mm.v2.0, k), KeyType::equal<K>(mm.v3.0, k), KeyType::equal<K>(mm.v4.0, k));
        }
        else {
            return m.has(k);
        }
    }

    function s_find<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): [K, V]? {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);
            if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);
            if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector3<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);
             if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            elif(KeyType::equal<K>(mm.v2.0, k)) {
                return m.v2;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector4<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector4<[K, V]>>(m);
             if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            elif(KeyType::equal<K>(mm.v2.0, k)) {
                return m.v2;
            }
            elif(KeyType::equal<K>(mm.v3.0, k)) {
                return m.v3;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector5<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector5<[K, V]>>(m);
             if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            elif(KeyType::equal<K>(mm.v2.0, k)) {
                return m.v2;
            }
            elif(KeyType::equal<K>(mm.v3.0, k)) {
                return m.v3;
            }
            elif(KeyType::equal<K>(mm.v4.0, k)) {
                return m.v4;
            }
            else {
                return none;
            }
        }
        else {
            return m.find(k);
        }
    }

    function s_union<K grounded KeyType, V>(m1: MapRepr<K, V>, m2: MapRepr<K, V>): Map<K, V> {
        if(/\(m1 === none, m2 === none)) {
            return none;
        }
        elif(m1 === none) {
            return m2;
        }
        elif(m2 === none) {
            return m1;
        }
        else {
            return MapOps::s_merge_vector_helper<K, V>(m1, m2);
        }
    }

    recursive? function s_submap_vector1<K grounded KeyType, V>(m: Vector1<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapVector<K, V> | None {
        let v0 = m.v0;
        let p0 = p[recursive?](m.v0.0, m.v0.1);

        if(p0) {
            return m;
        }
        else {
            return none;
        }
    }
    recursive? function s_submap_vector2<K grounded KeyType, V>(m: Vector2<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapVector<K, V> | None {
        let v0 = m.v0;
        let p0 = p[recursive?](v0.0, v0.1);
        let v1 = m.v1;
        let p1 = p[recursive?](v1.0, v1.1);

        if(/\(p0, p1)) {
            return m;
        }
        elif(p0) {
            return Vector1<[K, V]>{v0};
        }
        elif(p1) {
            return Vector1<[K, V]>{v1};
        }
        else {
            return none;
        }
    }
    recursive? function s_submap_vector3<K grounded KeyType, V>(m: Vector3<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapVector<K, V> | None {
        let v0 = m.v0;
        let p0 = p[recursive?](v0.0, v0.1);
        let v1 = m.v1;
        let p1 = p[recursive?](v1.0, v1.1);
        let v2 = m.v2;
        let p2 = p[recursive?](v2.0, v2.1);

        if(/\(p0, p1, p2)) {
            return m;
        }
        elif(/\(p0, p1)) {
            return Vector2<[K, V]>{v0, v1};
        }
        elif(/\(p0, p2)) {
            return Vector2<[K, V]>{v0, v2};
        }
        elif(/\(p1, p2)) {
            return Vector2<[K, V]>{v1, v2};
        }
        elif(p0) {
            return Vector1<[K, V]>{v0};
        }
        elif(p1) {
            return Vector1<[K, V]>{v1};
        }
        elif(p2) {
            return Vector1<[K, V]>{v2};
        }
        else {
            return none;
        }
    }
    recursive? function s_submap_vector4<K grounded KeyType, V>(m: Vector4<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapVector<K, V> | None {
        let lm, rm = MapOps::s_split_vector_4<K, V>(l);
        
        let lmf = MapOps::s_submap_vector2<K, V>[recursive?](ll, p);
        let rmf = MapOps::s_submap_vector2<K, V>[recursive?](rl, p);

        return MapOps::s_append_map_vector_safe_helper<K, V>(lmf, rmf);
    }
    recursive? function s_submap_vector5<K grounded KeyType, V>(m: Vector5<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapVector<K, V> | None {
        let lm, rm = MapOps::s_split_vector_5<K, V>(l);
        
        let lmf = MapOps::s_submap_vector2<K, V>[recursive?](ll, p);
        let rmf = MapOps::s_submap_vector3<K, V>[recursive?](rl, p);

        return MapOps::s_append_map_vector_safe_helper<K, V>(lmf, rmf);
    }
    recursive? function s_submap<K grounded KeyType, V>(m: MapRepr<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapRepr<K, V> {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            return MapOps::s_submap_vector1<K, V>[recursive?](m, p);
        }
        elif(l.is<Vector2<[K, V]>>()) {
            return MapOps::s_submap_vector2<K, V>[recursive?](m, p);
        }
        elif(m.is<Vector3<[K, V]>>()) {
            return MapOps::s_submap_vector3<K, V>[recursive?](m, p);
        }
        elif(m.is<Vector4<[K, V]>>()) {
            return MapOps::s_submap_vector4<K, V>[recursive?](m, p);
        }
        elif(m.is<Vector5<[K, V]>>()) {
            return MapOps::s_submap_vector5<K, V>[recursive?](m, p);
        }
        else {
            return m.submap[recursive?](p);
        }
    }

    recursive? function s_remap<K grounded KeyType, V, U>(m: MapRepr<K, V>, f: recursive? fn(k: K, v: V) -> U): MapRepr<K, U> {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);

            let v0 = mm.v0;
            return Vector1<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)]};
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            return Vector2<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)]};
        }
        elif(m.is<Vector3<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            let v2 = mm.v2;
            return Vector3<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)], [v2.0, f[recursive?](v2.0, v2.1)]};
        }
        elif(m.is<Vector4<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector4<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            let v2 = mm.v2;
            return Vector4<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)], [v2.0, f[recursive?](v2.0, v2.1)], [v3.0, f[recursive?](v3.0, v3.1)]};
        }
        elif(m.is<Vector5<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector5<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            let v2 = mm.v2;
            return Vector5<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)], [v2.0, f[recursive?](v2.0, v2.1)], [v3.0, f[recursive?](v3.0, v3.1)], [v4.0, f[recursive?](v4.0, v4.1)]};
        }
        else {
            return m.remap<U>[recursive?](f);
        }
    }

    function s_safe_insert_vector_1<K grounded KeyType, V>(m: Vector1<[K, V]>, k: K, v: T): Vector2<[K, V]> {
        if(KeyType::less<K>(k, m.v0.0)) {
            return Vector2<[K, V]>{[k, v], m.v0};
        }
        else {
            assert !KeyType::equal<K>(m.v0.0, k);
            return Vector2<[K, V]>{m.v0, [k, v]};
        }
    }
    function s_safe_insert_vector_2<K grounded KeyType, V>(m: Vector3<[K, V]>, k: K, v: T): Vector3<[K, V]> {
        if(KeyType::less<K>(k, m.v0.0)) {
            return Vector3<[K, V]>{[k, v], m.v0, m.v1};
        }
        elif(KeyType::less<K>(k, m.v1.0)) {
            return Vector3<[K, V]>{m.v0, [k, v], m.v1};
        }
        else {
            assert !KeyType::equal<K>(m.v1.0, k);
            return Vector3<[K, V]>{m.v0, m.v1, [k, v]};
        }
    }
    function s_safe_insert_vector_3<K grounded KeyType, V>(m: Vector4<[K, V]>, k: K, v: T): Vector4<[K, V]> {
        if(KeyType::less<K>(k, m.v0.0)) {
            return Vector4<[K, V]>{[k, v], m.v0, m.v1, m.v2};
        }
        elif(KeyType::less<K>(k, m.v1.0)) {
            return Vector4<[K, V]>{m.v0, [k, v], m.v1, m.v2};
        }
        elif(KeyType::less<K>(k, m.v2.0)) {
            return Vector4<[K, V]>{m.v0, m.v1, [k, v], m.v2};
        }
        else {
            assert !KeyType::equal<K>(m.v2.0, k);
            return Vector4<[K, V]>{m.v0, m.v1, m.v2, [k, v]};
        }
    }
    function s_safe_insert_vector_4<K grounded KeyType, V>(m: Vector4<[K, V]>, k: K, v: T): Vector5<[K, V]> {
        if(KeyType::less<K>(k, m.v0.0)) {
            return Vector5<[K, V]>{[k, v], m.v0, m.v1, m.v2, m.v3};
        }
        elif(KeyType::less<K>(k, m.v1.0)) {
            return Vector5<[K, V]>{m.v0, [k, v], m.v1, m.v2, m.v3};
        }
        elif(KeyType::less<K>(k, m.v2.0)) {
            return Vector5<[K, V]>{m.v0, m.v1, [k, v], m.v2, m.v3};
        }
        elif(KeyType::less<K>(k, m.v3.0)) {
            return Vector5<[K, V]>{m.v0, m.v1, m.v2, [k, v], m.v3};
        }
        else {
            assert !KeyType::equal<K>(m.v3.0, k);
            return Vector4<[K, V]>{m.v0, m.v1, m.v2, m.v3, [k, v]};
        }
    }
    function s_safe_insert_vector_helper<K grounded KeyType, V>(m: MapVector<K, V>, k: K, v: T): MapRepr<K, V> {
        if(l.is<Vector1<[K, V]>>()) {
           return MapOps::s_safe_insert_vector_1<K, V>(m, k, v);
        }
        elif(l.is<Vector2<[K, V]>>()) {
            return MapOps::s_safe_insert_vector_2<K, V>(m, k, v);
        }
        elif(l.is<Vector3<[K, V]>>()) {
            return MapOps::s_safe_insert_vector_3<K, V>(m, k, v);
        }
        elif(l.is<Vector4<[K, V]>>()) {
            return MapOps::s_safe_insert_vector_4<K, V>(m, k, v);
        }
        else {
            return MapOps::s_blockingfailure<MapRepr<K, V>>();
        }
    }

    function s_add<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        if(m === none) {
            return Vector1<[K, V]>{[k, v]};
        }
        else {
            if(m.is<LargeMap<K, V>>()) {
                return m.add(k, v);
            }
            else {
                return MapOps::s_safe_insert_vector_helper<K, V>(m, k, v);
            }
        }
    }

    function s_safe_set_vector_1<K grounded KeyType, V>(m: Vector1<[K, V]>, k: K, v: T): Vector1<[K, V]> {
        assert KeyType::equal<K>(m.v0.0, k);
        return Vector1<[K, V]>{[k, v]};
    }
    function s_safe_set_vector_2<K grounded KeyType, V>(m: Vector2<[K, V]>, k: K, v: T): Vector2<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector2<[K, V]>{[k, v], m.v1};
        }
        else {
            assert KeyType::equal<K>(m.v1.0, k);
            return Vector2<[K, V]>{m.v0, [k, v]};
        }
    }
    function s_safe_set_vector_3<K grounded KeyType, V>(m: Vector3<[K, V]>, k: K, v: T): Vector3<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector3<[K, V]>{[k, v], m.v1, m.v2};
        }
        elif(KeyType::equal<K>(m.v1.0, k)) {
            return Vector3<[K, V]>{m.v0, [k, v], m.v2};
        }
        else {
            assert KeyType::equal<K>(m.v2.0, k);
            return Vector3<[K, V]>{m.v0, m.v1, [k, v]};
        }
    }
    function s_safe_set_vector_4<K grounded KeyType, V>(m: Vector4<[K, V]>, k: K, v: T): Vector4<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector4<[K, V]>{[k, v], m.v1, m.v2, m.v3};
        }
        elif(KeyType::equal<K>(m.v1.0, k)) {
            return Vector4<[K, V]>{m.v0, [k, v], m.v2, m.v3};
        }
        elif(KeyType::equal<K>(m.v2.0, k)) {
            return Vector4<[K, V]>{m.v0, m.v1, [k, v], m.v3};
        }
        else {
            assert KeyType::equal<K>(m.v3.0, k);
            return Vector4<[K, V]>{m.v0, m.v1, m.v2, [k, v]};
        }
    }
    function s_safe_set_vector_5<K grounded KeyType, V>(m: Vector5<[K, V]>, k: K, v: T): Vector5<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector5<[K, V]>{[k, v], m.v1, m.v2, m.v3, m.v4};
        }
        elif(KeyType::equal<K>(m.v1.0, k)) {
            return Vector5<[K, V]>{m.v0, [k, v], m.v2, m.v3, m.v4};
        }
        elif(KeyType::equal<K>(m.v2.0, k)) {
            return Vector5<[K, V]>{m.v0, m.v1, [k, v], m.v3, m.v4};
        }
        elif(KeyType::equal<K>(m.v3.0, k)) {
            return Vector5<[K, V]>{m.v0, m.v1, m.v2, [k, v], m.v4};
        }
        else {
            assert KeyType::equal<K>(m.v4.0, k);
            return Vector5<[K, V]>{m.v0, m.v1, m.v2, m.v3, [k, v]};
        }
    }
    function s_safe_set_vector_helper<K grounded KeyType, V>(m: MapVector<K, V>, k: K, v: T): MapVector<K, V> {
        if(l.is<Vector1<[K, V]>>()) {
           return MapOps::s_safe_set_vector_1<K, V>(m, k, v);
        }
        elif(l.is<Vector2<[K, V]>>()) {
            return MapOps::s_safe_set_vector_2<K, V>(m, k, v);
        }
        elif(l.is<Vector3<[K, V]>>()) {
            return MapOps::s_safe_set_vector_3<K, V>(m, k, v);
        }
        elif(l.is<Vector4<[K, V]>>()) {
            return MapOps::s_safe_set_vector_4<K, V>(m, k, v);
        }
        else {
            return MapOps::s_safe_set_vector_5<K, V>(m, k, v);
        }
    }

    function s_set<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        if(m.is<LargeMap<K, V>>()) {
            return m.set(k);
        }
        else {
            let mm = s_safeAs<MapRepr<[K, V]>, MapVector<K, V>>(m);
            return MapOps::s_safe_remove_vector_helper<K, V>(mm, k);
        }
    }

    function s_safe_remove_vector_2<K grounded KeyType, V>(m: Vector2<[K, V]>, k: K): Vector1<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector1<[K, V]>{m.v1};
        }
        else {
            assert KeyType::equal<K>(m.v2.0, k);
            return Vector1<[K, V]>{m.v0};
        }
    }
    function s_safe_remove_vector_3<K grounded KeyType, V>(m: Vector3<[K, V]>, k: K): Vector2<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector2<[K, V]>{m.v1, m.v2};
        }
        elif(KeyType::equal<K>(m.v1.0, k)) {
            return Vector2<[K, V]>{m.v0, m.v2};
        }
        else {
            assert KeyType::equal<K>(m.v2.0, k);
            return Vector2<[K, V]>{m.v0, m.v1};
        }
    }
    function s_safe_remove_vector_4<K grounded KeyType, V>(m: Vector4<[K, V]>, k: K): Vector3<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector3<[K, V]>{m.v1, m.v2, m.v3};
        }
        elif(KeyType::equal<K>(m.v1.0, k)) {
            return Vector3<[K, V]>{m.v0, m.v2, m.v3};
        }
        elif(KeyType::equal<K>(m.v2.0, k)) {
            return Vector3<[K, V]>{m.v0, m.v1, m.v3};
        }
        else {
            assert KeyType::equal<K>(m.v3.0, k);
            return Vector3<[K, V]>{m.v0, m.v1, m.v2};
        }
    }
    function s_safe_remove_vector_5<K grounded KeyType, V>(m: Vector5<[K, V]>, k: K): Vector4<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector4<[K, V]>{m.v1, m.v2, m.v3, m.v4};
        }
        elif(KeyType::equal<K>(m.v1.0, k)) {
            return Vector4<[K, V]>{m.v0, m.v2, m.v3, m.v4};
        }
        elif(KeyType::equal<K>(m.v2.0, k)) {
            return Vector4<[K, V]>{m.v0, m.v1, m.v3, m.v4};
        }
        elif(KeyType::equal<K>(m.v3.0, k)) {
            return Vector4<[K, V]>{m.v0, m.v1, m.v2, m.v4};
        }
        else {
            assert KeyType::equal<K>(m.v4.0, k);
            return Vector4<[K, V]>{m.v0, m.v1, m.v2, m.v3};
        }
    }
    function s_safe_remove_vector_helper<K grounded KeyType, V>(m: MapVector<K, V>, k: K): MapVector<K, V> {
        if(m.is<Vector1<[K, V]>>()) {
            assert KeyType::equal<K>(m.v0.0, k);
            return none;
        }
        elif(m.is<Vector2<[K, V]>>()) {
            return MapOps::s_safe_remove_vector_2<K, V>(m, k);
        }
        elif(m.is<Vector3<[K, V]>>()) {
            return MapOps::s_safe_remove_vector_3<K, V>(m, k);
        }
        elif(m.is<Vector4<[K, V]>>()) {
            return MapOps::s_safe_remove_vector_4<K, V>(m, k);
        }
        else {
            return MapOps::s_safe_remove_vector_5<K, V>(m, k);
        }
    }

    function s_remove<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): MapRepr<K, V> {
        if(m.is<LargeMap<K, V>>()) {
            return m.remove(k);
        }
        else {
            let mm = s_safeAs<MapRepr<[K, V]>, MapVector<K, V>>(m);
            return MapOps::s_safe_remove_vector_helper<K, V>(mm, k);
        }
    }
}

entity LargeMap<K grounded KeyType, V> provides Some {
    //TODO: what repr do we want here
    //  field v1: Vector3<[K, V]>;
    //  field v2: Vector1<[K, V]> | Vector2<[K, V]> | Vector3<[K, V]>;
    //Or something else

    method count(): Nat {
        return MapOps::s_blockingfailure<Nat>();
    }

    method has(k: K): Bool {
        return MapOps::s_blockingfailure<Bool>();
    }

    method find(k: K): [K, V]? {
        return MapOps::s_blockingfailure<[K, V]?>();
    }

    function union(m1: MapRepr<K, V>, m2: MapRepr<K, V>): MapRepr<K, V> {
        return MapOps::s_blockingfailure<MapRepr<K, V>>();
    }

    recursive? method submap(p: recursive? pred(k: K, v: V) -> Bool): MapRepr<K, V> {
         return MapOps::s_blockingfailure<MapRepr<K, V>>();
    }

    recursive? method remap<U>(f: recursive? fn(k: K, v: V) -> U): LargeMap<K, U> {
        return MapOps::s_blockingfailure<LargeMap<K, V>>();
    }

    method add(k: K, v: V): LargeMap<K, V> {
        return MapOps::s_blockingfailure<LargeMap<K, V>>();
    }

    method set(k: K, v: V): LargeMap<K, V> {
        return MapOps::s_blockingfailure<LargeMap<K, V>>();
    }

    method remove(k: K): MapRepr<K, V> {
        return MapOps::s_blockingfailure<MapRepr<K, V>>();
    }
}
#endif
