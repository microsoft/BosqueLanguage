//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if CHECK_LIBS
internal typedef MapVector<K grounded KeyType, V> = Vector1<[K, V]> | Vector2<[K, V]> | Vector3<[K, V]> | Vector4<[K, V]>;

internal typedef MapRepr<K grounded KeyType, V> = None | Vector1<[K, V]> | Vector2<[K, V]> | Vector3<[K, V]> | Vector4<[K, V]> | SeqMap<K, V>;

internal entity MapOps provides Some {
    internal function s_into<K grounded KeyType, V>(m: MapRepr<K, V>): Map<K, V> = special_inject;
    internal function s_value<K grounded KeyType, V>(m: Map<K, V>): MapRepr<K, V> = special_extract;

    internal function s_vector_to_seqmap<K grounded KeyType, V>(m: MapVector<K, V>): SeqMap<K, V> {
        if(l.is<Vector1<[K, V]>>()) {
            return SeqMapOps::s_map_cons_1<K, V>(l);
        }
        elif(l.is<Vector2<[K, V]>>()) {
            return SeqMapOps::s_map_cons_2<K, V>(l);
        }
        elif(l.is<Vector3<[K, V]>>()) {
            return SeqMapOps::s_map_cons_3<K, V>(l);
        }
        else {
            return SeqMapOps::s_map_cons_4<K, V>(l);
        }
    }

    internal function s_seqlist_to_vector_or_none<T>(l: SeqList<T>, len: Nat): ListVector<T> | None {
        if(len == 0n) {
            return none;
        }
        elif(len == 1n) {
            return Vector1<T>{SeqListOps::s_list_get<T>(l, 0)};
        }
        elif(len == 2n) {
            return Vector2<T>{SeqListOps::s_list_get<T>(l, 0), SeqListOps::s_list_get<T>(l, 1)};
        }
        elif(len == 3n) {
            return Vector3<T>{SeqListOps::s_list_get<T>(l, 0), SeqListOps::s_list_get<T>(l, 1), SeqListOps::s_list_get<T>(l, 2)};
        }
        else {
            return Vector4<T>{SeqListOps::s_list_get<T>(l, 0), SeqListOps::s_list_get<T>(l, 1), SeqListOps::s_list_get<T>(l, 2), SeqListOps::s_list_get<T>(l, 3)};
        }
    }

    internal function s_ensure_seq_repr<T>(l: ListVector<T> | SeqList<T>): SeqList<T> {
        if(l.is<SeqList<T>>()) {
            return l;
        }
        else {
            return ListOps::s_vector_to_seqlist<T>(l);
        }
    }

    internal function s_ensure_std_repr<T>(l: ListVector<T> | SeqList<T> | None): ListRepr<T> {
        if(l.is<SeqList<T>>()) {
            let count = SeqListOps::s_list_size<T>(l);
            if(count > 4) {
                return l;
            }
            else {
                return ListOps::s_seqlist_to_vector_or_none<T>(l, count);
            }
        }
        else {
            return l;
        }
    }

    internal function s_append_helper<T>(l: ListRepr<T>, r: ListRepr<T>): ListRepr<T> {
        if(/\(l.is<Vector1<T>>(), r.is<Vector1<T>>())) {
            let ll = s_safeAs<ListRepr<T>, Vector1<T>>(l);
            let rr = s_safeAs<ListRepr<T>, Vector1<T>>(r);
            return Vector2<T>{ll.v0, rr.v0};
        }
        elif(/\(l.is<Vector1<T>>(), r.is<Vector2<T>>())) {
            let ll = s_safeAs<ListRepr<T>, Vector1<T>>(l);
            let rr = s_safeAs<ListRepr<T>, Vector2<T>>(r);
            return Vector3<T>{ll.v0, rr.v0, rr.v1};
        }
        elif(/\(l.is<Vector1<T>>(), r.is<Vector3<T>>())) {
            let ll = s_safeAs<ListRepr<T>, Vector1<T>>(l);
            let rr = s_safeAs<ListRepr<T>, Vector3<T>>(r);
            return Vector4<T>{ll.v0, rr.v0, rr.v1, rr.v2};
        }
        elif(/\(l.is<Vector2<T>>(), r.is<Vector1<T>>())) {
            let ll = s_safeAs<ListRepr<T>, Vector2<T>>(l);
            let rr = s_safeAs<ListRepr<T>, Vector1<T>>(r);
            return Vector3<T>{ll.v0, ll.v1, rr.v0};
        }
        elif(/\(l.is<Vector2<T>>(), r.is<Vector2<T>>())) {
            let ll = s_safeAs<ListRepr<T>, Vector2<T>>(l);
            let rr = s_safeAs<ListRepr<T>, Vector2<T>>(r);
            return Vector4<T>{ll.v0, ll.v1, rr.v0, rr.v1};
        }
        elif(/\(l.is<Vector1<T>>(), r.is<Vector3<T>>())) {
            let ll = s_safeAs<ListRepr<T>, Vector1<T>>(l);
            let rr = s_safeAs<ListRepr<T>, Vector3<T>>(r);
            return Vector4<T>{ll.v0, rr.v0, rr.v1, rr.v2};
        }
        else {
#if CHK_SMALL_ONLY
            return s_blockingfailure<ListRepr<T>>();
#else
            let ll = ListOps::s_ensure_seq_repr<T>(l);
            let rr = ListOps::s_ensure_seq_repr<T>(r);
            return SeqListOps::s_list_append<T>(ll, rr);
#endif
        }
    }
    xxxx;

    __safe internal function s_map_empty<K grounded KeyType, V>(m: Map<K, V>): Bool = s_map_empty; 
    __safe internal function s_map_count<K grounded KeyType, V>(m: Map<K, V>): Nat = s_map_count; 

    __safe internal function s_map_entries<K grounded KeyType, V>(m: Map<K, V>): List<[K, V]> = s_map_entries;

    __safe internal function s_map_min_key<K grounded KeyType, V>(m: Map<K, V>): K = s_map_min_key;
    __safe internal function s_map_max_key<K grounded KeyType, V>(m: Map<K, V>): K = s_map_max_key; 

    __safe internal function s_map_has<K grounded KeyType, V>(m: Map<K, V>, k: K): Bool = s_map_has; 
    __safe internal function s_map_get<K grounded KeyType, V>(m: Map<K, V>, k: K): V = s_map_get;
    
    __safe internal function s_map_union_fast<K grounded KeyType, V>(m1: Map<K, V>, m2: Map<K, V>): Map<K, V> = s_map_union_fast; 

    __conditional_safe internal recursive? function s_map_map_pred<K grounded KeyType, V>(m: Map<K, V>, p: recursive? pred(_: K, _: V) -> Bool): List<Bool> = s_map_map_pred;
    __safe internal function s_map_mask_select<K grounded KeyType, V>(m: Map<K, V>, mask: List<Bool>): Map<K, V> = s_map_mask_select;

    __conditional_safe internal recursive? function s_map_remap<K grounded KeyType, V, U>(m: Map<K, V>, f: recursive? fn(k: K, v: V) -> U): Map<K, U> = s_map_remap;

    __safe internal function s_map_add<K grounded KeyType, V>(m: Map<K, V>, k: K, vtup: [K, V]): Map<K, V> = s_map_add; 
    __safe internal function s_map_set<K grounded KeyType, V>(m: Map<K, V>, k: K, vtup: [K, V]): Map<K, V> = s_map_set;
    __safe internal function s_map_remove<K grounded KeyType, V>(m: Map<K, V>, k: K): Map<K, V> = s_map_remove;  
}
#endif
