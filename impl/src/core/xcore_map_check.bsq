//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if CHECK_LIBS
internal typedef MapVector<K grounded KeyType, V> = Vector1<[K, V]> | Vector2<[K, V]> | Vector3<[K, V]>;

internal typedef MapRepr<K grounded KeyType, V> = None | MapVector<K, V> | LargeMap<K, V>;

internal entity MapOps provides Some {
    internal function s_blockingfailure<T>(): T = s_blockingfailure;

    function s_append_map_vector_safe_helper<K, V>(l: MapVector<K, V> | None, r: MapVector<K, V> | None): MapVector<K, V> | None {
        if(/\(l === none, r === none)) {
            return none;
        }
        elif(l === none) {
            return r;
        }
        elif(r === none) {
            return l;
        }
        else {
            if(/\(l.is<Vector1<[K, V]>>(), r.is<Vector1<[K, V]>>())) {
                let ll = s_safeAs<MapVector<[K, V]>, Vector1<[K, V]>>(l);
                let rr = s_safeAs<MapVector<[K, V]>, Vector1<[K, V]>>(r);
                return Vector2<[K, V]>{ll.v0, rr.v0};
            }
            elif(/\(l.is<Vector1<[K, V]>>(), r.is<Vector2<[K, V]>>())) {
                let ll = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(l);
                let rr = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(r);
                return Vector3<[K, V]>{ll.v0, rr.v0, rr.v1};
            }
            else {
                let ll = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(l);
                let rr = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(r);
                return Vector3<[K, V]>{ll.v0, ll.v1, rr.v0};
            }
        }
    }

    function s_merge_vector_helper<K, V>(l: MapVector<K, V>, r: MapVector<K, V>): MapVector<K, V> | LargeMap<K, V> {
        if(/\(l.is<Vector1<[K, V]>>(), r.is<Vector1<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_1<K, V>(ll, rr.v0);
        }
        elif(/\(l.is<Vector1<[K, V]>>(), r.is<Vector2<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_2<K, V>(rr, ll.v0);
        }
        elif(/\(l.is<Vector2<[K, V]>>(), r.is<Vector1<[K, V]>>())) {
            let ll = s_safeAs<MapVector<K, V>, Vector2<[K, V]>>(l);
            let rr = s_safeAs<MapVector<K, V>, Vector1<[K, V]>>(r);
            return MapOps::s_safe_insert_vector_2<K, V>(ll, rr.v0);
        }
        else {
            return LargeMap<[K, V]>::union(l, r); 
        }
    }

    function s_empty<K grounded KeyType, V>(m: MapRepr<T>): Bool {
        return m === none;
    }

    function s_size<K grounded KeyType, V>(m: MapRepr<T>): Nat {
        if(m === none) {
            return 0n;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            return 1n;
        }
        elif(m.is<Vector2<[K, V]>>()) {
            return 2n;
        }
        elif(m.is<Vector3<[K, V]>>()) {
            return 3n;
        }
        else {
            return LargeMap<K, V>::count(m);
        }
    }

    function s_has<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): Bool {
        if(m === none) {
            return false;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);
            return KeyType::equal<K>(mm.v0.0, k);
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k));
        }
        elif(m.is<Vector3<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);
            return \/(KeyType::equal<K>(mm.v0.0, k), KeyType::equal<K>(mm.v1.0, k), KeyType::equal<K>(mm.v2.0, k));
        }
        else {
            return LargeMap<K, V>::has(m, k);
        }
    }

    function s_find<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): [K, V]? {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);
            if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);
            if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            else {
                return none;
            }
        }
        elif(m.is<Vector3<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);
             if(KeyType::equal<K>(mm.v0.0, k)) {
                return m.v0;
            }
            elif(KeyType::equal<K>(mm.v1.0, k)) {
                return m.v1;
            }
            elif(KeyType::equal<K>(mm.v2.0, k)) {
                return m.v2;
            }
            else {
                return none;
            }
        }
        else {
            return LargeMap<K, V>::find(m, k);
        }
    }

    function s_union<K grounded KeyType, V>(m1: MapRepr<K, V>, m2: MapRepr<K, V>): Map<K, V> {
        if(/\(m1 === none, m2 === none)) {
            return none;
        }
        elif(m1 === none) {
            return m2;
        }
        elif(m2 === none) {
            return m1;
        }
        else {
            return MapOps::s_merge_vector_helper<K, V>(m1, m2);
        }
    }

    recursive? function s_submap_vector1<K grounded KeyType, V>(m: Vector1<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapVector<K, V> | None {
        let v0 = m.v0;
        let p0 = p[recursive?](m.v0.0, m.v0.1);

        if(p0) {
            return m;
        }
        else {
            return none;
        }
    }
    recursive? function s_submap_vector2<K grounded KeyType, V>(m: Vector2<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapVector<K, V> | None {
        let v0 = m.v0;
        let p0 = p[recursive?](v0.0, v0.1);
        let v1 = m.v1;
        let p1 = p[recursive?](v1.0, v1.1);

        if(/\(p0, p1)) {
            return m;
        }
        elif(p0) {
            return Vector1<[K, V]>{v0};
        }
        elif(p1) {
            return Vector1<[K, V]>{v1};
        }
        else {
            return none;
        }
    }
    recursive? function s_submap_vector3<K grounded KeyType, V>(m: Vector3<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapVector<K, V> | None {
        let v0 = m.v0;
        let p0 = p[recursive?](v0.0, v0.1);
        let v1 = m.v1;
        let p1 = p[recursive?](v1.0, v1.1);
        let v2 = m.v2;
        let p2 = p[recursive?](v2.0, v2.1);

        if(/\(p0, p1, p2)) {
            return m;
        }
        elif(/\(p0, p1)) {
            return Vector2<[K, V]>{v0, v1};
        }
        elif(/\(p0, p2)) {
            return Vector2<[K, V]>{v0, v2};
        }
        elif(/\(p1, p2)) {
            return Vector2<[K, V]>{v1, v2};
        }
        elif(p0) {
            return Vector1<[K, V]>{v0};
        }
        elif(p1) {
            return Vector1<[K, V]>{v1};
        }
        elif(p2) {
            return Vector1<[K, V]>{v2};
        }
        else {
            return none;
        }
    }
    recursive? function s_submap<K grounded KeyType, V>(m: MapRepr<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapRepr<K, V> {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            return MapOps::s_submap_vector1<K, V>[recursive?](m, p);
        }
        elif(l.is<Vector2<[K, V]>>()) {
            return MapOps::s_submap_vector2<K, V>[recursive?](m, p);
        }
        elif(m.is<Vector3<[K, V]>>()) {
            return MapOps::s_submap_vector3<K, V>[recursive?](m, p);
        }
        else {
            return LargeMap<K, V>::submap[recursive?](m, p);
        }
    }

    recursive? function s_remap<K grounded KeyType, V, U>(m: MapRepr<K, V>, f: recursive? fn(k: K, v: V) -> U): MapRepr<K, U> {
        if(m === none) {
            return none;
        }
        elif(m.is<Vector1<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector1<[K, V]>>(m);

            let v0 = mm.v0;
            return Vector1<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)]};
        }
        elif(m.is<Vector2<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector2<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            return Vector2<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)]};
        }
        elif(m.is<Vector3<[K, V]>>()) {
            let mm = s_safeAs<MapRepr<K, V>, Vector3<[K, V]>>(m);

            let v0 = mm.v0;
            let v1 = mm.v1;
            let v2 = mm.v2;
            return Vector3<[K, U]>{[v0.0, f[recursive?](v0.0, v0.1)], [v1.0, f[recursive?](v1.0, v1.1)], [v2.0, f[recursive?](v2.0, v2.1)]};
        }
        else {
            return LargeMap<K, V>::remap<U>[recursive?](m, f);
        }
    }

    function s_safe_insert_vector_1<K grounded KeyType, V>(m: Vector1<[K, V]>, k: K, v: T): Vector2<[K, V]> {
        if(KeyType::less<K>(k, m.v0.0)) {
            return Vector2<[K, V]>{[k, v], m.v0};
        }
        else {
            assert !KeyType::equal<K>(m.v0.0, k);
            return Vector2<[K, V]>{m.v0, [k, v]};
        }
    }
    function s_safe_insert_vector_2<K grounded KeyType, V>(m: Vector3<[K, V]>, k: K, v: T): Vector3<[K, V]> {
        if(KeyType::less<K>(k, m.v0.0)) {
            return Vector3<[K, V]>{[k, v], m.v0, m.v1};
        }
        elif(KeyType::less<K>(k, m.v1.0)) {
            return Vector3<[K, V]>{m.v0, [k, v], m.v1};
        }
        else {
            assert !KeyType::equal<K>(m.v1.0, k);
            return Vector3<[K, V]>{m.v0, m.v1, [k, v]};
        }
    }

    function s_add<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        if(m === none) {
            return Vector1<[K, V]>{[k, v]};
        }
        else {
            if(m.is<LargeMap<K, V>>()) {
                return LargeMap<K, V>::add(m, k, v);
            }
            else {
                if(m.is<Vector1<[K, V]>()) {
                    return MapOps::s_safe_insert_vector_1<K, V>(m, k, v);
                }
                elif(m.is<Vector2<[K, V]>()) {
                    return MapOps::s_safe_insert_vector_2<K, V>(m, k, v);
                }
                else {
                    return LargeMap<[K, V]>::union(m, Vector1<[K, V]>{[k, v]}); 
                }
            }
        }
    }

    function s_safe_set_vector_1<K grounded KeyType, V>(m: Vector1<[K, V]>, k: K, v: T): Vector1<[K, V]> {
        assert KeyType::equal<K>(m.v0.0, k);
        return Vector1<[K, V]>{[k, v]};
    }
    function s_safe_set_vector_2<K grounded KeyType, V>(m: Vector2<[K, V]>, k: K, v: T): Vector2<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector2<[K, V]>{[k, v], m.v1};
        }
        else {
            assert KeyType::equal<K>(m.v1.0, k);
            return Vector2<[K, V]>{m.v0, [k, v]};
        }
    }
    function s_safe_set_vector_3<K grounded KeyType, V>(m: Vector3<[K, V]>, k: K, v: T): Vector3<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector3<[K, V]>{[k, v], m.v1, m.v2};
        }
        elif(KeyType::equal<K>(m.v1.0, k)) {
            return Vector3<[K, V]>{m.v0, [k, v], m.v2};
        }
        else {
            assert KeyType::equal<K>(m.v2.0, k);
            return Vector3<[K, V]>{m.v0, m.v1, [k, v]};
        }
    }
    function s_safe_set_vector_helper<K grounded KeyType, V>(m: MapVector<K, V>, k: K, v: T): MapVector<K, V> {
        if(l.is<Vector1<[K, V]>>()) {
           return MapOps::s_safe_set_vector_1<K, V>(m, k, v);
        }
        elif(l.is<Vector2<[K, V]>>()) {
            return MapOps::s_safe_set_vector_2<K, V>(m, k, v);
        }
        else {
            return MapOps::s_safe_set_vector_3<K, V>(m, k, v);
        }
    }

    function s_set<K grounded KeyType, V>(m: MapRepr<K, V>, k: K, v: V): MapRepr<K, V> {
        if(m.is<LargeMap<K, V>>()) {
            return LargeMap<K, V>::set(m, k);
        }
        else {
            let mm = s_safeAs<MapRepr<[K, V]>, MapVector<K, V>>(m);
            return MapOps::s_safe_remove_vector_helper<K, V>(mm, k);
        }
    }

    function s_safe_remove_vector_2<K grounded KeyType, V>(m: Vector2<[K, V]>, k: K): Vector1<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector1<[K, V]>{m.v1};
        }
        else {
            assert KeyType::equal<K>(m.v2.0, k);
            return Vector1<[K, V]>{m.v0};
        }
    }
    function s_safe_remove_vector_3<K grounded KeyType, V>(m: Vector3<[K, V]>, k: K): Vector2<[K, V]> {
        if(KeyType::equal<K>(m.v0.0, k)) {
            return Vector2<[K, V]>{m.v1, m.v2};
        }
        elif(KeyType::equal<K>(m.v1.0, k)) {
            return Vector2<[K, V]>{m.v0, m.v2};
        }
        else {
            assert KeyType::equal<K>(m.v2.0, k);
            return Vector2<[K, V]>{m.v0, m.v1};
        }
    }
    function s_safe_remove_vector_helper<K grounded KeyType, V>(m: MapVector<K, V>, k: K): MapVector<K, V> {
        if(m.is<Vector1<[K, V]>>()) {
            assert KeyType::equal<K>(m.v0.0, k);
            return none;
        }
        elif(m.is<Vector2<[K, V]>>()) {
            return MapOps::s_safe_remove_vector_2<K, V>(m, k);
        }
        else {
            return MapOps::s_safe_remove_vector_3<K, V>(m, k);
        }
    }

    function s_remove<K grounded KeyType, V>(m: MapRepr<K, V>, k: K): MapRepr<K, V> {
        if(m.is<LargeMap<K, V>>()) {
            return LargeMap<K, V>::remove(m, k);
        }
        else {
            let mm = s_safeAs<MapRepr<[K, V]>, MapVector<K, V>>(m);
            return MapOps::s_safe_remove_vector_helper<K, V>(mm, k);
        }
    }
}

entity LargeMap<K grounded KeyType, V> provides Some {
    internal field dummy_tuple: [K, V]; //ensure the compiler always has the appropriate tuple type for manipulating the internal representation

    __safe internal function s_vector1_to_large_map(v: Vector1<[K, V]>): LargeMap<K, V> = s_vector1_to_large_map;
    __safe internal function s_vector2_to_large_map(v: Vector2<[K, V]>): LargeMap<K, V> = s_vector2_to_large_map;
    __safe internal function s_vector3_to_large_map(v: Vector3<[K, V]>): LargeMap<K, V> = s_vector3_to_large_map;

    internal function s_large_map_to_vector1(l: LargeMap<K, V>): Vector1<[K, V]> = s_large_map_to_vector1;
    internal function s_large_map_to_vector2(l: LargeMap<K, V>): Vector2<[K, V]> = s_large_map_to_vector2;
    internal function s_large_map_to_vector3(l: LargeMap<K, V>): Vector3<[K, V]> = s_large_map_to_vector3;

    __safe internal function s_large_map_count(m: LargeMap<K, V>): Nat = s_large_map_count; 

    __safe internal function s_large_map_has(m: LargeMap<K, V>, k: K): Bool = s_large_map_has; 
    __safe internal function s_large_map_get(m: LargeMap<K, V>, k: K): [K, V] = s_large_map_get; 
    
    __safe internal function s_large_map_disjoint(m1: LargeMap<K, V>, m2: LargeMap<K, V>): Bool = s_large_map_disjoint;
    __safe internal function s_large_map_union(m1: LargeMap<K, V>, m2: LargeMap<K, V>): LargeMap<K, V> = s_large_map_union; 

    __safe internal function s_large_map_add(m: LargeMap<K, V>, k: K, vtup: [K, V]): LargeMap<K, V> = s_large_map_add; 
    __safe internal function s_large_map_set(m: LargeMap<K, V>, k: K, vtup: [K, V]): LargeMap<K, V> = s_large_map_set;
    __safe internal function s_large_map_remove(m: LargeMap<K, V>, k: K): LargeMap<K, V> = s_large_map_remove;  

    function s_vector_to_large_map(vm: MapVector<K, V>): LargeMap<K, V> {
        if(vl.is<Vector1<[K, V]>>()) {
            return LargeMap<K, V>::s_vector1_to_large_map(vm);
        }
        elif(vl.is<Vector2<[K, V]>>()) {
            return LargeMap<K, V>::s_vector2_to_large_map(vm);
        }
        else {
            return LargeMap<K, V>::s_vector3_to_large_map(vm);
        }
    }

    function s_large_map_to_vector(m: LargeMap<K, V>, count: Nat): MapVector<K, V> {
        if(count === 1) {
            return LargeMap<K, V>::s_large_map_to_vector1(m);
        }
        elif(count === 2) {
            return LargeMap<K, V>::s_large_map_to_vector2(m);
        }
        else {
            return LargeMap<K, V>::s_large_map_to_vector3(m);
        }
    }

    function count(m: LargeMap<K, V>): Nat {
        return LargeMap<K, V>::s_large_map_count(m);
    }

    function has(m: LargeMap<K, V>, k: K): Bool {
        return LargeMap<K, V>::s_large_map_has(m, k);
    }

    function find(m: LargeMap<K, V>, k: K): [K, V]? {
        let has = LargeMap<K, V>::s_large_map_has(m, k);
        if(!has) {
            return none;
        }
        else {
            return LargeMap<K, V>::s_large_map_get(m, k);
        }
    }

    function union(l: MapRepr<K, V>, r: MapRepr<K, V>): MapRepr<K, V> {
        if(/\(l.is<LargeMap<K, V>>(), r.is<LargeMap<K, V>>())) {
            assert(LargeMap<K, V>::s_large_map_disjoint(l, r));
            return LargeMap<K, V>::s_large_map_union(l, r);
        }
        elif(l.is<LargeMap<K, V>>()) {
            let rr = LargeMap<K, V>::s_vector_to_large_map(r);
            assert(LargeMap<K, V>::s_large_map_disjoint(l, rr));
            return LargeMap<K, V>::s_large_map_union(l, rr);
        }
        elif(r.is<LargeMap<K, V>>()) {
            let ll = LargeMap<K, V>::s_vector_to_large_map(l);
            assert(LargeMap<K, V>::s_large_map_disjoint(ll, r));
            return LargeMap<K, V>::s_large_map_union(ll, r);
        }
        else {
            let rr = LargeMap<K, V>::s_vector_to_large_map(r);
            let ll = LargeMap<K, V>::s_vector_to_large_map(l);
            assert(LargeMap<K, V>::s_large_map_disjoint(ll, rr));
            return LargeMap<K, V>::s_large_map_union(ll, rr);
        }
    }

    recursive? function submap(m: MapRepr<K, V>, p: recursive? pred(k: K, v: V) -> Bool): MapRepr<K, V> {
         return MapOps::s_blockingfailure<MapRepr<K, V>>();
    }

    recursive? function remap<U>(m: MapRepr<K, V>, f: recursive? fn(k: K, v: V) -> U): LargeMap<K, U> {
        return MapOps::s_blockingfailure<LargeMap<K, V>>();
    }

    function add(m: MapRepr<K, V>, k: K, v: V): LargeMap<K, V> {
        assert(!LargeMap<K, V>::s_large_map_has(m, k));

        return LargeMap<K, V>::s_large_map_add(m, k, v);
    }

    function set(m: MapRepr<K, V>, k: K, v: V): LargeMap<K, V> {
        assert(LargeMap<K, V>::s_large_map_has(m, k));

        return LargeMap<K, V>::s_large_map_set(m, k, v);
    }

    function remove(m: MapRepr<K, V>, k: K): MapRepr<K, V> {
        assert(LargeMap<K, V>::s_large_map_has(m, k));

        let mm = LargeMap<K, V>::s_large_map_remove(m, k);
        let mmc = LargeMap<K, V>::s_large_map_count(mm);

        if(mm > 3) {
            return mm;
        }
        else {
            return LargeMap<K, V>::s_large_map_to_vector(mm, mmc);
        }
    }
}
#endif
