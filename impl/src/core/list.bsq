//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

__internal entity List<T> provides Some, Expandoable<T>, APIType when T grounded APIType, TestableType when T grounded TestableType {
    function rangeInt(start: Int, end: Int): List<Int>
        requires start <= end;
    {
        if(start == end) {
            return List<Int>{};
        }
        else {
            return ListOps::s_list_index_int(start, end, end - start);
        }
    }

    function rangeNat(start: Nat, end: Nat): List<Nat>
        requires start <= end;
    {
        if(start == end) {
            return List<Nat>{};
        }
        else {
            return ListOps::s_list_index_nat(start, end, end - start);
        }
    }

    method index(): List<[Nat, T]> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<[Nat, T]>{};
        }
        else {
            return ListOps::s_list_map_fn_idx<T, [Nat, T]>(this, fn(v: T, idx: Nat): [Nat, T] => [idx, v]);
        }
    }

    method zip<U=?>(l: List<U>): List<[T, U]>
        requires ListOps::s_list_size<T>(this) == ListOps::s_list_size<U>(l);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<[T, U]>{};
        }
        else {
            return ListOps::s_list_map_fn_sync<T, U, [T, U]>(this, l, fn(v1: T, v2: U): [T, U] => [v1, v2]);
        }
    }

    method zipMap<U=?, V=?>(l: List<U>, f: recursive? fn(_: T, _: U) -> V): List<V>
        requires ListOps::s_list_size<T>(this) == ListOps::s_list_size<U>(l);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<V>{};
        }
        else {
            return ListOps::s_list_map_fn_sync<T, U, V>(this, l, f);
        }
    }

    function fill(k: Nat, val: T): List<T> {
        if(k == 0n) {
            return List<T>{};
        }
        else {
            return ListOps::s_list_fill<T>(k, val);
        }
    }

    function concat(...ll: List<List<T>>): List<T> {
        if(ListOps::s_list_empty<List<T>>(ll)) {
            return List<T>{};
        }
        else {
            let ilist = ListOps::s_get_front<List<T>>(ll);
            let tl = ListOps::s_pop_front<List<T>>(ll);
            if(ListOps::s_list_empty<List<T>>(tl)) {
                return ilist;
            }
            else {
                return ListOps::s_list_reduce<List<T>, List<T>>(tl, istr, fn(acc: List<T>, argl: List<T>): List<T> => {
                    if(/\(ListOps::s_list_empty<List<T>>(acc), ListOps::s_list_empty<List<T>>(argl))) {
                        return List<List<T>>{};
                    }
                    elif(ListOps::s_list_empty<List<T>>(acc)) {
                        return argl;
                    }
                    elif(ListOps::s_list_empty<List<T>>(argl)) {
                        return acc;
                    }
                    else {
                        return ListOps::s_list_append<List<T>>(acc, argl);
                    }
                });
            }
        }
    }

    method size(): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
            return ListOps::s_list_size<T>(this);
        }
    }

    method empty(): Bool {
        return ListOps::s_list_empty<T>(this);
    }

    method front(): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        return ListOps::s_list_get_front<T>(this);
    }

    method frontOrNone(): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            return ListOps::s_list_get_front<T>(this);
        }
    }

    method frontOption(): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            return something(ListOps::s_list_get_front<T>(this));
        }
    }

    method frontTry(out? res: T): Bool {
        if(!ListOps::s_list_empty<T>(this)) {
            res = ListOps::s_list_get_front<T>(this);
            return true;
        }
        else {
            return false;
        }
    }

    method back(): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        return ListOps::s_list_get_back<T>(this);
    }

    method backOrNone(): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            return ListOps::s_list_get_back<T>(this);
        }
    }

    method backOption(): Option<T> {
        if(ListOps::s_list_empty<T>(this)){
            return nothing;
        }
        else {
            return something(ListOps::s_list_get_back<T>(this));
        }
    }

    method backTry(out? res: T): Bool {
        if(!ListOps::s_list_empty<T>(this)) {
            res = ListOps::s_list_get_back<T>(this);
            return true;
        }
        else {
            return false;
        }
    }

    method get(i: Nat): T
        requires i < ListOps::s_list_size<T>(this);
    {
        return ListOps::s_list_get<T>(this, i);
    }

    method getOrNone(i: Nat): T? {
        if(i < ListOps::s_list_size<T>(this)) {
            return ListOps::s_list_get<T>(this, i);
        }
        else {
            return none;
        }
    }

    method getOption(i: Nat): Option<T> {
        if(i < ListOps::s_list_size<T>(this)) {
            return something(ListOps::s_list_get<T>(this, i));
        }
        else {
            return nothing;
        }
    }

    method getTry(i: Nat, out? res: T): Bool {
        if(i < ListOps::s_list_size<T>(this)) {
            res = ListOps::s_list_get<T>(this, i);
            return true;
        }
        else {
            return false;
        }
    }

    recursive? method single(p: recursive? pred(_: T) -> Bool): T 
        requires !ListOps::s_list_empty<T>(this);
    {
#if CHECK_LIBS
        let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
        let idx = ListOps::s_list_single_indexof_true(vmap);
#else
        let idx = ListOps::s_list_single_index_of<T>[recursive](this, p);
#endif
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method singleOrNone(p: recursive? pred(_: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_single_indexof_true(vmap);
#else
            let idx = ListOps::s_list_single_index_of<T>[recursive](this, p);
#endif

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method singleOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_single_indexof_true(vmap);
#else
            let idx = ListOps::s_list_single_index_of<T>[recursive](this, p);
#endif

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method singleTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_single_indexof_true(vmap);
#else
            let idx = ListOps::s_list_single_index_of<T>[recursive](this, p);
#endif

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    method getSingleton(): T 
        requires ListOps::s_list_size<T>(this) == 1n;
    {
        return ListOps::s_list_get_front<T>(this);
    }

    method getSingletonOrNone(): T? {
        if(ListOps::s_list_size<T>(this) != 1n) {
            return none;
        }
        else {
            return ListOps::s_list_get_front<T>(this);
        }
    }

    recursive? method getSingletonOption(): Option<T> {
        if(ListOps::s_list_size<T>(this) != 1n) {
            return nothing;
        }
        else {
            return something(ListOps::s_list_get_front<T>(this));
        }
    }

    recursive? method getSingletonTry(out? res: T): Bool {
        if(ListOps::s_list_size<T>(this) != 1n) {
            return false;
        }
        else {
            res = ListOps::s_list_get_front<T>(this);
            return true;
        }
    }

    recursive? method allOf(p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return true;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>[recursive?](this, p);
            return ListOps::s_list_all_true(mask);
#else
            return !ListOps::s_list_has_pred<T>[recursive?](this, recursive? pred(v: T): Bool => !p[recursive?](v));
#endif
        }
    }

    recursive? method allOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return true;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            return ListOps::s_list_all_true(mask);
#else
            return !ListOps::s_list_has_pred_idx<T>[recursive?](this, recursive? pred(v: T, idx: Nat): Bool => !p[recursive?](v, idx));
#endif
        }
    }

    recursive? method noneOf(p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return true;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>[recursive?](this, p);
            return ListOps::s_list_all_false(mask);
#else
            return !ListOps::s_list_has_pred<T>[recursive?](this, p);
#endif
        }
    }

    recursive? method noneOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return true;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            return ListOps::s_list_all_false(mask);
#else
            return !ListOps::s_list_has_pred_idx<T>[recursive?](this, p);
#endif
        }
    }

    recursive? method someOf(p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>[recursive?](this, p);
            return ListOps::s_list_has_true(mask);
#else
            return ListOps::s_list_has_pred<T>[recursive?](this, p);
#endif
        }
    }

    recursive? method someOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            return ListOps::s_list_has_true(mask);
#else
            return ListOps::s_list_has_pred_idx<T>[recursive?](this, p);
#endif
        }
    }

    recursive? method countIf(p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>[recursive?](this, p);
            if(ListOps::s_list_all_false(mask)) {
                return 0n;
            }
            elif(ListOps::s_list_single_true(mask)) {
                return 1n;
            }
            elif(ListOps::s_list_all_true(mask)) {
                return ListOps::s_list_size<T>(this);
            }
            else {
                return ListOps::s_list_reduce<Bool, Nat>(mask, 0n, fn(acc: Nat, bv: Bool): Nat => {
                    if(bv) {
                        return acc + 1n;
                    }
                    else { 
                        return acc;
                    }
                });
            }
#else
            return ListOps::s_list_reduce<T, Nat>(this, 0n, recursive? fn(acc: Nat, v: T): Nat => {
                if(p[recursive?](v)) {
                    return acc + 1n;
                    }
                else { 
                    return acc;
                }
            });
#endif
        }
    }

    recursive? method countIf(p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            if(ListOps::s_list_all_false(mask)) {
                return 0n;
            }
            elif(ListOps::s_list_single_true(mask)) {
                return 1n;
            }
            elif(ListOps::s_list_all_true(mask)) {
                return ListOps::s_list_size<T>(this);
            }
            else {
                return ListOps::s_list_reduce<Bool, Nat>(mask, 0n, fn(acc: Nat, bv: Bool): Nat => {
                    if(bv) {
                        return acc + 1n;
                    }
                    else { 
                        return acc;
                    }
                });
            }
#else
            return ListOps::s_list_reduce_idx<T, Nat>(this, 0n, recursive? fn(acc: Nat, v: T, idx: Nat): Nat =>  {
                if(p[recursive?](v, idx)) {
                    return acc + 1n;
                }
                else { 
                    return acc;
                }
            });
#endif
        }
    }

    method {when T grounded KeyType} contains(v: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return ListOps::s_list_has<T>(this, v);
        }
    }

    //TODO: needs a {when T noneable} or something
    method containsNone(): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return ListOps::s_list_has<T>(this, none);
        }
    }

    //TODO: needs a {when T nothingable} or something
    method containsNothing(): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return ListOps::s_list_has<T>(this, nothing);
        }
    }

    method {when T unique IResult} containsError(): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>(this, pred(e: Result<T!IResultT, T!IResultE>): Bool => e.isErr());
            return ListOps::s_list_has_true(mask);
#else
            return ListOps::s_list_has_pred<T>(this, pred(e: Result<T!IResultT, T!IResultE>): Bool => e.isErr());
#endif
        }
    }

    method {when T unique IResult} allOk(): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>(this, pred(e: Result<T!IResultT, T!IResultE>): Bool => e.isOk());
            return ListOps::s_list_all_true(mask);
#else
            return !ListOps::s_list_has_pred<T>(this, pred(e: Result<T!IResultT, T!IResultE>): Bool => e.isErr());
#endif
        }
    }

    method {when T grounded KeyType} count(v: T): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>(this, pred(e: T): Bool => KeyType::equal<T>(v, e));
            if(ListOps::s_list_all_false(mask)) {
                return 0n;
            }
            elif(ListOps::s_list_single_true(mask)) {
                return 1n;
            }
            elif(ListOps::s_list_all_true(mask)) {
                return ListOps::s_list_size<T>(this);
            }
            else {
                return ListOps::s_list_reduce<Bool, Nat>(mask, 0n, fn(acc: Nat, bv: Bool): Nat => {
                    if(bv) {
                        return acc + 1n;
                    }
                    else { 
                        return acc;
                    }
                });
            }
#else
            return ListOps::s_list_reduce_idx<T, Nat>(this, 0n, fn(acc: Nat, v: T): Nat => KeyType::equal<T>(v, e) ? acc + 1n : acc);
#endif
        }
    }

    method countNone(): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>(this, pred(e: T): Bool => e === none);
            if(ListOps::s_list_all_false(mask)) {
                return 0n;
            }
            elif(ListOps::s_list_single_true(mask)) {
                return 1n;
            }
            elif(ListOps::s_list_all_true(mask)) {
                return ListOps::s_list_size<T>(this);
            }
            else {
                return ListOps::s_list_reduce<Bool, Nat>(mask, 0n, fn(acc: Nat, bv: Bool): Nat => {
                    if(bv) {
                        return acc + 1n;
                    }
                    else { 
                        return acc;
                    }
                });
            }
#else
            return ListOps::s_list_reduce_idx<T, Nat>(this, 0n, fn(acc: Nat, v: T): Nat => {
                if(v === none) {
                    return acc + 1n;
                }
                else { 
                    return acc;
                }
            });
#endif
        }
    }

    method countNothing(): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>(this, pred(e: T): Bool => e === nothing);
            if(ListOps::s_list_all_false(mask)) {
                return 0n;
            }
            elif(ListOps::s_list_single_true(mask)) {
                return 1n;
            }
            elif(ListOps::s_list_all_true(mask)) {
                return ListOps::s_list_size<T>(this);
            }
            else {
                return ListOps::s_list_reduce<Bool, Nat>(mask, 0n, fn(acc: Nat, bv: Bool): Nat => {
                    if(bv) {
                        return acc + 1n;
                    }
                    else { 
                        return acc;
                    }
                });
            }
#else
            return ListOps::s_list_reduce_idx<T, Nat>(this, 0n, fn(acc: Nat, v: T): Nat => {
                if(v === nothing) {
                    return acc + 1n;
                }
                else { 
                    return acc;
                }
            });
#endif
        }
    }

    method {when T unique Orderable} min(): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        let iv = ListOps::s_get_front<T>(this);
        let tl = ListOps::s_pop_front<T>(this);
        if(ListOps::s_list_empty<T>(tl)) {
            return iv;
        }
        else {
            return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                if(v < acc) {
                    return v;
                }
                else {
                    return acc;
                }
            });
        }
    }

    method {when T unique Orderable} max(): T
        requires !ListOps::s_list_empty<T>(this);
    {
        let iv = ListOps::s_get_front<T>(this);
        let tl = ListOps::s_pop_front<T>(this);
        if(ListOps::s_list_empty<T>(tl)) {
            return iv;
        }
        else {
            return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                if(v > acc) {
                    return v;
                }
                else {
                    return acc;
                }
            });
        }
    }

    method {when T unique Orderable} minOrNone(): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v < acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
            }
        }
    }

    method {when T unique Orderable} maxOrNone(): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v > acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
            }
        }
    }

    method {when T unique Orderable} minOption(): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return something(iv);
            }
            else {
                let res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v < acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return something(res);
            }
        }
    }

    method {when T unique Orderable} maxOrOption(): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return something(iv);
            }
            else {
                let res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v > acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return something(res);
            }
        }
    }

    method {when T unique Orderable} minTry(out? res: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                res = iv;
                return true;
            }
            else {
                res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v < acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return true;
            }
        }
    }

    method {when T unique Orderable} maxTry(out? res: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                res = iv;
                return true;
            }
            else {
                res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v > acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
                
                return true;
            }
        }
    }

    method argMin(cmp: recursive? pred(_: T, _: T) -> Bool): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        let iv = ListOps::s_get_front<T>(this);
        let tl = ListOps::s_pop_front<T>(this);
        if(ListOps::s_list_empty<T>(tl)) {
            return iv;
        }
        else {
            return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                if(cmp[recursive?](v, acc)) {
                    return v;
                }
                else {
                    return acc;
                }
            });
        }
    }

    method argMax(cmp: recursive? pred(_: T, _: T) -> Bool): T
        requires !ListOps::s_list_empty<T>(this);
    {
        let iv = ListOps::s_get_front<T>(this);
        let tl = ListOps::s_pop_front<T>(this);
        if(ListOps::s_list_empty<T>(tl)) {
            return iv;
        }
        else {
            return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                if(cmp[recursive?](acc, v)) {
                    return v;
                }
                else {
                    return acc;
                }
            });
        }
    }

    method argMinOrNone(cmp: recursive? pred(_: T, _: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](v, acc)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
            }
        }
    }

    method argMaxOrNone(cmp: recursive? pred(_: T, _: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](acc, v)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
            }
        }
    }

    method argMinOption(cmp: recursive? pred(_: T, _: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return something(iv);
            }
            else {
                let res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](v, acc)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return something(res);
            }
        }
    }

    method argMaxOrOption(cmp: recursive? pred(_: T, _: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return something(iv);
            }
            else {
                let res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](acc, v)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return something(res);
            }
        }
    }

    method argMinTry(out? res: T, cmp: recursive? pred(_: T, _: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                res = iv;
                return true;
            }
            else {
                res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](v, acc)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return true;
            }
        }
    }

    method argMaxTry(out? res: T, cmp: recursive? pred(_: T, _: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                res = iv;
                return true;
            }
            else {
                res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](acc, v)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return true;
            }
        }
    }

    method {when T unique Algebraic} sum(): T {
        if(ListOps::s_list_empty<T>(this)) {
            return T::zero;
        }
        else {
            let iv = ListOps::s_get_front<T>(this);
            let tl = ListOps::s_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(a: T, b: T): T => (a + b));
            }
        }
    }

    recursive? method find(p: recursive? pred(_: T) -> Bool): T
        requires !ListOps::s_list_empty<T>(this);
    {
#if CHECK_LIBS
        let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
        let idx = ListOps::s_list_indexof_true(vmap);
#else
        let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);
#endif
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method find(p: recursive? pred(_: T, _: Nat) -> Bool): T
        requires !ListOps::s_list_empty<T>(this);
    {
#if CHECK_LIBS
        let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
        let idx = ListOps::s_list_indexof_true(vmap);
#else
        let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);
#endif
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method findOrNone(p: recursive? pred(_: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method findOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    recursive? method findLast(p: recursive? pred(_: T) -> Bool): T 
        requires !ListOps::s_list_empty<T>(this);
    {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
#endif
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method findLast(p: recursive? pred(_: T, _: Nat) -> Bool): T
        requires !ListOps::s_list_empty<T>(this);
    {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);
#endif
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findLastOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method findLastOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    recursive? method findIndexOf(p: recursive? pred(_: T) -> Bool): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
#if CHECK_LIBS
        let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
        let idx = ListOps::s_list_indexof_true(vmap);
#else
        let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);
#endif

        assert idx != -1i;
        return NumericOps::s_intToNat(idx);
    }

    recursive? method findIndexOf(p: recursive? pred(_: T, _: Nat) -> Bool): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
#if CHECK_LIBS
        let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
        let idx = ListOps::s_list_indexof_true(vmap);
#else
        let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);
#endif

        assert idx != -1i;
        return NumericOps::s_intToNat(idx);
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    recursive? method findIndexOfOption(p: recursive? pred(_: T) -> Bool): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findIndexOfOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T) -> Bool): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
#if CHECK_LIBS
        let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
        let idx = ListOps::s_list_last_indexof_true(vmap);
#else
        let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
#endif

        assert idx != -1i;
        return NumericOps::s_intToNat(idx);
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T, _: Nat) -> Bool): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
#if CHECK_LIBS
        let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
        let idx = ListOps::s_list_last_indexof_true(vmap);
#else
        let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);
#endif

        assert idx != -1i;
        return NumericOps::s_intToNat(idx);
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    recursive? method findIndexOfLastOption(p: recursive? pred(_: T) -> Bool): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findIndexOfLastOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_last_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
#if CHECK_LIBS
            let vmap = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
#else
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);
#endif

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    method {when T grounded KeyType} indexOf(v: T): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_indexof<T>(this, v);

        assert idx != -1i;
        return idx;
    }

    method {when T grounded KeyType} indexOfOrNone(v: T): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_indexof<T>(this, v);
            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    method {when T grounded KeyType} indexOfOption(v: T): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_indexof<T>(this, v);
            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    method {when T grounded KeyType} indexOfTry(out? res: Nat, v: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_indexof<T>(this, v);
            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    method {when T grounded KeyType} indexOfLast(v: T): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_last_indexof<T>(this, v);

        assert idx != -1i;
        return idx;
    }

    method {when T grounded KeyType} indexOfLastOrNone(v: T): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_last_indexof<T>(this, v);
            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    method {when T grounded KeyType} indexOfLastOption(v: T): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_last_indexof<T>(this, v);
            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    method {when T grounded KeyType} indexOfLastTry(out? res: Nat, v: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_last_indexof<T>(this, v);
            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    recursive? method filter(p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>[recursive?](this, p);
            if(ListOps::s_list_all_false(mask)) {
                return List<T>{};
            }
            elif(ListOps::s_list_single_true(mask)) {
                let sidx = ListOps::s_list_single_indexof_true(mask);
                return List<T>{ListOps::s_list_get<T>(this, sidx)};
            }
            elif(ListOps::s_list_all_true(mask)) {
                return this;
            }
            else {
                return ListOps::s_list_mask_select<T>(this, mask);
            }
#else
        return ListOps::s_filter_pred<T>[recursive?](this, p);
#endif
        }
    }

    recursive? method filter(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred_idx<T>[recursive?](this, p);
            if(ListOps::s_list_all_false(mask)) {
                return List<T>{};
            }
            elif(ListOps::s_list_single_true(mask)) {
                let sidx = ListOps::s_list_single_indexof_true(mask);
                return List<T>{ListOps::s_list_get<T>(this, sidx)};
            }
            elif(ListOps::s_list_all_true(mask)) {
                return this;
            }
            else {
                return ListOps::s_list_mask_select<T>(this, mask);
            }
#else
            return ListOps::s_filter_pred_idx<T>[recursive?](this, p);
#endif
        }
    }

    method filterType<U>(): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{};
        }
        else {
#if CHECK_LIBS
            let mask = ListOps::s_list_map_pred<T>[recursive?](this, p);
            if(ListOps::s_list_all_false(mask)) {
                return List<U>{};
            }
            elif(ListOps::s_list_single_true(mask)) {
                let sidx = ListOps::s_list_single_indexof_true(mask);
                return List<U>{s_safeAs<T, U>(ListOps::s_list_get<T>(this, sidx))};
            }
            elif(ListOps::s_list_all_true(mask)) {
                return xxx;
            }
            else {
                return xxx ListOps::s_list_mask_select<T>(this, mask);
            }
#else
            xxxx;
#endif
        }
    }

    method filterSome(): List<T!Some> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!Some>{};
        }
        else {
            let mask = ListOps::s_list_map_pred<T>(this, pred(v: T): Bool => v !== none);
            if(!ListOps::s_list_has_true(mask)) {
                return List<T!Some>{};
            }
            elif(!ListOps::s_list_has_false(mask)) {
                return ListOps::s_map_fn<T, T!Some>(fl, fn(v: T): U => s_safeAs<T, T!Some>(v));
            }
            else {
                return ListOps::s_blockingfailure<List<T!Some>>();
            }
        }
    }

    method {when T unique IOption} filterSomething(): List<T!IOptionT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IOptionT>{};
        }
        else {
            let mask = ListOps::s_list_map_pred<T>(this, pred(v: T): Bool => v !== nothing);
            if(!ListOps::s_list_has_true(mask)) {
                return List<T!IOptionT>{};
            }
            elif(!ListOps::s_list_has_false(mask)) {
                return ListOps::s_map_fn<T, T!IOptionT>(fl, fn(v: T): U => s_safeAs<T, T!IOptionT>(v));
            }
            else {
                return ListOps::s_blockingfailure<List<T!IOptionT>>();
            }
        }
    }

    method {when T unique IResult} filterOk(): List<T!IResultT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IResultT>{};
        }
        else {
            let mask = ListOps::s_list_map_pred<T>(this, pred(v: T): Bool => v.isOk());
            if(!ListOps::s_list_has_true(mask)) {
                return List<T!IResultT>{};
            }
            elif(!ListOps::s_list_has_false(mask)) {
                return ListOps::s_map_fn<T, T!IResultT>(fl, fn(v: T): U => s_safeAs<T, T!IResultT>(v));
            }
            else {
                return ListOps::s_blockingfailure<List<T!IResultT>>();
            }
        }
    }

    method {when T unique IResult} filterErr(): List<T!IResultE> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IResultE>{};
        }
        else {
            let mask = ListOps::s_list_map_pred<T>(this, pred(v: T): Bool => v.isErr());
            if(!ListOps::s_list_has_true(mask)) {
                return List<T!IResultE>{};
            }
            elif(!ListOps::s_list_has_false(mask)) {
                return ListOps::s_map_fn<T, T!IResultE>(fl, fn(v: T): U => s_safeAs<T, T!IResultE>(v));
            }
            else {
                return ListOps::s_blockingfailure<List<T!IResultE>>();
            }
        }
    }

    method castType<U>(): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{};
        }
        else {
            return ListOps::s_list_map_fn<T, U>(this, fn(v: T): U => v astype U);
        }
    }

    method castSome(): List<T!Some> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!Some>{};
        }
        else {
            return ListOps::s_list_map_fn<T, T!Some>(this, fn(v: T): T!Some => v astype T!Some);
        }
    }

    method {when T unique IOption} castSomething(): List<T!IOptionT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IOptionT>{};
        }
        else {
            return ListOps::s_list_map_fn<T, T!IOptionT>(this, fn(v: T): T!IOptionT => v.data());
        }
    }

    method {when T unique IResult} castOk(): List<T!IResultT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IResultT>{};
        }
        else {
            return ListOps::s_list_map_fn<T, T!IResultT>(this, fn(v: T): T!IResultT => v.result());
        }
    }

    method {when T unique IResult} castErr(): List<T!IResultT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IResultE>{};
        }
        else {
            return ListOps::s_list_map_fn<T, T!IResultE>(this, fn(v: T): T!IResultE => v.error());
        }
    }

    method sliceStart(start: Nat): List<T> 
        requires start <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(start == 0n) {
            return this;
        }
        elif(start == ListOps::s_list_size<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_list_slice_front<T>(this, start);
        }
    }

    method sliceEnd(end: Nat): List<T> 
        requires end <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(end == 0n) {
            return List<T>{};
        }
        elif(end == ListOps::s_list_size<T>(this)) {
            return this;
        }
        else {
            return ListOps::s_list_slice_end<T>(this, end);
        }
    }

    method slice(start?: Nat=0n, end?: Nat=ListOps::s_list_size<T>(this)): List<T> 
        requires start <= end;
        requires end <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(start == end) {
            return List<T>{};
        }
        elif(/\(start == 0n, end == ListOps::s_list_size<T>(this))) {
            return this;
        }
        else {
            return ListOps::s_list_slice<T>(this, start, end - start);
        }
    }

    method removeFirst(k: Nat): List<T> 
        requires k <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(k == 0n) {
            return this;
        }
        elif(start == ListOps::s_list_size<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_list_slice_front<T>(this, k);
        }
    } 

    method removeLast(k: Nat): List<T> 
        requires k <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(k == 0n) {
            return this;
        }
        elif(k == ListOps::s_list_size<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_list_slice_end<T>(this, ListOps::s_list_size<T>(this) - k);
        }
    }

    recursive? method takeWhile(p: recursive? pred(_: T) -> Bool): List<T>  {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_false(vmap);
            if(idx == -1i) {
                return this;
            }
            elif(idx == 0i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_end<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method takeWhile(p: recursive? pred(_: T, _: Nat) -> Bool): List<T>  {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            return ListOps::s_blockingfailure<List<T>>();
        }
    }

    recursive? method discardWhile(p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_false(vmap);
            if(idx == 0i) {
                return this;
            }
            elif(idx == -1i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_start<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method discardWhile(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            return ListOps::s_blockingfailure<List<T>>();
        }
    }

    recursive? method takeUntil(p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
            if(idx == -1i) {
                return this;
            }
            elif(idx == 0i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_end<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method takeUntil(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            return ListOps::s_blockingfailure<List<T>>();
        }
    }

    recursive? method discardUntil(p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let vmap = ListOps::s_list_map_pred<T>[recursive?](this, p);
            let idx = ListOps::s_list_indexof_true(vmap);
            if(idx == 0i) {
                return this;
            }
            elif(idx == -1i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_start<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method discardUntil(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            return ListOps::s_blockingfailure<List<T>>();
        }
    }

    recursive? method map<U=?>(f: recursive? fn(_: T) -> U): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{}; 
        }
        else {
            return ListOps::s_list_map_fn<T, U>[recursive?](this, f);
        }
    }

    recursive? method map<U=?>(f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{}; 
        }
        else {
            return ListOps::s_blockingfailure<List<U>>();
        }
    }

    recursive? method mapNone<U=?>(f: recursive? fn(_: T!Some) -> U): List<U?>  {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U?>{}; 
        }
        else {
            return ListOps::s_list_map_fn<T, U?>[recursive?](this, recursive? fn(v: T): U? => {
                if(v === none) {
                    return none;
                }
                else {
                    return f[recursive?](v);
                }
            });
        }
    }

    recursive? method mapNone<U=?>(f: recursive? fn(_: T, _: Nat) -> U): List<U?> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U?>{}; 
        }
        else {
            return ListOps::s_blockingfailure<List<U?>>();
        }
    }

    recursive? method {when T unique IOption} mapOption<U=?>(f: recursive? fn(_: T!IOptionT) -> U): List<Option<U>> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<Option<U>>{}; 
        }
        else {
            return ListOps::s_list_map_fn<T, Option<U>>[recursive?](this, recursive? fn(v: T): U => {
                if(v === nothing) {
                    return nothing;
                }
                else {
                    return something(f[recursive?](v.data()));
                }
            });
        }
    }

    recursive? method {when T unique IOption} mapOption<U=?>(f: recursive? fn(_: T!IOptionT, _: Nat) -> U): List<Option<U>>  {
        if(ListOps::s_list_empty<T>(this)) {
            return List<Option<U>>{}; 
        }
        else {
            return ListOps::s_blockingfailure<List<Option<U>>>();
        }
    }

    method {when T grounded KeyType} project<U=?>(m: Map<T, U>): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{};
        }
        else {
            return ListOps::s_list_map_fn<T, U>(this, fn(v: T): U => {
                return m.get(v);
            });
        }
    }

    method {when T grounded KeyType} projectOrNone<U=?>(m: Map<T, U>): List<U?> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U?>{};
        }
        else {
            return ListOps::s_list_map_fn<T, U?>(this, fn(v: T): U => {
                return m.getOrNone(v);
            });
        }
    }

    method {when T grounded KeyType} projectOption<U=?>(m: Map<T, U>): List<Option<U>> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<Option<U>>{};
        }
        else {
            return ListOps::s_list_map_fn<T, U>(this, fn(v: T): U => {
                return m.getOrOption(v);
            });
        }
    }

    method {when T grounded KeyType} projectImage<U=?>(m: Map<T, U>): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{};
        }
        else {
            let mask = ListOps::s_list_map_pred<T>[recursive?](this, pred(v: T) => m.has(v));
            if(!ListOps::s_list_has_true(mask)) {
                return List<U>{};
            }
            elif(!ListOps::s_list_has_false(mask)) {
                return ListOps::s_list_map_fn<T, U>(this, fn(v: T): U => m.get(v));
            }
            else {
                let sti = ListOps::s_list_single_indexof_true(mask);
                if(sti != -1) {
                    return List<U>{m.get(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)))};
                }
                else {
                    return ListOps::s_blockingfailure<List<U>>();
                }
            }
        }
    }

    recursive? method join<U=?>(ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        if(\/(ListOps::s_empty<T>(this), ListOps::s_empty<T>(ol))) {
            return List<[T, U]>{};
        }
        else {
            return ListOps::s_blockingfailure<List<[T, U]>>();
            //map, filter, concat
        }
    }

    recursive? method joinGroup<U=?>(ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, List<U>]> {
        if(\/(ListOps::s_empty<T>(this), ListOps::s_empty<T>(ol))) {
            return List<[T, U]>{};
        }
        else {
            return ListOps::s_blockingfailure<List<[T, U]>>();
            //map, filter
        }
    }

    method append(l: List<T>): List<T> {
        if(/\(ListOps::s_list_empty<T>(this), ListOps::s_list_empty<T>(l))) {
            return List<T>{};
        }
        elif(ListOps::s_list_empty<T>(this)) {
            return l;
        }
        elif(ListOps::s_list_empty<T>(l)) {
            return this;
        }
        else {
            return ListOps::s_list_append<T>(this, l);
        }
    }

    method prepend(l: List<T>): List<T> {
        if(/\(ListOps::s_list_empty<T>(this), ListOps::s_list_empty<T>(l))) {
            return List<T>{};
        }
        elif(ListOps::s_list_empty<T>(this)) {
            return l;
        }
        elif(ListOps::s_list_empty<T>(l)) {
            return this;
        }
        else {
            return ListOps::s_list_append<T>(l, this);
        }
    }

    recursive? method partition<K grounded KeyType=?>(pf: recursive? fn(_: T) -> K): Map<K, List<T>> {
        if(ListOps::s_list_empty<T>(this)) {
            return Map<K, List<T>>{};
        }
        else {
            return ListOps::s_blockingfailure<Map<K, List<T>>>();
            //implement using other primitives or do some UF magic?
        }
    }

    recursive? method sort(cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_blockingfailure<List<T>>();
        }
    }

    recursive? method uniqueify(cmp: recursive? pred(_: T, _: T) -> Bool, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_blockingfailure<List<T>>();
        }
    }

    method reverse(): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_blockingfailure<List<T>>();
        }
    }

    method pushBack(v: T): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{v};
        }
        else {
            return ListOps::s_list_push_back<T>(this, v);
        }
    }

    method pushFront(v: T): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{v};
        }
        else {
            return ListOps::s_list_push_front<T>(this, v);
        }
    }

    method popBack(): List<T> 
        requires !ListOps::s_list_empty<T>(this);
    {
        return ListOps::s_list_pop_back<T>(this);
    }

    method popFront(): List<T> 
        requires !ListOps::s_list_empty<T>(this);
    {
        return ListOps::s_list_pop_front<T>(this);
    }

    method set(i: Nat, v: T): List<T> 
        requires i < ListOps::s_list_size<T>(this);
    {
        return ListOps::s_list_set<T>(this, i, v);
    }

    method remove(i: Nat): List<T> 
        requires i < ListOps::s_list_size<T>(this);
    {
        return ListOps::s_list_remove<T>(this, i);
    }

    //TODO: we can make this inferable later when we have a better infer procedure for lambdas 
    //      (since the U is in the body and the return type this may fail in the checker if we run it today)
    recursive? method reduce<U>(init: U, f: recursive? fn(_: U, _: T) -> U): U {
        if(ListOps::s_list_empty<T>(this)) {
            return init;
        }
        else {
            return ListOps::s_list_reduce<T, U>[recursive?](this, init, f);
        }
    }

    recursive? method reduce<U>(init: U, f: recursive? fn(_: U, _: T, _: Nat) -> U): U {
        if(ListOps::s_list_empty<T>(this)) {
            return init;
        }
        else {
            return ListOps::s_blockingfailure<U>();
        }
    }

    recursive? method transduce<E, U>(env: E, f: recursive? fn(_: T, _: E) -> (|E, U|)): (|E, List<U>|) {
        if(ListOps::s_list_empty<T>(this)) {
            return (|env, List<U>{}|);
        }
        else {
            //TODO: this is wrong but we need to do it
            assert false;
            return (|env, List<U>{}|);
        }
    }

    recursive? method transduce<E, U>(env: E, f: recursive? fn(_: T, _: E, _: Nat) -> (|E, U|)): (|E, List<U>|) {
        if(ListOps::s_list_empty<T>(this)) {
            return (|env, List<U>{}|);
        }
        else {
            //TODO: this is wrong but we need to do it
            assert false;
            return (|env, List<U>{}|);
        }
    }

    //
    //TODO: ref versions of the add/remove/set operators
    //

    //
    //TODO: Convert to Map<K, V> and Set<T> operations
    //
}
