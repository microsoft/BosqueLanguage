//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

__internal entity List<T> provides Some, Expandoable<T>, APIType when T grounded APIType, TestableType when T grounded TestableType {
    internal function s_append_helper(l1: List<T>, l2: List<T>): List<T> {
        if(/\(ListOps::s_list_empty<T>(l1), ListOps::s_list_empty<T>(l2))) {
            return List<T>{};
        }
        elif(ListOps::s_list_empty<T>(l1)) {
            return l2;
        }
        elif(ListOps::s_list_empty<T>(l2)) {
            return l1;
        }
        else {
            return ListOps::s_list_append<T>(l1, l2);
        }
    }

    function rangeInt(start: Int, end: Int): List<Int>
        requires start <= end;
    {
        if(start == end) {
            return List<Int>{};
        }
        else {
            return ListOps::s_list_index_int(start, end, end - start);
        }
    }

    function rangeNat(start: Nat, end: Nat): List<Nat>
        requires start <= end;
    {
        if(start == end) {
            return List<Nat>{};
        }
        else {
            return ListOps::s_list_index_nat(start, end, end - start);
        }
    }

    method index(): List<[Nat, T]> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<[Nat, T]>{};
        }
        else {
            return ListOps::s_list_map_fn_idx<T, [Nat, T]>(this, fn(v: T, idx: Nat): [Nat, T] => [idx, v]);
        }
    }

    method zip<U=?>(l: List<U>): List<[T, U]>
        requires ListOps::s_list_size<T>(this) == ListOps::s_list_size<U>(l);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<[T, U]>{};
        }
        else {
            return ListOps::s_list_map_fn_sync<T, U, [T, U]>(this, l, fn(v1: T, v2: U): [T, U] => [v1, v2]);
        }
    }

    method zipMap<U=?, V=?>(l: List<U>, f: recursive? fn(_: T, _: U) -> V): List<V>
        requires ListOps::s_list_size<T>(this) == ListOps::s_list_size<U>(l);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<V>{};
        }
        else {
            return ListOps::s_list_map_fn_sync<T, U, V>[recursive?](this, l, f);
        }
    }

    function fill(k: Nat, val: T): List<T> {
        if(k == 0n) {
            return List<T>{};
        }
        else {
            return ListOps::s_list_fill<T>(k, val);
        }
    }

    function concat(...ll: List<List<T>>): List<T> {
        if(ListOps::s_list_empty<List<T>>(ll)) {
            return List<T>{};
        }
        else {
            let ilist = ListOps::s_list_front<List<T>>(ll);
            let tl = ListOps::s_list_pop_front<List<T>>(ll);
            if(ListOps::s_list_empty<List<T>>(tl)) {
                return ilist;
            }
            else {
                return ListOps::s_list_reduce<List<T>, List<T>>(tl, ilist, fn(acc: List<T>, argl: List<T>): List<T> => {
                    return List<T>::s_append_helper(acc, argl);
                });
            }
        }
    }

    method size(): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
            return ListOps::s_list_size<T>(this);
        }
    }

    method empty(): Bool {
        return ListOps::s_list_empty<T>(this);
    }

    method front(): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        return ListOps::s_list_front<T>(this);
    }

    method frontOrNone(): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            return ListOps::s_list_front<T>(this);
        }
    }

    method frontOption(): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            return something(ListOps::s_list_front<T>(this));
        }
    }

    method frontTry(out? res: T): Bool {
        if(!ListOps::s_list_empty<T>(this)) {
            res = ListOps::s_list_front<T>(this);
            return true;
        }
        else {
            return false;
        }
    }

    method back(): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        return ListOps::s_list_back<T>(this);
    }

    method backOrNone(): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            return ListOps::s_list_back<T>(this);
        }
    }

    method backOption(): Option<T> {
        if(ListOps::s_list_empty<T>(this)){
            return nothing;
        }
        else {
            return something(ListOps::s_list_back<T>(this));
        }
    }

    method backTry(out? res: T): Bool {
        if(!ListOps::s_list_empty<T>(this)) {
            res = ListOps::s_list_back<T>(this);
            return true;
        }
        else {
            return false;
        }
    }

    method get(i: Nat): T
        requires i < ListOps::s_list_size<T>(this);
    {
        return ListOps::s_list_get<T>(this, i);
    }

    method getOrNone(i: Nat): T? {
        if(i < ListOps::s_list_size<T>(this)) {
            return ListOps::s_list_get<T>(this, i);
        }
        else {
            return none;
        }
    }

    method getOption(i: Nat): Option<T> {
        if(i < ListOps::s_list_size<T>(this)) {
            return something(ListOps::s_list_get<T>(this, i));
        }
        else {
            return nothing;
        }
    }

    method getTry(i: Nat, out? res: T): Bool {
        if(i < ListOps::s_list_size<T>(this)) {
            res = ListOps::s_list_get<T>(this, i);
            return true;
        }
        else {
            return false;
        }
    }

    recursive? method single(p: recursive? pred(_: T) -> Bool): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_single_index_of<T>[recursive?](this, p);
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method singleOrNone(p: recursive? pred(_: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            let idx = ListOps::s_list_single_index_of<T>[recursive?](this, p);

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method singleOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            let idx = ListOps::s_list_single_index_of<T>[recursive?](this, p);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method singleTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            let idx = ListOps::s_list_single_index_of<T>[recursive?](this, p);

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    method getSingleton(): T 
        requires ListOps::s_list_size<T>(this) == 1n;
    {
        return ListOps::s_list_front<T>(this);
    }

    method getSingletonOrNone(): T? {
        if(ListOps::s_list_size<T>(this) != 1n) {
            return none;
        }
        else {
            return ListOps::s_list_front<T>(this);
        }
    }

    recursive? method getSingletonOption(): Option<T> {
        if(ListOps::s_list_size<T>(this) != 1n) {
            return nothing;
        }
        else {
            return something(ListOps::s_list_front<T>(this));
        }
    }

    recursive? method getSingletonTry(out? res: T): Bool {
        if(ListOps::s_list_size<T>(this) != 1n) {
            return false;
        }
        else {
            res = ListOps::s_list_front<T>(this);
            return true;
        }
    }

    recursive? method allOf(p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return true;
        }
        else {
            return !ListOps::s_list_has_pred<T>[recursive?](this, recursive? pred(v: T): Bool => !p[recursive?](v));
        }
    }

    recursive? method allOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return true;
        }
        else {
            return !ListOps::s_list_has_pred_idx<T>[recursive?](this, recursive? pred(v: T, idx: Nat): Bool => !p[recursive?](v, idx));
        }
    }

    recursive? method noneOf(p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return true;
        }
        else {
            return !ListOps::s_list_has_pred<T>[recursive?](this, p);
        }
    }

    recursive? method noneOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return true;
        }
        else {
            return !ListOps::s_list_has_pred_idx<T>[recursive?](this, p);
        }
    }

    recursive? method someOf(p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return ListOps::s_list_has_pred<T>[recursive?](this, p);
        }
    }

    recursive? method someOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return ListOps::s_list_has_pred_idx<T>[recursive?](this, p);
        }
    }

    recursive? method countIf(p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
            return ListOps::s_list_reduce<T, Nat>(this, 0n, recursive? fn(acc: Nat, v: T): Nat => {
                if(p[recursive?](v)) {
                    return acc + 1n;
                    }
                else { 
                    return acc;
                }
            });
        }
    }

    recursive? method countIf(p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
            return ListOps::s_list_reduce_idx<T, Nat>(this, 0n, recursive? fn(acc: Nat, v: T, idx: Nat): Nat =>  {
                if(p[recursive?](v, idx)) {
                    return acc + 1n;
                }
                else { 
                    return acc;
                }
            });
        }
    }

    method {when T grounded KeyType} contains(v: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return ListOps::s_list_has<T>(this, v);
        }
    }

    method {when T KeyType} containsNone(): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return ListOps::s_list_has<T>(this, none);
        }
    }

    //TODO: not quite right since we also want to make sure this is Option<T> *not* IOption
    method {when T unique IOption} containsNothing(): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return ListOps::s_list_has_pred<T>(this, pred(e: T): Bool => e.isNothing());
        }
    }

    //TODO: not quite right since we also want to make sure this is Result<T, E> *not* IResult
    method {when T unique IResult} containsError(): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return ListOps::s_list_has_pred<T>(this, pred(e: T): Bool => e.isErr());
        }
    }

    //TODO: not quite right since we also want to make sure this is Result<T, E> *not* IResult
    method {when T unique IResult} allOk(): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            return !ListOps::s_list_has_pred<T>(this, pred(e: T): Bool => e.isErr());
        }
    }

    method {when T grounded KeyType} count(v: T): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
            return ListOps::s_list_reduce<T, Nat>(this, 0n, fn(acc: Nat, v: T): Nat => {
                if(KeyType::equal<T>(v, e)) {
                    return acc + 1n;
                }
                else {
                    return acc;
                }
            });
        }
    }

    method countNone(): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
            return ListOps::s_list_reduce<T, Nat>(this, 0n, fn(acc: Nat, v: T): Nat => {
                if(v === none) {
                    return acc + 1n;
                }
                else { 
                    return acc;
                }
            });
        }
    }

    method countNothing(): Nat {
        if(ListOps::s_list_empty<T>(this)) {
            return 0n;
        }
        else {
            return ListOps::s_list_reduce<T, Nat>(this, 0n, fn(acc: Nat, v: T): Nat => {
                if(v.isNothing()) {
                    return acc + 1n;
                }
                else { 
                    return acc;
                }
            });
        }
    }

    method {when T unique Orderable} min(): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        let iv = ListOps::s_list_front<T>(this);
        let tl = ListOps::s_list_pop_front<T>(this);
        if(ListOps::s_list_empty<T>(tl)) {
            return iv;
        }
        else {
            return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                if(v < acc) {
                    return v;
                }
                else {
                    return acc;
                }
            });
        }
    }

    method {when T unique Orderable} max(): T
        requires !ListOps::s_list_empty<T>(this);
    {
        let iv = ListOps::s_list_front<T>(this);
        let tl = ListOps::s_list_pop_front<T>(this);
        if(ListOps::s_list_empty<T>(tl)) {
            return iv;
        }
        else {
            return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                if(v > acc) {
                    return v;
                }
                else {
                    return acc;
                }
            });
        }
    }

    method {when T unique Orderable} minOrNone(): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v < acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
            }
        }
    }

    method {when T unique Orderable} maxOrNone(): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v > acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
            }
        }
    }

    method {when T unique Orderable} minOption(): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return something(iv);
            }
            else {
                let res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v < acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return something(res);
            }
        }
    }

    method {when T unique Orderable} maxOrOption(): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return something(iv);
            }
            else {
                let res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v > acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return something(res);
            }
        }
    }

    method {when T unique Orderable} minTry(out? res: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                res = iv;
                return true;
            }
            else {
                res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v < acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return true;
            }
        }
    }

    method {when T unique Orderable} maxTry(out? res: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                res = iv;
                return true;
            }
            else {
                res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(v > acc) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
                
                return true;
            }
        }
    }

    method argMin(cmp: recursive? pred(_: T, _: T) -> Bool): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        let iv = ListOps::s_list_front<T>(this);
        let tl = ListOps::s_list_pop_front<T>(this);
        if(ListOps::s_list_empty<T>(tl)) {
            return iv;
        }
        else {
            return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                if(cmp[recursive?](v, acc)) {
                    return v;
                }
                else {
                    return acc;
                }
            });
        }
    }

    method argMax(cmp: recursive? pred(_: T, _: T) -> Bool): T
        requires !ListOps::s_list_empty<T>(this);
    {
        let iv = ListOps::s_list_front<T>(this);
        let tl = ListOps::s_list_pop_front<T>(this);
        if(ListOps::s_list_empty<T>(tl)) {
            return iv;
        }
        else {
            return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                if(cmp[recursive?](acc, v)) {
                    return v;
                }
                else {
                    return acc;
                }
            });
        }
    }

    method argMinOrNone(cmp: recursive? pred(_: T, _: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](v, acc)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
            }
        }
    }

    method argMaxOrNone(cmp: recursive? pred(_: T, _: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](acc, v)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });
            }
        }
    }

    method argMinOption(cmp: recursive? pred(_: T, _: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return something(iv);
            }
            else {
                let res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](v, acc)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return something(res);
            }
        }
    }

    method argMaxOrOption(cmp: recursive? pred(_: T, _: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return something(iv);
            }
            else {
                let res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](acc, v)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return something(res);
            }
        }
    }

    method argMinTry(out? res: T, cmp: recursive? pred(_: T, _: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                res = iv;
                return true;
            }
            else {
                res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](v, acc)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return true;
            }
        }
    }

    method argMaxTry(out? res: T, cmp: recursive? pred(_: T, _: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                res = iv;
                return true;
            }
            else {
                res = ListOps::s_list_reduce<T, T>(tl, iv, fn(acc: T, v: T): T => {
                    if(cmp[recursive?](acc, v)) {
                        return v;
                    }
                    else {
                        return acc;
                    }
                });

                return true;
            }
        }
    }

    method {when T unique Algebraic} sum(): T {
        if(ListOps::s_list_empty<T>(this)) {
            return T::zero;
        }
        else {
            let iv = ListOps::s_list_front<T>(this);
            let tl = ListOps::s_list_pop_front<T>(this);
            if(ListOps::s_list_empty<T>(tl)) {
                return iv;
            }
            else {
                return ListOps::s_list_reduce<T, T>(tl, iv, fn(a: T, b: T): T => (a + b));
            }
        }
    }

    recursive? method find(p: recursive? pred(_: T) -> Bool): T
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method find(p: recursive? pred(_: T, _: Nat) -> Bool): T
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method findOrNone(p: recursive? pred(_: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method findOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    recursive? method findLast(p: recursive? pred(_: T) -> Bool): T 
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method findLast(p: recursive? pred(_: T, _: Nat) -> Bool): T
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);
        assert idx != -1i;

        return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): T? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return none;
            }
            else {
                return ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findLastOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method findLastOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx)));
            }
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return false;
            }
            else {
                res = ListOps::s_list_get<T>(this, NumericOps::s_intToNat(idx));
                return true;
            }
        }
    }

    recursive? method findIndexOf(p: recursive? pred(_: T) -> Bool): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);

        assert idx != -1i;
        return NumericOps::s_intToNat(idx);
    }

    recursive? method findIndexOf(p: recursive? pred(_: T, _: Nat) -> Bool): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);

        assert idx != -1i;
        return NumericOps::s_intToNat(idx);
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    recursive? method findIndexOfOption(p: recursive? pred(_: T) -> Bool): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findIndexOfOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T) -> Bool): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);

        assert idx != -1i;
        return NumericOps::s_intToNat(idx);
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T, _: Nat) -> Bool): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);

        assert idx != -1i;
        return NumericOps::s_intToNat(idx);
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    recursive? method findIndexOfLastOption(p: recursive? pred(_: T) -> Bool): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findIndexOfLastOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last<T>[recursive?](this, p);

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_find_pred_last_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    method {when T grounded KeyType} indexOf(v: T): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_indexof<T>(this, v);

        assert idx != -1i;
        return idx;
    }

    method {when T grounded KeyType} indexOfOrNone(v: T): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_indexof<T>(this, v);

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    method {when T grounded KeyType} indexOfOption(v: T): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_indexof<T>(this, v);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    method {when T grounded KeyType} indexOfTry(out? res: Nat, v: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_indexof<T>(this, v);

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    method {when T grounded KeyType} indexOfLast(v: T): Nat
        requires !ListOps::s_list_empty<T>(this);
    {
        let idx = ListOps::s_list_last_indexof<T>(this, v);

        assert idx != -1i;
        return idx;
    }

    method {when T grounded KeyType} indexOfLastOrNone(v: T): Nat? {
        if(ListOps::s_list_empty<T>(this)) {
            return none; 
        }
        else {
            let idx = ListOps::s_list_last_indexof<T>(this, v);

            if(idx == -1i) {
                return none;
            }
            else {
                return NumericOps::s_intToNat(idx);
            }
        }
    }

    method {when T grounded KeyType} indexOfLastOption(v: T): Option<Nat> {
        if(ListOps::s_list_empty<T>(this)) {
            return nothing; 
        }
        else {
            let idx = ListOps::s_list_last_indexof<T>(this, v);

            if(idx == -1i) {
                return nothing;
            }
            else {
                return something(NumericOps::s_intToNat(idx));
            }
        }
    }

    method {when T grounded KeyType} indexOfLastTry(out? res: Nat, v: T): Bool {
        if(ListOps::s_list_empty<T>(this)) {
            return false; 
        }
        else {
            let idx = ListOps::s_list_last_indexof<T>(this, v);

            if(idx == -1i) {
                return false;
            }
            else {
                res = NumericOps::s_intToNat(idx);
                return true;
            }
        }
    }

    recursive? method filter(p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_filter_pred<T>[recursive?](this, p);
        }
    }

    recursive? method filter(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_filter_pred_idx<T>[recursive?](this, p);
        }
    }

    method filterType<U>(): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{};
        }
        else {
            return ListOps::s_list_filter_map_fn<T, U>(this, pred(v: T): Bool => v.is<U>(), fn(vv: T): U => s_safeAs<T, U>(vv));
        }
    }

    method filterSome(): List<T!Some> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!Some>{};
        }
        else {
            return ListOps::s_list_filter_map_fn<T, T!Some>(this, pred(v: T): Bool => v.is<T!Some>(), fn(vv: T): T!Some => s_safeAs<T, T!Some>(vv));
        }
    }

    method {when T unique IOption} filterSomething(): List<T!IOptionT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IOptionT>{};
        }
        else {
            return ListOps::s_list_filter_map_fn<T, T!IOptionT>(this, pred(v: T): Bool => v.is<T!IOptionT>(), fn(vv: T): T!IOptionT => s_safeAs<T, T!IOptionT>(vv));
        }
    }

    method {when T unique IResult} filterOk(): List<T!IResultT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IResultT>{};
        }
        else {
            ListOps::s_list_filter_map_fn<T, T!IResultT>(this, pred(v: T): Bool => v.is<T!IResultT>(), fn(vv: T): T!IResultT => s_safeAs<T, T!IResultT>(vv));
        }
    }

    method {when T unique IResult} filterErr(): List<T!IResultE> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IResultE>{};
        }
        else {
            ListOps::s_list_filter_map_fn<T, T!IResultE>(this, pred(v: T): Bool => v.is<T!IResultE>(), fn(vv: T): T!IResultE => s_safeAs<T, T!IResultE>(vv));
        }
    }

    method castType<U>(): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{};
        }
        else {
            return ListOps::s_list_map_fn<T, U>(this, fn(v: T): U => v.as<U>());
        }
    }

    method castSome(): List<T!Some> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!Some>{};
        }
        else {
            return ListOps::s_list_map_fn<T, T!Some>(this, fn(v: T): T!Some => v.as<T!Some>());
        }
    }

    method {when T unique IOption} castSomething(): List<T!IOptionT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IOptionT>{};
        }
        else {
            return ListOps::s_list_map_fn<T, T!IOptionT>(this, fn(v: T): T!IOptionT => v.data());
        }
    }

    method {when T unique IResult} castOk(): List<T!IResultT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IResultT>{};
        }
        else {
            return ListOps::s_list_map_fn<T, T!IResultT>(this, fn(v: T): T!IResultT => v.result());
        }
    }

    method {when T unique IResult} castErr(): List<T!IResultT> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T!IResultE>{};
        }
        else {
            return ListOps::s_list_map_fn<T, T!IResultE>(this, fn(v: T): T!IResultE => v.error());
        }
    }

    method sliceStart(start: Nat): List<T> 
        requires start <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(start == 0n) {
            return this;
        }
        elif(start == ListOps::s_list_size<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_list_slice_front<T>(this, start);
        }
    }

    method sliceEnd(end: Nat): List<T> 
        requires end <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(end == 0n) {
            return List<T>{};
        }
        elif(end == ListOps::s_list_size<T>(this)) {
            return this;
        }
        else {
            return ListOps::s_list_slice_end<T>(this, end);
        }
    }

    method slice(start?: Nat=0n, end?: Nat=ListOps::s_list_size<T>(this)): List<T> 
        requires start <= end;
        requires end <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(start == end) {
            return List<T>{};
        }
        else {
            if(/\(start == 0n, end == ListOps::s_list_size<T>(this))) {
                return this;
            }
            elif(start == 0n) {
                return ListOps::s_list_slice_end<T>(this, end);
            }
            elif(end == ListOps::s_list_size<T>(this)) {
                return ListOps::s_list_slice_start<T>(this, start);
            }
            else {
                return ListOps::s_list_slice<T>(this, start, end - start);
            }
        }
    }

    method removeFirst(k: Nat): List<T> 
        requires k <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(k == 0n) {
            return this;
        }
        elif(k == ListOps::s_list_size<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_list_slice_start<T>(this, k);
        }
    } 

    method removeLast(k: Nat): List<T> 
        requires k <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        elif(k == 0n) {
            return this;
        }
        elif(k == ListOps::s_list_size<T>(this)) {
            return List<T>{};
        }
        else {
            return ListOps::s_list_slice_end<T>(this, ListOps::s_list_size<T>(this) - k);
        }
    }

    recursive? method takeWhile(p: recursive? pred(_: T) -> Bool): List<T>  {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, recursive? pred(v: T) => !p[recursive?](v));

            if(idx == -1i) {
                return this;
            }
            elif(idx == 0i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_end<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method takeWhile(p: recursive? pred(_: T, _: Nat) -> Bool): List<T>  {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, recursive? pred(v: T, idx: Nat) => !p[recursive?](v, idx));

            if(idx == -1i) {
                return this;
            }
            elif(idx == 0i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_end<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method discardWhile(p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, recursive? pred(v: T) => !p[recursive?](v));

            if(idx == 0i) {
                return this;
            }
            elif(idx == -1i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_start<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method discardWhile(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, recursive? pred(v: T, idx: Nat) => !p[recursive?](v, idx));

            if(idx == 0i) {
                return this;
            }
            elif(idx == -1i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_start<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method takeUntil(p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);

            if(idx == -1i) {
                return this;
            }
            elif(idx == 0i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_end<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method takeUntil(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);

            if(idx == -1i) {
                return this;
            }
            elif(idx == 0i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_end<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method discardUntil(p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let idx = ListOps::s_list_find_pred<T>[recursive?](this, p);

            if(idx == 0i) {
                return this;
            }
            elif(idx == -1i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_start<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method discardUntil(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{}; 
        }
        else {
            let idx = ListOps::s_list_find_pred_idx<T>[recursive?](this, p);

            if(idx == 0i) {
                return this;
            }
            elif(idx == -1i) {
                return List<T>{};
            }
            else {
                return ListOps::s_list_slice_start<T>(this, NumericOps::s_intToNat(idx));
            }
        }
    }

    recursive? method map<U=?>(f: recursive? fn(_: T) -> U): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{}; 
        }
        else {
            return ListOps::s_list_map_fn<T, U>[recursive?](this, f);
        }
    }

    recursive? method map<U=?>(f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{}; 
        }
        else {
            return ListOps::s_list_map_fn_idx<T, U>[recursive?](this, f);
        }
    }

    recursive? method mapNone<U=?>(f: recursive? fn(_: T!Some) -> U): List<U?>  {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U?>{}; 
        }
        else {
            return ListOps::s_list_map_fn<T, U?>[recursive?](this, recursive? fn(v: T): U? => {
                if(v === none) {
                    return none;
                }
                else {
                    return f[recursive?](v);
                }
            });
        }
    }

    recursive? method mapNone<U=?>(f: recursive? fn(_: T, _: Nat) -> U): List<U?> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U?>{}; 
        }
        else {
            return ListOps::s_list_map_fn_idx<T, U?>[recursive?](this, recursive? fn(v: T, idx: Nat): U? => {
                if(v === none) {
                    return none;
                }
                else {
                    return f[recursive?](v, idx);
                }
            });
        }
    }

    recursive? method {when T unique IOption} mapOption<U=?>(f: recursive? fn(_: T!IOptionT) -> U): List<Option<U>> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<Option<U>>{}; 
        }
        else {
            return ListOps::s_list_map_fn<T, Option<U>>[recursive?](this, recursive? fn(v: T): U => {
                if(v === nothing) {
                    return nothing;
                }
                else {
                    return something(f[recursive?](v.data()));
                }
            });
        }
    }

    recursive? method {when T unique IOption} mapOption<U=?>(f: recursive? fn(_: T!IOptionT, _: Nat) -> U): List<Option<U>>  {
        if(ListOps::s_list_empty<T>(this)) {
            return List<Option<U>>{}; 
        }
        else {
            return ListOps::s_list_map_fn_idx<T, Option<U>>[recursive?](this, recursive? fn(v: T, idx: Nat): U => {
                if(v === nothing) {
                    return nothing;
                }
                else {
                    return something(f[recursive?](v.data(), idx));
                }
            });
        }
    }

    method {when T grounded KeyType} project<U=?>(m: Map<T, U>): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{};
        }
        else {
            return ListOps::s_list_map_fn<T, U>(this, fn(v: T): U => {
                return m.get(v);
            });
        }
    }

    method {when T grounded KeyType} projectOrNone<U=?>(m: Map<T, U>): List<U?> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U?>{};
        }
        else {
            return ListOps::s_list_map_fn<T, U?>(this, fn(v: T): U => {
                if(!m.has(v)) {
                    return none;
                }
                else {
                    return m.get(v);
                }
            });
        }
    }

    method {when T grounded KeyType} projectOption<U=?>(m: Map<T, U>): List<Option<U>> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<Option<U>>{};
        }
        else {
            return ListOps::s_list_map_fn<T, Option<U>>(this, fn(v: T): Option<U> => {
                if(!m.has(v)) {
                    return nothing;
                }
                else {
                    return something(m.get(v));
                }
            });
        }
    }

    method {when T grounded KeyType} projectImage<U=?>(m: Map<T, U>): List<U> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<U>{};
        }
        else {
            return ListOps::s_list_filter_map_fn<T, U>(this, pred(v: T): Bool => m.has(v), fn(v: T): U => m.get(v));
        }
    }

    recursive? method joinGroup<U=?>(ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, List<U>]> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<[T, List<U>]>{};
        }
        elif(ListOps::s_list_empty<U>(ol)) {
            return ListOps::s_list_map_fn<T, [T, List<U>]>(this, fn(v: T): [T, List<U>] => [v, List<U>{}]);
        }
        else {
            return ListOps::s_list_map_fn<T, [T, List<U>]>(this, recursive? fn(v: T): [T, List<U>] => {
                return [v, ListOps::s_filter_pred<U>[recursive?](ol, recursive? pred(u: U): Bool => p[recursive?](v, u))];
            });
        }
    }

    recursive? method join<U=?>(ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        if(\/(ListOps::s_empty<T>(this), ListOps::s_empty<T>(ol))) {
            return List<[T, U]>{};
        }
        else {
            return ListOps::s_list_reduce<T, List<[T, U]>>(this, List<[T, U]>{}, recursive? fn(acc: List<[T, U]>, v: T): List<[T, U]> => {
                let ull = ListOps::s_filter_pred<U>[recursive?](ol, recursive? pred(u: U): Bool => p[recursive?](v, u));

                if(ListOps::s_list_empty<T>(ull)) {
                    return acc;
                }
                else {
                    let accp = ListOps::s_list_map_fn<U, [T, U]>(ull, fn(u: U): [T, U] => [v, u]);
                    return List<[T, U]>::s_append_helper(acc, ull);
                }
            });
        }
    }

    method append(l: List<T>): List<T> {
        return List<T>::s_append_helper<T>(this, l);
    }

    method prepend(l: List<T>): List<T> {
        return List<T>::s_append_helper<T>(l, this);
    }

    recursive? method partition<K grounded KeyType=?>(pf: recursive? fn(_: T) -> K): Map<K, List<T>> {
        if(ListOps::s_list_empty<T>(this)) {
            return Map<K, List<T>>{};
        }
        else {
            return ListOps::s_list_reduce<T, Map<K, List<T>>>[recursive?](this, Map<K, List<T>>{}, recursive? fn(acc: Map<K, List<T>>, v: T): Map<K, List<T>> => {
                let k = pf[recursive?](v);
                if(!acc.has(k)) {
                    return acc.add(k, List<T>{v});
                }
                else {
                    let nll = ListOps::s_list_push_back(acc.get(k), v);
                    return acc.set(k, nll);
                }
            });
        }
    }

    recursive? method sort(cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
            if(ListOps::s_list_size<T>(this) == 1) {
                return this;
            }
            else {
#if CHECK_LIBS
                if(ListOps::s_list_is_sorted<T>[recursive?](this, cmp)) {
                    return this;
                }
                else {
                    return ListOps::s_list_reduce<T, List<T>>[recursive?](this, List<T>{}, recursive? fn(acc: List<T>, v: T): List<T> => {
                        if(ListOps::s_empty<T>(acc)) {
                            return List<T>{v};
                        }
                        else {
                            let iidx = ListOps::s_list_find_pred<T>[recursive?](acc, recursive? pred(accv: T): Bool => cmp[recursive?](accv, v));
                            
                            if(iidx == -1i) {
                                return ListOps::s_list_push_back<T>(acc, v);
                            }
                            elif(iidx == 0) {
                                return ListOps::s_list_push_front<T>(acc, v);
                            }
                            else {
                                return ListOps::s_list_insert<T>(acc, iidx, v);
                            }
                        }
                    });
                }
#else
                xxxx; //TODO: implement in Bosque for runtime -- merge sort?
#endif
            }
        }
    }

    recursive? method uniqueify<K grounded KeyType>(keyf: recursive? fn(_: T) -> K): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
            if(ListOps::s_list_size<T>(this) == 1) {
                return this;
            }
            else {
#if CHECK_LIBS
                //TODO: this is rough, maybe a special \forall UF type thing would be better
                return ListOps::s_list_reduce<T, List<T>>[recursive?](this, List<T>{}, recursive? fn(acc: List<T>, v: T): List<T> => {
                    if(ListOps::s_empty<T>(acc)) {
                        return List<T>{v};
                    }
                    else {
                        let vk = keyf[recursive?](v);
                        let hasv = ListOps::s_list_has_pred<T>[recursive?](acc, recursive? pred(accv: T): Bool => KeyType<K>::equal(keyf[recursive?](accv), kv));
                        if(hasv) {
                            return acc;
                        }
                        else {
                            return ListOps::s_list_push_back<T>(acc, v);
                        }
                    }
                });
#else
                xxxx; //TODO: implement in Bosque for runtime -- use map and reduce
#endif
            }
        }
    }

    method reverse(): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{};
        }
        else {
            if(ListOps::s_list_size<T>(this) == 1) {
                return this;
            }
            else {
                return ListOps::s_list_reverse<T>(this);
            }
        }
    }

    method pushBack(v: T): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{v};
        }
        else {
            return ListOps::s_list_push_back<T>(this, v);
        }
    }

    method pushFront(v: T): List<T> {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{v};
        }
        else {
            return ListOps::s_list_push_front<T>(this, v);
        }
    }

    method popBack(): List<T> 
        requires !ListOps::s_list_empty<T>(this);
    {
        return ListOps::s_list_pop_back<T>(this);
    }

    method popFront(): List<T> 
        requires !ListOps::s_list_empty<T>(this);
    {
        return ListOps::s_list_pop_front<T>(this);
    }

    method set(i: Nat, v: T): List<T> 
        requires i < ListOps::s_list_size<T>(this);
    {
        return ListOps::s_list_set<T>(this, i, v);
    }

    method insert(i: Nat, v: T): List<T> 
        requires i <= ListOps::s_list_size<T>(this);
    {
        if(ListOps::s_list_empty<T>(this)) {
            return List<T>{v};
        }
        else {
            return ListOps::s_list_insert<T>(this, i, v);
        }
    }

    method remove(i: Nat): List<T> 
        requires i < ListOps::s_list_size<T>(this);
    {
        return ListOps::s_list_remove<T>(this, i);
    }

    //TODO: we can make this inferable later when we have a better infer procedure for lambdas 
    //      (since the U is in the body and the return type this may fail in the checker if we run it today)
    recursive? method reduce<U>(init: U, f: recursive? fn(_: U, _: T) -> U): U {
        if(ListOps::s_list_empty<T>(this)) {
            return init;
        }
        else {
            return ListOps::s_list_reduce<T, U>[recursive?](this, init, f);
        }
    }

    recursive? method reduce<U>(init: U, f: recursive? fn(_: U, _: T, _: Nat) -> U): U {
        if(ListOps::s_list_empty<T>(this)) {
            return init;
        }
        else {
            return ListOps::s_list_reduce_idx<T, U>[recursive?](this, init, f);
        }
    }

    recursive? method transduce<E, U>(env: E, f: recursive? fn(_: T, _: E) -> (|E, U|)): (|E, List<U>|) {
        if(ListOps::s_list_empty<T>(this)) {
            return (|env, List<U>{}|);
        }
        else {
            return ListOps::s_list_transduce<T, E, U>[recursive?](this, env, f);
        }
    }

    recursive? method transduce<E, U>(env: E, f: recursive? fn(_: T, _: E, _: Nat) -> (|E, U|)): (|E, List<U>|) {
        if(ListOps::s_list_empty<T>(this)) {
            return (|env, List<U>{}|);
        }
        else {
            return ListOps::s_list_transduce_idx<T, E, U>[recursive?](this, env, f);
        }
    }

    //
    //TODO: ref versions of the add/remove/set operators
    //

    //
    //TODO: Convert to Map<K, V> and Set<T> operations
    //
}
