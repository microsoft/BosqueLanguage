//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

__internal entity List<T> provides Some, Expandoable<T>, APIType when T grounded APIType, TestableType when T grounded TestableType {
    private function s_into(l: ListRepr<T>): List<T> = special_inject;
    method value(): ListRepr<T> = special_extract;

    function rangeInt(start: Int, end: Int): List<Int>
        requires start <= end;
    {
        return List<Int>::s_into(ListOps::s_range<Int>(start, end, 1i, (end - start).toNat()));
    }

    function rangeNat(start: Int, end: Int): List<Nat>
        requires start <= end;
    {
        return List<Nat>::s_into(ListOps::s_range<Nat>(start, end, 1n, end - start));
    }

    method index(): List<[Nat, T]> {
        return List<[Nat, T]>::s_into(ListOps::s_zip_index<T>(this.value()));
    }

    method zip<U=?>(l: List<U>): List<[T, U]>
        requires ListOps::s_size<T>(this) == ListOps::s_size<U>(l);
    {
        return List<[T, U]>::s_into(ListOps::s_zip<T, U>(this.value(), l));
    }

    function fill(k: Nat, val: T): List<T> {
        return List<T>::s_into(ListOps::s_fill<T>(k, val));
    }

    function concat(...ll: List<List<T>>): List<T> {
        if(ListOps::s_empty<T>(this.value())) {
            return List<T>{};
        }
        else {
            let count = ListOps::s_size<List<T>>(ll.value());
            if(count == 1) {
                return ListOps::s_safe_get<List<T>>(ll.value(), 0n);
            }
            elif(count == 2) {
                return List<T>::s_into(ListOps::s_append<T>(ListOps::s_safe_get<List<T>>(ll.value(), 0n), ListOps::s_safe_get<List<T>>(ll.value(), 1n)));
            }
            elif(count == 3) {
                let la = ListOps::s_append<T>(ListOps::s_safe_get<List<T>>(ll.value(), 0n), ListOps::s_safe_get<List<T>>(ll.value(), 1n));
                return List<T>::s_into(ListOps::s_append<T>(la, ListOps::s_safe_get<List<T>>(ll.value(), 2n)));
            }
            elif(count == 4) {
                let la = ListOps::s_append<T>(ListOps::s_safe_get<List<T>>(ll.value(), 0n), ListOps::s_safe_get<List<T>>(ll.value(), 1n));
                let ra = ListOps::s_append<T>(ListOps::s_safe_get<List<T>>(ll.value(), 2n), ListOps::s_safe_get<List<T>>(ll.value(), 3n));
                return List<T>::s_into(ListOps::s_append<T>(la, ra));
            }
            else {
                return List<T>::s_into(ListOps::s_concat<T>(ll.value()));
            }
        }
    }

    method size(): Nat {
        return ListOps::s_size<T>(this.value());
    }

    method empty(): Bool {
        return ListOps::s_empty<T>(this.value());
    }

    method front(): T {
        assert !ListOps::s_empty(this.value());
        return ListOps::s_safe_get<T>(this.value(), 0n);
    }

    method frontOrNone(): T? {
        if(ListOps::s_empty(this.value())) {
            return none;
        }
        else {
            return ListOps::s_safe_get<T>(this.value(), 0n);
        }
    }

    method frontOption(): Option<T> {
        if(ListOps::s_empty(this.value())) {
            return nothing;
        }
        else {
            return something(ListOps::s_safe_get<T>(this.value(), 0n));
        }
    }

    method frontTry(out? res: T): Bool {
        if(!ListOps::s_empty(this.value())) {
            res = ListOps::s_safe_get<T>(this.value(), 0n);
            return true;
        }
        else {
            return false;
        }
    }

    method back(): T {
        assert !ListOps::s_empty(this.value());
        return ListOps::s_safe_get<T>(this.value(), ListOps::s_size<T>(this.value()) - 1n);
    }

    method backOrNone(): T? {
        if(ListOps::s_empty(this.value())) {
            return none;
        }
        else {
            return ListOps::s_safe_get<T>(this.value(), ListOps::s_size<T>(this.value()) - 1n);
        }
    }

    method backOption(): Option<T> {
        if(ListOps::s_empty(this.value())){
            return nothing;
        }
        else {
            return something(ListOps::s_safe_get<T>(this.value(), ListOps::s_size<T>(this.value()) - 1n));
        }
    }

    method backTry(out? res: T): Bool {
        if(!ListOps::s_empty(this.value())) {
            res = ListOps::s_safe_get<T>(this.value(), ListOps::s_size<T>(this.value()) - 1n);
            return true;
        }
        else {
            return false;
        }
    }

    method get(i: Nat): T
        requires i < ListOps::s_size<T>(this.value());
    {
        return ListOps::s_safe_get<T>(this.value(), i);
    }

    method getOrNone(i: Nat): T? {
        if(i < ListOps::s_size<T>(this.value())) {
            return ListOps::s_safe_get<T>(this.value(), i);
        }
        else {
            return none;
        }
    }

    method getOption(i: Nat): Option<T> {
        if(i < ListOps::s_size<T>(this.value())) {
            return something(ListOps::s_safe_get<T>(this.value(), i));
        }
        else {
            return nothing;
        }
    }

    method getTry(i: Nat, out? res: T): Bool {
        if(i < ListOps::s_size<T>(this.value())) {
            res = ListOps::s_safe_get<T>(this.value(), i);
            return true;
        }
        else {
            return false;
        }
    }

    recursive? method single(p: recursive? pred(_: T) -> Bool): T {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);
        assert idx !== none;

        let lastidx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);
        assert lastidx === idx;

        return ListOps::s_safe_get<T>(this.value(), idx);
    }

    recursive? method singleOrNone(p: recursive? pred(_: T) -> Bool): T? {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);
        if(idx === none) {
            return none;
        }
        else {
            let lastidx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

            if(idx !== lastidx) {
                return none;
            }
            else {
                return ListOps::s_safe_get<T>(this.value(), idx);
            }
        }
    }

    recursive? method singleOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);
         if(idx === none) {
            return nothing;
        }
        else {
            let lastidx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

            if(idx !== lastidx) {
                return nothing;
            }
            else {
                return something(ListOps::s_safe_get<T>(this.value(), idx));
            }
        }
    }

    recursive? method singleTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);
        if(idx === none) {
            return false;
        }
        else {
            let lastidx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

            if(idx !== lastidx) {
                return false;
            }
            else {
                res = ListOps::s_safe_get<T>(this.value(), idx);
                return true;
            }
        }
    }

    recursive? method allOf(p: recursive? pred(_: T) -> Bool): Bool {
        return !ListOps::s_has_pred<T>[recursive?](this.value(), recursive? pred(v: T): Bool => !p[recursive?](v));
    }

    recursive? method allOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return !ListOps::s_has_pred_idx<T>[recursive?](this.value(), recursive? pred(v: T, i: Nat): Bool => !p[recursive?](v, i));
    }

    recursive? method noneOf(p: recursive? pred(_: T) -> Bool): Bool {
        return !ListOps::s_has_pred<T>[recursive?](this.value(), p);
    }

    recursive? method noneOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return !ListOps::s_has_pred_idx<T>[recursive?](this.value(), p);
    }

    recursive? method someOf(p: recursive? pred(_: T) -> Bool): Bool {
        return ListOps::s_has_pred<T>[recursive?](this.value(), p);
    }

    recursive? method someOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return ListOps::s_has_pred_idx<T>[recursive?](this.value(), p);
    }

    recursive? method countIf(p: recursive? pred(_: T) -> Bool): Nat {
        return ListOps::s_size<T>(ListOps::s_filter_pred<T>[recursive?](this.value(), p));
    }

    recursive? method countIf(p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
        return ListOps::s_size<T>(ListOps::s_filter_pred_idx<T>[recursive?](this.value(), p));
    }

    method {when T grounded KeyType} contains(v: T): Bool {
        return ListOps::s_has_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e));
    }

    method containsNone(): Bool {
        return ListOps::s_has_pred<T>(this.value(), pred(e: T): Bool => e === none);
    }

    method containsNothing(): Bool {
        return ListOps::s_has_pred<T>(this.value(), pred(e: T): Bool => e === nothing);
    }

    method {when T unique IResult} containsError(): Bool {
        return ListOps::s_has_pred<T>(this.value(), pred(e: Result<T!IResultT, T!IResultE>): Bool => e.isErr());
    }

    method {when T unique IResult} allOk(): Bool {
        return !ListOps::s_has_pred<T>(this.value(), pred(e: Result<T!IResultT, T!IResultE>): Bool => e.isErr());
    }

    method {when T grounded KeyType} count(v: T): Int {
        return ListOps::s_size<T>(ListOps::s_filter_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e)));
    }

    method countNone(): Bool {
        return ListOps::s_size<T>(ListOps::s_filter_pred<T>(this.value(), pred(e: T): Bool => e === none));
    }

    method countNothing(): Bool {
        return ListOps::s_size<T>(ListOps::s_filter_pred<T>(this.value(), pred(e: T): Bool => e === nothing));
    }

    method {when T unique Orderable} min(): T {
        assert !ListOps::s_empty(this.value());

        let midx = ListOps::s_min_arg<T, T>(this.value(), fn(v: T): T => v);
        return ListOps::s_safe_get<T>(this.value(), midx);
    }

    method {when T unique Orderable} max(): T {
        assert !ListOps::s_empty(this.value());

        let midx = ListOps::s_max_arg<T, T>(this.value(), fn(v: T): T => v);
        return ListOps::s_safe_get<T>(this.value(), midx);
    }

    method {when T unique Orderable} minOrNone(): T? {
        if(ListOps::s_empty(this.value())) {
            return none;
        }
        else {
            let midx = ListOps::s_min_arg<T, T>(this.value(), fn(v: T): T => v);
            return ListOps::s_safe_get<T>(this.value(), midx);
        }
    }

    method {when T unique Orderable} maxOrNone(): T? {
        if(ListOps::s_empty(this.value())) {
            return none;
        }
        else {
            let midx = ListOps::s_max_arg<T, T>(this.value(), fn(v: T): T => v);
            return ListOps::s_safe_get<T>(this.value(), midx);
        }
    }

    method {when T unique Orderable} minOption(): Option<T> {
        if(ListOps::s_empty(this.value())) {
            return nothing;
        }
        else {
            let midx = ListOps::s_min_arg<T, T>(this.value(), fn(v: T): T => v);
            return something(ListOps::s_safe_get<T>(this.value(), midx));
        }
    }

    method {when T unique Orderable} maxOrOption(): Option<T> {
        if(ListOps::s_empty(this.value())) {
            return nothing;
        }
        else {
            let midx = ListOps::s_max_arg<T, T>(this.value(), fn(v: T): T => v);
            return something(ListOps::s_safe_get<T>(this.value(), midx));
        }
    }

    method {when T unique Orderable} minTry(out? res: T): Bool {
        if(ListOps::s_empty(this.value())) {
            return false;
        }
        else {
            let midx = ListOps::s_min_arg<T, T>(this.value(), fn(v: T): T => v);
            res = ListOps::s_safe_get<T>(this.value(), midx);
            return true;
        }
    }

    method {when T unique Orderable} maxTry(out? res: T): Bool {
        if(ListOps::s_empty(this.value())) {
            return false;
        }
        else {
            let midx = ListOps::s_max_arg<T, T>(this.value(), fn(v: T): T => v);
            res = ListOps::s_safe_get<T>(this.value(), midx);
            return true;
        }
    }

    method argMin<U unique Orderable=?>(f: recursive? fn(_: T) -> U): T {
        assert !ListOps::s_empty(this.value());

        let midx = ListOps::s_min_arg<T, U>[recursive?](this.value(), f);
        return ListOps::s_safe_get<T>(this.value(), midx);
    }

    method argMax<U unique Orderable=?>(f: recursive? fn(_: T) -> U): T {
        assert !ListOps::s_empty(this.value());

        let midx = ListOps::s_max_arg<T, U>[recursive?](this.value(), f);
        return ListOps::s_safe_get<T>(this.value(), midx);
    }

    method argMinOrNone<U unique Orderable=?>(f: recursive? fn(_: T) -> U): T? {
        if(ListOps::s_empty(this.value())) {
            return none;
        }
        else {
            let midx = ListOps::s_min_arg<T, U>[recursive?](this.value(), f);
            return ListOps::s_safe_get<T>(this.value(), midx);
        }
    }

    method argMaxOrNone<U unique Orderable=?>(f: recursive? fn(_: T) -> U): T? {
        if(ListOps::s_empty(this.value())) {
            return none;
        }
        else {
            let midx = ListOps::s_max_arg<T, U>[recursive?](this.value(), f);
            return ListOps::s_safe_get<T>(this.value(), midx);
        }
    }

    method argMinOption<U unique Orderable=?>(f: recursive? fn(_: T) -> U): Option<T> {
        if(ListOps::s_empty(this.value())) {
            return nothing;
        }
        else {
            let midx = ListOps::s_min_arg<T, U>[recursive?](this.value(), f);
            return something(ListOps::s_safe_get<T>(this.value(), midx));
        }
    }

    method argMaxOrOption<U unique Orderable=?>(f: recursive? fn(_: T) -> U): Option<T> {
        if(ListOps::s_empty(this.value())) {
            return nothing;
        }
        else {
            let midx = ListOps::s_max_arg<T, U>[recursive?](this.value(), f);
            return something(ListOps::s_safe_get<T>(this.value(), midx));
        }
    }

    method argMinTry<U unique Orderable=?>(out? res: T, f: recursive? fn(_: T) -> U): Bool {
        if(ListOps::s_empty(this.value())) {
            return false;
        }
        else {
            let midx = ListOps::s_min_arg<T, U>[recursive?](this.value(), f);
            res = ListOps::s_safe_get<T>(this.value(), midx);
            return true;
        }
    }

    method argMaxTry<U unique Orderable=?>(out? res: T, f: recursive? fn(_: T) -> U): Bool {
        if(ListOps::s_empty(this.value())) {
            return false;
        }
        else {
            let midx = ListOps::s_max_arg<T, U>[recursive?](this.value(), f);
            res = ListOps::s_safe_get<T>(this.value(), midx);
            return true;
        }
    }

    method {when T unique Algebraic} sum(): T {
        return ListOps::s_sum<T>(this.value());
    }

    recursive? method find(p: recursive? pred(_: T) -> Bool): T {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);

        assert idx !== none;
        return ListOps::s_safe_get<T>(this.value(), idx);
    }

    recursive? method find(p: recursive? pred(_: T, _: Nat) -> Bool): T {
        let idx = ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);

        assert idx !== none;
        return ListOps::s_safe_get<T>(this.value(), idx);
    }

    recursive? method findOrNone(p: recursive? pred(_: T) -> Bool): T? {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return none;
        }
        else {
            return ListOps::s_safe_get<T>(this.value(), idx);
        }
    }

    recursive? method findOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): T? {
        let idx = ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return none;
        }
        else {
            return ListOps::s_safe_get<T>(this.value(), idx);
        }
    }

    recursive? method findOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return nothing;
        }
        else {
            return something(ListOps::s_safe_get<T>(this.value(), idx));
        }
    }

    recursive? method findOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<T> {
        let idx = ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return nothing;
        }
        else {
            return something(ListOps::s_safe_get<T>(this.value(), idx));
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return false;
        }
        else {
            res = ListOps::s_safe_get<T>(this.value(), idx);
            return true;
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let idx = ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return false;
        }
        else {
            res = ListOps::s_safe_get<T>(this.value(), idx);
            return true;
        }
    }

    recursive? method findLast(p: recursive? pred(_: T) -> Bool): T {
        let idx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

        assert idx !== none;
        return ListOps::s_safe_get<T>(this.value(), idx);
    }

    recursive? method findLast(p: recursive? pred(_: T, _: Nat) -> Bool): T {
        let idx = ListOps::s_find_last_pred_idx<T>[recursive?](this.value(), p);

        assert idx !== none;
        return ListOps::s_safe_get<T>(this.value(), idx);
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T) -> Bool): T? {
        let idx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return none;
        }
        else {
            return ListOps::s_safe_get<T>(this.value(), idx);
        }
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): T? {
        let idx = ListOps::s_find_last_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return none;
        }
        else {
            return ListOps::s_safe_get<T>(this.value(), idx);
        }
    }

    recursive? method findLastOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        let idx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return nothing;
        }
        else {
            return something(ListOps::s_safe_get<T>(this.value(), idx));
        }
    }

    recursive? method findLastOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<T> {
        let idx = ListOps::s_find_last_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return nothing;
        }
        else {
            return something(ListOps::s_safe_get<T>(this.value(), idx));
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        let idx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return false;
        }
        else {
            res = ListOps::s_safe_get<T>(this.value(), idx);
            return true;
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let idx = ListOps::s_find_last_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return false;
        }
        else {
            res = ListOps::s_safe_get<T>(this.value(), idx);
            return true;
        }
    }

    recursive? method findIndexOf(p: recursive? pred(_: T) -> Bool): Nat {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);

        assert idx !== none;
        return idx;
    }

    recursive? method findIndexOf(p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
        let idx = ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);

        assert idx !== none;
        return idx;
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T) -> Bool): Nat? {
        return ListOps::s_find_pred<T>[recursive?](this.value(), p);
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        return ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);
    }

    recursive? method findIndexOfOption(p: recursive? pred(_: T) -> Bool): Option<Nat> {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    recursive? method findIndexOfOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<Nat> {
        let idx = ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T) -> Bool): Bool {
        let idx = ListOps::s_find_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let idx = ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T) -> Bool): Nat {
        let idx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

        assert idx !== none;
        return idx;
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
        let idx = ListOps::s_find_last_pred_idx<T>[recursive?](this.value(), p);

        assert idx !== none;
        return idx;
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T) -> Bool): Nat? {
        return ListOps::s_find_last_pred<T>[recursive?](this.value(), p);
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        return ListOps::s_find_last_pred_idx<T>[recursive?](this.value(), p);
    }

    recursive? method findIndexOfLastOption(p: recursive? pred(_: T) -> Bool): Option<Nat> {
        let idx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    recursive? method findIndexOfLastOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<Nat> {
        let idx = ListOps::s_find_last_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T) -> Bool): Bool {
        let idx = ListOps::s_find_last_pred<T>[recursive?](this.value(), p);

        if(idx === none) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let idx = ListOps::s_find_last_pred_idx<T>[recursive?](this.value(), p);

        if(idx === none) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    method {when T grounded KeyType} indexOf(v: T): Nat {
        let idx = ListOps::s_find_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e));

        assert idx !== none;
        return idx;
    }

    method {when T grounded KeyType} indexOfOrNone(v: T): Nat? {
        return ListOps::s_find_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e));
    }

    method {when T grounded KeyType} indexOfOption(v: T): Option<Nat> {
        let idx = ListOps::s_find_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e));

        if(idx === none) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    method {when T grounded KeyType} indexOfTry(out? res: Nat, v: T): Bool {
        let idx = ListOps::s_find_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e));

        if(idx === none) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    method {when T grounded KeyType} indexOfLast(v: T): Nat {
        let idx = ListOps::s_find_last_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e));

        assert idx !== none;
        return idx;
    }

    method {when T grounded KeyType} indexOfLastOrNone(v: T): Nat? {
        return ListOps::s_find_last_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e));
    }

    method {when T grounded KeyType} indexOfLastOption(v: T): Option<Nat> {
        let idx = ListOps::s_find_last_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e));

        if(idx === none) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    method {when T grounded KeyType} indexOfLastTry(out? res: Nat, v: T): Bool {
        let idx = ListOps::s_find_last_pred<T>(this.value(), pred(e: T): Bool => KeyType::equal<T>(v, e));

        if(idx === none) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method filter(p: recursive? pred(_: T) -> Bool): List<T> {
        return List<T>::s_into(ListOps::s_filter_pred<T>[recursive?](this.value(), p));
    }

    recursive? method filter(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        return List<T>::s_into(ListOps::s_filter_pred_idx<T>[recursive?](this.value(), p));
    }

    method filterType<U>(): List<U> {
        let fl = ListOps::s_filter_pred<T>(this.value(), pred(v: T): Bool => v istype U);
        return List<U>::s_into(ListOps::s_map<T, U>(fl, fn(v: T): U => s_safeAs<T, U>(v)));
    }

    method filterSome(): List<T!Some> {
        let fl = ListOps::s_filter_pred<T>(this.value(), pred(v: T): Bool => v !== none);
        return List<T!Some>::s_into(ListOps::s_map<T, T!Some>(fl.value(), fn(v: T): T!Some => s_safeAs<T, T!Some>(v)));
    }

    method {when T unique IOption} filterSomething(): List<T!IOptionT> {
        let fl = ListOps::s_filter_pred<T>(this.value(), pred(v: T): Bool => v !== nothing);
        return List<T!IOptionT>::s_into(ListOps::s_map<T, T!IOptionT>(fl.value(), fn(v: T): T!IOptionT => s_safeAs<T, Something<T!IOptionT>>(v).value()));
    }

    method {when T unique IResult} filterOk(): List<T!IResultT> {
        let fl = ListOps::s_filter_pred<T>(this.value(), pred(v: T): Bool => v.isOk());
        return List<T!IResultT>::s_into(ListOps::s_map<T, T!IResultT>(fl.value(), fn(v: T): T!IResultT => s_safeAs<T, Result<T!IResultT, T!IResultE>::Ok>(v).value()));
    }

    method castType<U>(): List<U> {
        return List<U>::s_into(ListOps::s_map<T, U>(this.value(), fn(v: T): U => v astype U));
    }

    method castSome(): List<T!Some> {
        return List<T!Some>::s_into(ListOps::s_map<T, T!Some>(this.value(), fn(v: T): T!Some => v astype T!Some));
    }

    method {when T unique IOption} castSomething(): List<T!IOptionT> {
        return List<T!IOptionT>::s_into(ListOps::s_map<T, T!IOptionT>(this.value(), fn(v: T): T!IOptionT => v.data()));
    }

    method {when T unique IResult} castOk(): List<T!IResultT> {
        return List<T!IResultT>::s_into(ListOps::s_map<T, T!IResultT>(this.value(), fn(v: T): T!IResultT => v.result()));
    }

    method slice(start?: Nat=0n, end?: Nat=ListOps::s_size<T>(this.value())): List<T> {
        assert start <= end;
        assert end <= ListOps::s_size<T>(this.value());
        return List<T>::s_into(ListOps::s_slice_end<T>(ListOps::s_slice_front<T>(this.value(), start), end));
    }

    method removeFirst(k: Nat): List<T> {
        assert k <= ListOps::s_size<T>(this.value());
        return List<T>::s_into(ListOps::s_slice_front<T>(this.value(), k));
    } 

    method removeLast(k: Nat): List<T> {
        assert k <= ListOps::s_size<T>(this.value());
        return List<T>::s_into(ListOps::s_slice_end<T>(this.value(), ListOps::s_size<T>(this.value()) - k));
    }

    recursive? method takeWhile(p: recursive? pred(_: T) -> Bool): List<T>  {
        let lpos = ListOps::s_find_pred<T>[recursive?](this.value(), recursive? pred(v: T) => !p[recursive?](v));

        if(lpos === none) {
            return this;
        }
        else {
            return List<T>::s_into(ListOps::s_slice_end<T>(this.value(), lpos));
        }
    }

    recursive? method takeWhile(p: recursive? pred(_: T, _: Nat) -> Bool): List<T>  {
        let lpos = ListOps::s_find_pred_idx<T>[recursive?](this.value(), recursive? pred(v: T, i: Nat) => !p[recursive?](v, i));

        if(lpos === none) {
            return this;
        }
        else {
            return List<T>::s_into(ListOps::s_slice_end<T>(this.value(), lpos));
        }
    }

    recursive? method discardWhile(p: recursive? pred(_: T) -> Bool): List<T> {
        let lpos = ListOps::s_find_pred<T>[recursive?](this.value(), recursive? pred(v: T) => !p[recursive?](v));

        if(lpos === none) {
            return List<T>{};
        }
        else {
            return List<T>::s_into(ListOps::s_slice_front<T>(this.value(), lpos));
        }
    }

    recursive? method discardWhile(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let lpos = ListOps::s_find_pred_idx<T>[recursive?](this.value(), recursive? pred(v: T, i: Nat) => !p[recursive?](v, i));

        if(lpos === none) {
            return List<T>{};
        }
        else {
            return List<T>::s_into(ListOps::s_slice_front<T>(this.value(), lpos));
        }
    }

    recursive? method takeUntil(p: recursive? pred(_: T) -> Bool): List<T> {
        let lpos = ListOps::s_find_pred<T>[recursive?](this.value(), p);

        if(lpos === none) {
            return this;
        }
        else {
            return List<T>::s_into(ListOps::s_slice_end<T>(this.value(), lpos));
        }
    }

    recursive? method takeUntil(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let lpos = ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);

        if(lpos === none) {
            return this;
        }
        else {
            return List<T>::s_into(ListOps::s_slice_end<T>(this.value(), lpos));
        }
    }

    recursive? method discardUntil(p: recursive? pred(_: T) -> Bool): List<T>  {
        let lpos = ListOps::s_find_pred<T>[recursive?](this.value(), p);

        if(lpos === none) {
            return this;
        }
        else {
            return List<T>::s_into(ListOps::s_slice_front<T>(this.value(), lpos));
        }
    }

    recursive? method discardUntil(p: recursive? pred(_: T, _: Nat) -> Bool): List<T>  {
        let lpos = ListOps::s_find_pred_idx<T>[recursive?](this.value(), p);

        if(lpos === none) {
            return this;
        }
        else {
            return List<T>::s_into(ListOps::s_slice_front<T>(this.value(), lpos));
        }
    }

    recursive? method map<U=?>(f: recursive? fn(_: T) -> U): List<U>  {
        return List<U>::s_into(ListOps::s_map<T, U>[recursive?](this.value(), f));
    }

    recursive? method map<U=?>(f: recursive? fn(_: T, _: Nat) -> U): List<U>  {
        return List<U>::s_into(ListOps::s_map_idx<T, U>[recursive?](this.value(), f));
    }

    recursive? method mapNone<U=?>(f: recursive? fn(_: T!Some) -> U): List<U?>  {
        return List<U>::s_into(ListOps::s_map<T, U>[recursive?](this.value(), recursive? fn(v: T): U => {
            if(v === none) {
                return none;
            }
            else {
                return f[recursive?](v);
            }
        }));
    }

    recursive? method mapNone<U=?>(f: recursive? fn(_: T, _: Nat) -> U): List<U?>  {
        return List<U>::s_into(ListOps::s_map_idx<T, U>[recursive?](this.value(), recursive? fn(v: T, i: Nat): U => {
            if(v === none) {
                return none;
            }
            else {
                return f[recursive?](v, i);
            }
        }));
    }

    recursive? method {when T unique IOption} mapOption<U=?>(f: recursive? fn(_: T!IOptionT) -> U): List<Option<U>>  {
        return List<Option<U>>::s_into(ListOps::s_map<T, U>[recursive?](this.value(), recursive? fn(v: T): U => {
            if(v === nothing) {
                return nothing;
            }
            else {
                return something(f[recursive?](v.value()));
            }
        }));
    }

    recursive? method {when T unique IOption} mapOption<U=?>(f: recursive? fn(_: T!IOptionT, _: Nat) -> U): List<Option<U>>  {
        return List<Option<U>>::s_into(ListOps::s_map_idx<T, U>[recursive?](this.value(), recursive? fn(v: T, i: Nat): U => {
            if(v === nothing) {
                return nothing;
            }
            else {
                return something(f[recursive?](v.value(), i));
            }
        }));
    }

    method {when T grounded KeyType} project<U=?>(m: Map<T, U>): List<U> {
        return List<T>::s_into(ListOps::s_map<T, U>(this.value(), fn(v: T): U => {
            return m.get(v);
        }));
    }

    method {when T grounded KeyType} projectOrNone<U=?>(m: Map<T, U>): List<U?> {
        return List<T>::s_into(ListOps::s_map<T, U?>(this.value(), fn(v: T): U? => {
            return m.getOrNone(v);
        }));
    }

    method {when T grounded KeyType} projectOption<U=?>(m: Map<T, U>): List<Option<U>> {
        return List<T>::s_into(ListOps::s_map<T, Option<U>>(this.value(), fn(v: T): Option<U> => {
            return m.getOption(v);
        }));
    }

    method {when T grounded KeyType} projectImage<U=?>(m: Map<T, U>): List<U> {
        let img = ListOps::s_filter_pred<T>(this.value(), pred(v: T) => m.has(v));
        return List<T>::s_into(ListOps::s_map<T, U>(img, fn(v: T): U => m.get(v)));
    }

    recursive? method join<U=?>(ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        if(ListOps::s_empty<T>(this.value()) || ListOps::s_empty<U>(ol.value())) {
            return List<T>{};
        }
        else {
            let jjl = ListOps::s_map<T, List<[T, U]>>[recursive?](this.value(), recursive? fn(v: T): List<[T, U]> => {
                let ul = ListOps::s_filter_pred<U>[recursive?](ol.value(), pred(u: U) => p[recursive?](v, u));
                return List<U>::s_into(ListOps::s_map<U>(ul, fn(u: U): [T, U] => [v, u]));
            });

            let count = ListOps::s_size<List<[T, U]>>(jjl);
            if(count == 1) {
                return ListOps::s_safe_get<List<[T, U]>>(jjl, 0n);
            }
            elif(count == 2) {
                return List<[T, U]>::s_into(ListOps::s_append<[T, U]>(ListOps::s_safe_get<List<[T, U]>>(jjl, 0n), ListOps::s_safe_get<List<[T, U]>>(jjl, 1n)));
            }
            elif(count == 3) {
                let la = ListOps::s_append<T>(ListOps::s_safe_get<List<[T, U]>>(jjl, 0n), ListOps::s_safe_get<List<[T, U]>>(jjl, 1n));
                return List<[T, U]>::s_into(ListOps::s_append<[T, U]>(la, ListOps::s_safe_get<List<T>>(jjl, 2n)));
            }
            elif(count == 4) {
                let la = ListOps::s_append<[T, U]>(ListOps::s_safe_get<List<[T, U]>>(jjl, 0n), ListOps::s_safe_get<List<[T, U]>>(jjl, 1n));
                let ra = ListOps::s_append<[T, U]>(ListOps::s_safe_get<List<[T, U]>>(jjl, 2n), ListOps::s_safe_get<List<[T, U]>>(jjl, 3n));
                return List<[T, U]>::s_into(ListOps::s_append<[T, U]>(la, ra));
            }
            else {
                return List<T>::s_into(List<T>::s_concat<T>(jjl));
            }
        }
    }

    recursive? method joinGroup<U=?>(ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, List<U>]> {
        return List<[T, List<U>]>::s_into(ListOps::s_map<T, [T, List<U>]>[recursive?](this.value(), recursive? fn(v: T): [T, List<U>] => {
            let ul = List<U>::s_into(ListOps::s_filter_pred<U>[recursive?](ol.value(), pred(u: U) => p[recursive?](v, u)));
            return [v, ul];
        }));
    }

    method append(l: List<T>): List<T> {
        return List<T>::s_into(ListOps::s_append<T>(this.value(), l));
    }

    method prepend(l: List<T>): List<T> {
        return List<T>::s_into(ListOps::s_append<T>(l, this.value()));
    }

    recursive? method partition<K grounded KeyType=?>(pf: recursive? fn(_: T) -> K): Map<K, List<T>> {
        let allkeys = ListOps::s_map<T, K>[recursive?](this.value(), pf);
        let ukeys = ListOps::s_unique_from_sorted<T>[recursive?](ListOps::s_sort<T>[recursive?](this.value(), pred(a: K, b: K): Bool => KeyType::less<K>(a, b)), pred(a: K, b: K): Bool => KeyType::equal<K>(a, b));

        let kopts = ListOps::s_zip<K, T>(allkeys, this.value());
        let classes = List<[K, List<T>]>::s_into(ListOps::s_map<K, [K, List<T>]>(ukeys, fn(k: K): [K, List<T>] => {
            let pl = ListOps::s_filter_pred<[K, T]>(kopts, pred(v: [K, T]) => k === v.0);
            let tl = List<T>::s_into(ListOps::s_map<[K, T], T>(pl, fn(vv: [K, T]): T => vv.1));

            return [k, tl];
        }));

        return Map<K, T>::s_from_list(classes);
    }

    recursive? method sort(cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        return List<T>::s_into(ListOps::s_sort<T>[recursive?](this.value(), cmp));
    }

    recursive? method uniqueify(cmp: recursive? pred(_: T, _: T) -> Bool, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
       return List<T>::s_into(ListOps::s_unique_from_sorted<T>[recursive?](ListOps::s_sort<T>[recursive?](this.value(), cmp), eq));
    }

    method reverse(): List<T> {
        return List<T>::s_into(ListOps::s_reverse<T>(this.value()));
    }

    method pushBack(v: T): List<T> {
        return List<T>::s_into(ListOps::s_append<T>(this.value(), List<T>{v}));
    }

    method pushFront(v: T): List<T> {
        return List<T>::s_into(ListOps::s_append<T>(List<T>{v}.value(), this.value()));
    }

    method popBack(): List<T> {
        assert !ListOps::s_empty(this.value());

        return List<T>::s_into(ListOps::s_slice_end<T>(this.value(), ListOps::s_size<T>(this.value()) - 1n));
    }

    method popFront(): List<T> {
        assert !ListOps::s_empty(this.value());

        return List<T>::s_into(ListOps::s_slice_front<T>(this.value(), 1n));
    }

    method set(i: Nat, v: T): List<T> {
        assert i < ListOps::s_size<T>(this.value());

        return List<T>::s_into(ListOps::s_set<T>(this.value(), i, v));
    }

    method remove(i: Nat): List<T> {
        assert i < ListOps::s_size<T>(this.value());

        return List<T>::s_into(ListOps::s_remove<T>(this.value(), i));
    }

    recursive? method reduce<U=?>(init: U, f: recursive? fn(_: U, _: T) -> U): U {
        return ListOps::s_reduce<T, U>[recursive?](this.value(), init, f);
    }

    recursive? method reduce<U=?>(init: U, f: recursive? fn(_: U, _: T, _: Nat) -> U): U {
        return ListOps::s_reduce_idx<T, U>[recursive?](this.value(), init, f);
    }

    recursive? method transduce<E=?, U=?>(env: E, f: recursive? fn(_: T, _: E) -> (|E, U|)): (|E, List<U>|) {
        let ee, llu = ListOps::s_transduce<T, E, U>[recursive?](this.value(), env, f);
        return (|ee, List<U>::s_into(llu)|);
    }

    recursive? method transduce<E=?, U=?>(env: E, f: recursive? fn(_: T, _: E, _: Nat) -> (|E, U|)): (|E, List<U>|) {
        let ee, llu = ListOps::s_transduce_idx<T, E, U>[recursive?](this.value(), env, f);
        return (|ee, List<U>::s_into(llu)|);
    }

    //
    //TODO: ref versions of the add/remove/set operators
    //

    //
    //TODO: Convert to Map<K, V> and Set<T> operations
    //
}
