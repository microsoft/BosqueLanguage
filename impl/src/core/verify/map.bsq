//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

__internal entity Map<K grounded KeyType, V> provides Object, Expandoable<[K, V]>, APIType when K APIType && V APIType {
    private method value(): List<[K, V]> # special_extract
    private function from(v: List<[K, V]>): # special_inject

    method empty(): Bool {
        return ListFlatOps::s_empty<[K, V]>(this.value());
    }

    method size(): Nat {
        return ListOps::s_size<[K, V]>(this.value());
    }

    method has(key: K): Bool {
        return ListOps::s_has_check_kv<K, V>(this.value(), k);
    }

    method get(key: K): V {
        let idx = ListOps::s_find_index_kv<[K, V]>(this.value(), k);

        check idx !== none;
        return ListOps::s_safe_get<[K, V]>(this.value(), idx);
    }

    method getOrNone(k: K): V? {
        let idx = ListOps::s_find_index_kv<K, V>(this.value(), k);
        if(idx === none) {
            return none;
        }
        else {
            return ListOps::s_safe_get<[K, V]>(this.value(), idx);
        }
    }

    method getOption(k: K): Option<V> {
        let idx = ListOps::s_find_index_kv<K, V>(this.value(), k);
        if(idx === none) {
            return nothing;
        }
        else {
            return something(ListOps::s_safe_get<[K, V]>(this.value(), idx));
        }
    }

    method getTry(k: K, out? v: V): Bool {
        let idx = ListOps::s_find_index_kv<K, V>(this.value(), k);
        if(idx === none) {
            return false;
        }
        else {
            v = ListOps::s_safe_get<[K, V]>(this.value(), idx);
            return true;
        }
    }

    method union(m: Map<K, V>): Map<K, V> {
            let tl = this.value();
            let ml = m.value();

            xxxx;

            let am = ListOps::s_concat2<[K, V]>(tl, ml);
            return Map<K, V>::from(am);
    }

    recursive? method submap(p: recursive? pred(v: [K, V]) -> Bool): Map<K, V> {
        let sm = ListOps::s_filter<[K, V]>(this.value(), p);
        return Map<K, V>::from(sm);
    }

    recursive? method remap(f: recursive? fn(v: [K, V]) -> V): Map<K, V> {
        let rm = ListOps::s_map<[K, V]>(this.value(), recursive? fn(v: [K, V]): [K, V] => [v.0, f[recursive?](v)]);
        return Map<K, V>::from(rm);
    }

    method add(k: K, v: V): Map<K, V> {
        check !ListOps::s_has_check_kv<K, V>(this.value(), k);
        
        let am = ListOps::s_concat2<[K, V]>(this.value(), List<[K, V]>{[k, v]});
        return Map<K, V>::from(am);
    }

    method set(k: K, v: V): Map<K, V> {
        let idx = ListOps::s_find_index_kv<K, V>(this.value(), k);
        check idx !== none;

        let sm = this.value().set(idx, [k, v]);
        return Map<K, V>::from(sm);
    }

    method remove(k: K): Map<K, V> {
        let idx = ListOps::s_find_index_kv<K, V>(this.value(), k);
        check idx !== none;

        let rm = this.value().remove(idx);
        return Map<K, V>::from(rm);
    }

    //
    //TODO: ref versions of the add/remove/set operators
    //
}

