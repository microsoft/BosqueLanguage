//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

entity Map<K KeyType, V> provides Object, Expandoable<[K, V]>, APIType when K APIType && V APIType {
    private field List<[K, V]> m_entries;

    method empty(): Bool {
        return ListOperators::s_empty<[K, V]>(this.m_entries);
    }

    method size(): Nat {
        return ListOperators::s_size<[K, V]>(this.m_entries);
    }

    method has(key: K): Bool {
        return ListKeyOperators::s_hasCheckMapKV<[K, V]>(this.m_entries, k);
    }

    method get(key: K): V {
        let idx = ListKeyOperators::s_findIndexOfMapKV_KeyHelper<[K, V]>(this.m_entries, k);
        check idx != ListOperators::s_size<[K, V]>(this.m_entries);
        return ListOperators::s_safe_get<[K, V]>(this.m_entries, idx);
    }

    method getOrNone(k: K): V? {
        xxxx;
        return Map<K, V>::s_has_key(this, k) ? Map<K, V>::s_at_val(this, k) : none;
    }

    method getOption(k: K): Option<V> {
        xxxx;
        return Map<K, V>::s_has_key(this, k) ? Map<K, V>::s_at_val(this, k) : d;
    }

    method getTry(k: K, out? v: V): Bool {
        xxxx;
        if(Map<K, V>::s_has_key(this, k)) {
            v = Map<K, V>::s_at_val(this, k);
            return true;
        }
        else {
            return false;
        }
    }

    method merge(m: Map<K, V>): Map<K, V> {
        xxxx;
    }

    method submap(p: recursive? pred(v: [K, V]) -> Bool): Map<K, V> {

    }

    method remap(f: recursive? fn(v: [K, V]) -> V): Map<K, V> {
        
    }

    method add(k: K, v: V): Map<K, V> {
    }

    method set(k: K, v: V): Map<K, V> {
    }

    method remove(k: K): Map<K, V> {
    }
}

