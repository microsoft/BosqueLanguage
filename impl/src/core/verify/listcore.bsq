//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

__internal entity ListFlatOps provides Object {
    __safe function s_empty<T>(l: List<T>): Bool # list_empty

    __safe function s_is1<T>(l: List<T>): Bool # flat_list_is1
    __assume_safe function s_1at0<T>(l: List<T>): T # flat_list_1at0

    __safe function s_is2<T>(l: List<T>): Bool # flat_list_is2
    __assume_safe function s_2at0<T>(l: List<T>): T # flat_list_2at0
    __assume_safe function s_2at1<T>(l: List<T>): T # flat_list_2at1

    __safe function s_is3<T>(l: List<T>): Bool # flat_list_is3
    __assume_safe function s_3at0<T>(l: List<T>): T # flat_list_3at0
    __assume_safe function s_3at1<T>(l: List<T>): T # flat_list_3at1
    __assume_safe function s_3at2<T>(l: List<T>): T # flat_list_3at2

    //equiv s_empty | s_is1 | s_is2 | s_is3
    __safe function s_isFlatList<T>(l: List<T>): Bool # list_isflat

    function s_at<T>(l: List<T>, i Nat): T {
        if(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_1at0<T>(l);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            if(i == 0) {
                return ListFlatOps::s_2at0<T>(l);
            }
            else {
                return ListFlatOps::s_2at1<T>(l);
            }
        }
        else {
            if(i == 0) {
                return ListFlatOps::s_3at0<T>(l);
            }
            elif(i == 1) {
                return ListFlatOps::s_3at1<T>(l);
            }
            else {
                return ListFlatOps::s_3at2<T>(l);
            }
        }
    }

    recursive? function s_has_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOps::s_empty<T>(l)) {
            return false;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return p[recursive?](ListFlatOps::s_1at0(l));
        }
        else(ListFlatOps::s_is2<T>(l)) {
            return ListOps::s_or2(p[recursive?](ListFlatOps::s_2at0(l)), p[recursive?](ListFlatOps::s_2at1(l)));
        }
        else {
            return ListOps::s_or3(p[recursive?](ListFlatOps::s_3at0(l)), p[recursive?](ListFlatOps::s_3at1(l)), p[recursive?](ListFlatOps::s_3at2(l)));
        }
    }

    recursive? function s_has_pred_check_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOps::s_empty<T>(l)) {
            return false;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return p[recursive?](ListFlatOps::s_1at0(l), bidx);
        }
        else(ListFlatOps::s_is2<T>(l)) {
            return ListOps::s_or2(p[recursive?](ListFlatOps::s_2at0(l), bidx), p[recursive?](ListFlatOps::s_2at1(l), bidx + 1n));
        }
        else {
            return ListOps::s_or3(p[recursive?](ListFlatOps::s_3at0(l), bidx), p[recursive?](ListFlatOps::s_3at1(l), bidx + 1n), p[recursive?](ListFlatOps::s_3at2(l), bidx + 2n));
        }
    }

    recursive? function s_all_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return true;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return p[recursive?](ListFlatOps::s_1at0(l));
        }
        else(ListFlatOps::s_is2<T>(l)) {
            return ListOps::s_and2(p[recursive?](ListFlatOps::s_2at0(l)), p[recursive?](ListFlatOps::s_2at1(l)));
        }
        else {
            return ListOps::s_and3(p[recursive?](ListFlatOps::s_3at0(l)), p[recursive?](ListFlatOps::s_3at1(l)), p[recursive?](ListFlatOps::s_3at2(l)));
        }
    }

    recursive? function s_all_pred_check_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return true;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return p[recursive?](ListFlatOps::s_1at0(l), bidx);
        }
        else(ListFlatOps::s_is2<T>(l)) {
            return ListOps::s_and2(p[recursive?](ListFlatOps::s_2at0(l), bidx), p[recursive?](ListFlatOps::s_2at1(l), bidx + 1n));
        }
        else {
            return ListOps::s_and3(p[recursive?](ListFlatOps::s_3at0(l), bidx), p[recursive?](ListFlatOps::s_3at1(l), bidx + 1n), p[recursive?](ListFlatOps::s_3at2(l), bidx + 2n));
        }
    }

    recursive? function s_find_index_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            if(p[recursive?](ListFlatOps::s_1at0(l))) {
                return bidx;
            }
            else {
                return none;
            }
        }
        else(ListFlatOps::s_is2<T>(l)) {
            if(p[recursive?](ListFlatOps::s_2at0(l))) {
                return bidx;
            } 
            elif(p[recursive?](ListFlatOps::s_2at1(l))) {
                return bidx + 1n;
            }
            else {
                return none;
            }
        }
        else {
            if(p[recursive?](ListFlatOps::s_3at0(l))) {
                return bidx;
            }
            elif(p[recursive?](ListFlatOps::s_3at1(l))) {
                return bidx + 1n;
            }
            elif(p[recursive?](ListFlatOps::s_3at2(l))) {
                return bidx + 2n;
            }
            else {
                return none;
            }
        }
    }

    recursive? function s_find_index_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            if(p[recursive?](ListFlatOps::s_1at0(l), bidx)) {
                return bidx;
            }
            else {
                return none;
            }
        }
        else(ListFlatOps::s_is2<T>(l)) {
            if(p[recursive?](ListFlatOps::s_2at0(l), bidx)) {
                return bidx;
            } 
            elif(p[recursive?](ListFlatOps::s_2at1(l), bidx + 1n)) {
                return bidx + 1n;
            }
            else {
                return none;
            }
        }
        else {
            if(p[recursive?](ListFlatOps::s_3at0(l), bidx)) {
                return bidx;
            }
            elif(p[recursive?](ListFlatOps::s_3at1(l), bidx + 1n)) {
                return bidx + 1n;
            }
            elif(p[recursive?](ListFlatOps::s_3at2(l), bidx + 2n)) {
                return bidx + 2n;
            }
            else {
                return none;
            }
        }
    }

    recursive? function s_find_last_index_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            if(p[recursive?](ListFlatOps::s_1at0(l))) {
                return bidx;
            }
            else {
                return none;
            }
        }
        else(ListFlatOps::s_is2<T>(l)) {
            if(p[recursive?](ListFlatOps::s_2at1(l))) {
                return bidx + 1n;
            } 
            elif(p[recursive?](ListFlatOps::s_2at0(l))) {
                return bidx;
            }
            else {
                return none;
            }
        }
        else {
            if(p[recursive?](ListFlatOps::s_3at2(l))) {
                return bidx + 2n;
            }
            elif(p[recursive?](ListFlatOps::s_3at1(l))) {
                return bidx + 1n;
            }
            elif(p[recursive?](ListFlatOps::s_3at0(l))) {
                return bidx;
            }
            else {
                return none;
            }
        }
    }

    recursive? function s_find_last_index_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            if(p[recursive?](ListFlatOps::s_1at0(l), bidx)) {
                return bidx;
            }
            else {
                return none;
            }
        }
        else(ListFlatOps::s_is2<T>(l)) {
            if(p[recursive?](ListFlatOps::s_2at1(l), bidx + 1n)) {
                return bidx + 1n;
            } 
            elif(p[recursive?](ListFlatOps::s_2at1(l), bidx)) {
                return bidx;
            }
            else {
                return none;
            }
        }
        else {
            if(p[recursive?](ListFlatOps::s_3at2(l), bidx + 2n)) {
                return bidx + 2n;
            }
            elif(p[recursive?](ListFlatOps::s_3at1(l), bidx + 1n)) {
                return bidx + 1n;
            }
            elif(p[recursive?](ListFlatOps::s_3at0(l), bidx)) {
                return bidx;
            }
            else {
                return none;
            }
        }
    }

    recursive? function s_map<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        if(ListOperators::s_empty<T>(l)) {
            return List<U>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return List<U>@{f[recursive?](ListFlatOps::s_1at0(l))};
        }
        else(ListFlatOps::s_is2<T>(l)) {
            return List<U>@{f[recursive?](ListFlatOps::s_2at0(l)), f[recursive?](ListFlatOps::s_2at1(l))};
        }
        else {
            return List<U>@{f[recursive?](ListFlatOps::s_3at0(l)), f[recursive?](ListFlatOps::s_3at1(l)), f[recursive?](ListFlatOps::s_3at2(l))};
        }
    }

    recursive? function s_map_idx<T, U>(l: List<T>, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        if(ListOperators::s_empty<T>(l)) {
            return List<U>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return List<U>@{f[recursive?](ListFlatOps::s_1at0(l), bidx)};
        }
        else(ListFlatOps::s_is2<T>(l)) {
            return List<U>@{f[recursive?](ListFlatOps::s_2at0(l), bidx), f[recursive?](ListFlatOps::s_2at1(l), bidx + 1n)};
        }
        else {
            return List<U>@{f[recursive?](ListFlatOps::s_3at0(l), bidx), f[recursive?](ListFlatOps::s_3at1(l), bidx + 1n), f[recursive?](ListFlatOps::s_3at2(l), bidx + 2n)};
        }
    }

    recursive? function s_filter<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            if(p[recursive?](ListFlatOps::s_1at0(l))) {
                return l;
            }
            else {
                return List<T>@{};
            }
        }
        else(ListFlatOps::s_is2<T>(l)) {
            let at0 = ListFlatOps::s_2at0(l);
            let pat0 = p[recursive?](at0);
            let at1 = ListFlatOps::s_2at1(l);
            let pat1 = p[recursive?](at1);

            if(ListOps::s_and2(pat0, pat1) {
                return l;
            }
            elif(pat0) {
                return List<T>@{at0};
            }
            elif(pat1) {
                return List<T>@{at1};
            }
            else {
                return List<T>@{};
            }
        }
        else {
            let at0 = ListFlatOps::s_3at0(l);
            let pat0 = p[recursive?](at0);
            let at1 = ListFlatOps::s_3at1(l);
            let pat1 = p[recursive?](at1);
            let at2 = ListFlatOps::s_3at2(l);
            let pat2 = p[recursive?](at2);

            if(ListOps::s_and3(pat0, pat1, pat2) {
                return l;
            }
            elif(ListOps::s_and2(pat0, pat1) {
                return List<T>@{at0, at1};
            }
            elif(ListOps::s_and2(pat0, pat2) {
                return List<T>@{at0, at2};
            }
            elif(ListOps::s_and2(pat1, pat2) {
                return List<T>@{at1, at2};
            }
            elif(pat0) {
                return List<T>@{at0};
            }
            elif(pat1) {
                return List<T>@{at1};
            }
            elif(pat2) {
                return List<T>@{at2};
            }
            else {
                return List<T>@{};
            }
        }
    }

    recursive? function s_filter_idx<T, U>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            if(p[recursive?](ListFlatOps::s_1at0(l), bidx)) {
                return l;
            }
            else {
                return List<T>@{};
            }
        }
        else(ListFlatOps::s_is2<T>(l)) {
            let at0 = ListFlatOps::s_2at0(l);
            let pat0 = p[recursive?](at0, bidx);
            let at1 = ListFlatOps::s_2at1(l);
            let pat1 = p[recursive?](at1, bidx + 1n);

            if(ListOps::s_and2(pat0, pat1) {
                return l;
            }
            elif(pat0) {
                return List<T>@{at0};
            }
            elif(pat1) {
                return List<T>@{at1};
            }
            else {
                return List<T>@{};
            }
        }
        else {
            let at0 = ListFlatOps::s_3at0(l);
            let pat0 = p[recursive?](at0, bidx);
            let at1 = ListFlatOps::s_3at1(l);
            let pat1 = p[recursive?](at1, bidx + 1n);
            let at2 = ListFlatOps::s_3at2(l);
            let pat2 = p[recursive?](at2, bidx + 2n);

            if(ListOps::s_and3(pat0, pat1, pat2) {
                return l;
            }
            elif(ListOps::s_and2(pat0, pat1) {
                return List<T>@{at0, at1};
            }
            elif(ListOps::s_and2(pat0, pat2) {
                return List<T>@{at0, at2};
            }
            elif(ListOps::s_and2(pat1, pat2) {
                return List<T>@{at1, at2};
            }
            elif(pat0) {
                return List<T>@{at0};
            }
            elif(pat1) {
                return List<T>@{at1};
            }
            elif(pat2) {
                return List<T>@{at2};
            }
            else {
                return List<T>@{};
            }
        }
    }
}

__internal entity ListBlockOps provides Object {
    __safe function s_head<T>(l: List<T>): List<T> # block_list_head
    __safe function s_tail<T>(l: List<T>): List<T> # block_list_tail

    __safe function s_isBlockList<T>(l: List<T>): Nat # list_isblock

    function s_at<T>(l: List<T>, i Nat): T {
        if(i < 3) {
            return ListFlatOps::s_at<T>(ListBlockOps::s_head<T>(l), i);
        }
        else {
            return ListFlatOps::s_at<T>(ListBlockOps::s_tail<T>(l), i - 3);
        }
    }

    recursive? function s_has_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return ListOps::s_or2(
            ListFlatOps::s_has_pred_check<T>[recursive?](ListBlockOps::s_head<T>(l), p),
            ListFlatOps::s_has_pred_check<T>[recursive?](ListBlockOps::s_tail<T>(l), p)
        );
    }

    recursive? function s_has_pred_check_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return ListOps::s_or2(
            ListFlatOps::s_has_pred_check_idx<T>[recursive?](ListBlockOps::s_head<T>(l), bidx, p),
            ListFlatOps::s_has_pred_check_idx<T>[recursive?](ListBlockOps::s_tail<T>(l), bidx + 3, p)
        );
    }

    recursive? function s_all_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return ListOps::s_and2(
            ListFlatOps::s_all_pred_check<T>[recursive?](ListBlockOps::s_head<T>(l), p),
            ListFlatOps::s_all_pred_check<T>[recursive?](ListBlockOps::s_tail<T>(l), p)
        );
    }

    recursive? function s_all_pred_check_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return ListOps::s_and2(
            ListFlatOps::s_all_pred_check_idx<T>[recursive?](ListBlockOps::s_head<T>(l), bidx, p),
            ListFlatOps::s_all_pred_check_idx<T>[recursive?](ListBlockOps::s_tail<T>(l), bidx + 3, p)
        );
    }

    recursive? function s_find_index_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let ff = ListFlatOps::s_find_index_pred<T>[recursive?](ListBlockOps::s_head<T>(l), bidx, p);
        if(ff !== none) {
            return ff;
        }
        else {
            return ListFlatOps::s_find_index_pred<T>[recursive?](ListBlockOps::s_tail<T>(l), bidx + 3, p);
        }
    }

    recursive? function s_find_index_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let ff = ListFlatOps::s_find_index_pred_idx<T>[recursive?](ListBlockOps::s_head<T>(l), bidx, p);
        if(ff !== none) {
            return ff;
        }
        else {
            return ListFlatOps::s_find_index_pred_idx<T>[recursive?](ListBlockOps::s_tail<T>(l), bidx + 3, p);
        }
    }

    recursive? function s_find_last_index_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let ll = ListFlatOps::s_find_last_index_pred<T>[recursive?](ListBlockOps::s_tail<T>(l), bidx + 3, p);
        if(ll !== none) {
            return ll;
        }
        else {
            return ListFlatOps::s_find_last_index_pred<T>[recursive?](ListBlockOps::s_head<T>(l), bidx, p);
        }
    }

    recursive? function s_find_index_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let ll = ListFlatOps::s_find_last_index_pred_idx<T>[recursive?](ListBlockOps::s_tail<T>(l), bidx + 3, p);
        if(ll !== none) {
            return ll;
        }
        else {
            return ListFlatOps::s_find_last_index_pred_idx<T>[recursive?](ListBlockOps::s_head<T>(l), bidx, p);
        }
    }

    recursive? function s_map<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        let ll = ListBlockOps::s_head<T>(l);
        let lr = ListBlockOps::s_tail<T>(l);

        if(ListFlatOps::s_is1<T>(lr)) {
            return List<U>@{f[recursive?](ListFlatOps::s_3at0(ll)), f[recursive?](ListFlatOps::s_3at1(ll)), f[recursive?](ListFlatOps::s_3at2(ll)), f[recursive?](ListFlatOps::s_1at0(lr))};
        }
        else(ListFlatOps::s_is2<T>(lr)) {
            return List<U>@{f[recursive?](ListFlatOps::s_3at0(ll)), f[recursive?](ListFlatOps::s_3at1(ll)), f[recursive?](ListFlatOps::s_3at2(ll)), f[recursive?](ListFlatOps::s_2at0(lr)), f[recursive?](ListFlatOps::s_2at1(lr))};
        }
        else {
            return List<U>@{f[recursive?](ListFlatOps::s_3at0(ll)), f[recursive?](ListFlatOps::s_3at1(ll)), f[recursive?](ListFlatOps::s_3at2(ll)), f[recursive?](ListFlatOps::s_3at0(lr)), f[recursive?](ListFlatOps::s_3at1(lr)), f[recursive?](ListFlatOps::s_3at2(lr))};
        }
    }

    recursive? function s_map_idx<T, U>(l: List<T>, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        let ll = ListBlockOps::s_head<T>(l);
        let lr = ListBlockOps::s_tail<T>(l);

        if(ListFlatOps::s_is1<T>(l)) {
            return List<U>@{f[recursive?](ListFlatOps::s_3at0(ll), bidx), f[recursive?](ListFlatOps::s_3at1(ll), bidx + 1n), f[recursive?](ListFlatOps::s_3at2(ll), bidx + 2n), f[recursive?](ListFlatOps::s_1at0(lr), bidx + 3n)};
        }
        else(ListFlatOps::s_is2<T>(l)) {
            return List<U>@{f[recursive?](ListFlatOps::s_3at0(ll), bidx), f[recursive?](ListFlatOps::s_3at1(ll), bidx + 1n), f[recursive?](ListFlatOps::s_3at2(ll), bidx + 2n), f[recursive?](ListFlatOps::s_2at0(lr), bidx + 3n), f[recursive?](ListFlatOps::s_2at1(lr), bidx + 4n)};
        }
        else {
            return List<U>@{f[recursive?](ListFlatOps::s_3at0(ll), bidx), f[recursive?](ListFlatOps::s_3at1(ll), bidx + 1n), f[recursive?](ListFlatOps::s_3at2(ll), bidx + 2n), f[recursive?](ListFlatOps::s_3at0(lr), bidx + 3n), f[recursive?](ListFlatOps::s_3at1(lr), bidx + 4n), f[recursive?](ListFlatOps::s_3at2(lr), bidx + 5n)};
        }
    }

    recursive? function s_filter<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        let ll = ListFlatOps::s_filter(ListBlockOps::s_head<T>(l), p);
        let lr = ListFlatOps::s_filter(ListBlockOps::s_tail<T>(l), p);

        return ListOps::s_concat2(ll, lr);
    }

    recursive? function s_filter_idx<T, U>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let ll = ListFlatOps::s_filter_idx(ListBlockOps::s_head<T>(l), bidx, p);
        let lr = ListFlatOps::s_filter_idx(ListBlockOps::s_tail<T>(l), bidx + 3, p);

        return ListOps::s_concat2(ll, lr);
    }
}

__internal entity ListConcatOps provides Object {
    __safe function s_left<T>(l: List<T>): List<T> # concat_list_left
    __safe function s_right<T>(l: List<T>): List<T> # concat_list_right

    __safe function s_isConcatList<T>(l: List<T>): Nat # list_isconcat

    recursive function s_concat_lropt_at<T>(l: List<T>, i Nat): T {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_at<T>(l, i);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_at<T>(l, i);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_at<T>[recursive](l, i);
        }
        else {
            return ListOperators::s_safe_get_impl<T>(l, i);
        }
    }

    recursive function s_at<T>(l: List<T>, i Nat): T {
        let ll = ListConcatOps::s_left<T>(l);
        let count = ListOperators::s_size<T>(ll);

        if(i < count) {
            return ListConcatOps::s_concat_lropt_at<T>[recursive](ll, i);
        }
        else {
            let rl = ListConcatOps::s_right<T>(l);
            let ri = i - count;

            return ListConcatOps::s_concat_lropt_at<T>[recursive](rl, ri);
        }
    }

    recursive function s_concat_lropt_has_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_has_pred_check<T>(l, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_has_pred_check<T>(l, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_has_pred_check<T>[recursive](l, p);
        }
        else {
            return ListOperators::s_has_pred_check_base<T>(l, p);
        }
    }

    recursive function s_has_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return ListOps::s_or2(
            ListConcatOps::s_concat_lropt_has_pred_check<T>[recursive](ListBlockOps::s_left<T>(l), p),
            ListConcatOps::s_concat_lropt_has_pred_check<T>[recursive](ListBlockOps::s_right<T>(l), p)
        );
    }

    recursive function s_concat_lropt_has_pred_idx_check<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_has_pred_check_idx<T>(l, bidx, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_has_pred_check_idx<T>(l, bidx p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_has_pred_check_idx<T>[recursive](l, bidx, p);
        }
        else {
            return ListOperators::s_has_pred_check_base<T>(l, bidx, p);
        }
    }

    recursive? function s_has_pred_check_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return ListOps::s_or2(
            ListConcatOps::s_concat_lropt_has_pred_idx_check<T>[recursive](ListBlockOps::s_left<T>(l), bidx, p),
            ListConcatOps::s_concat_lropt_has_pred_idx_check<T>[recursive](ListBlockOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListBlockOps::s_left<T>(l)), p)
        );
    }

    recursive function s_concat_lropt_all_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_all_pred_check<T>(l, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_all_pred_check<T>(l, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_all_pred_check<T>[recursive](l, p);
        }
        else {
            return ListOperators::s_all_pred_check_base<T>(l, p);
        }
    }

    recursive function s_all_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return ListOps::s_all2(
            ListConcatOps::s_concat_lropt_all_pred_check<T>[recursive](ListBlockOps::s_left<T>(l), p),
            ListConcatOps::s_concat_lropt_all_pred_check<T>[recursive](ListBlockOps::s_right<T>(l), p)
        );
    }

    recursive function s_concat_lropt_all_pred_idx_check<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_all_pred_check_idx<T>(l, bidx, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_all_pred_check_idx<T>(l, bidx p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_all_pred_check_idx<T>[recursive](l, bidx, p);
        }
        else {
            return ListOperators::s_all_pred_check_base<T>(l, bidx, p);
        }
    }

    recursive? function s_all_pred_check_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return ListOps::s_all2(
            ListConcatOps::s_concat_lropt_all_pred_idx_check<T>[recursive](ListBlockOps::s_left<T>(l), bidx, p),
            ListConcatOps::s_concat_lropt_all_pred_idx_check<T>[recursive](ListBlockOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListBlockOps::s_left<T>(l)), p)
        );
    }

    recursive function s_concat_lropt_find_index_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_index_pred<T>[recursive?](l, bidx, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_find_index_pred<T>[recursive?](l, bidx, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_index_pred<T>[recursive](l, bidx, p);
        }
        else {
            return ListOperators::s_find_index_pred_base<T>[recursive?](l, bidx, p);
        }
    }

    recursive? function s_find_index_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let ff = ListConcatOps::s_concat_lropt_find_index_pred<T>[recursive](ListConcatOps::s_left<T>(l), bidx, p);
        if(ff !== none) {
            return ff;
        }
        else {
            return ListFlatOps::s_concat_lropt_find_index_pred<T>[recursive](ListBlockOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListBlockOps::s_left<T>(l)), p);
        }
    }

    recursive function s_concat_lropt_find_index_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_index_pred_idx<T>[recursive?](l, bidx, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_find_index_pred_idx<T>[recursive?](l, bidx p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_index_pred_idx<T>[recursive](l, bidx, p);
        }
        else {
            return ListOperators::s_find_index_pred_idx_base<T>[recursive?](l, bidx, p);
        }
    }

    recursive? function s_find_index_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let ff = ListConcatOps::s_concat_lropt_find_index_pred_idx<T>[recursive](ListConcatOps::s_left<T>(l), bidx, p);
        if(ff !== none) {
            return ff;
        }
        else {
            return ListFlatOps::s_concat_lropt_find_index_pred_idx<T>[recursive](ListBlockOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListBlockOps::s_left<T>(l)), p);
        }
    }

    recursive function s_concat_lropt_find_last_index_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_last_index_pred<T>[recursive?](l, bidx, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_find_last_index_pred<T>[recursive?](l, bidx, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_last_index_pred<T>[recursive](l, bidx, p);
        }
        else {
            return ListOperators::s_find_last_index_pred_base<T>[recursive?](l, bidx, p);
        }
    }

    recursive? function s_find_last_index_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let ll = ListConcatOps::s_concat_lropt_find_last_index_pred<T>[recursive?](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListBlockOps::s_left<T>(l)), p);
        if(ll !== none) {
            return ll;
        }
        else {
            return ListFlatOps::s_concat_lropt_find_last_index_pred<T>[recursive?](ListBlockOps::s_left<T>(l), bidx, p);
        }
    }

    recursive function s_concat_lropt_find_last_index_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_last_index_pred_idx<T>[recursive?](l, bidx, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_find_last_index_pred_idx<T>[recursive?](l, bidx p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_last_index_pred_idx<T>[recursive](l, bidx, p);
        }
        else {
            return ListOperators::s_find_last_index_pred_idx_base<T>[recursive?](l, bidx, p);
        }
    }

    recursive? function s_find_index_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let ll = ListConcatOps::s_concat_lropt_find_last_index_pred_idx<T>[recursive?](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListBlockOps::s_left<T>(l)), p);
        if(ll !== none) {
            return ll;
        }
        else {
            return ListFlatOps::s_concat_lropt_find_last_index_pred_idx<T>[recursive?](ListBlockOps::s_left<T>(l), bidx, p);
        }
    }
}

__internal entity ISequence provides Object {
    __safe function s_size(isq: ISequence): Nat # isequence_size
}

__internal entity JSequence provides Object {
    __safe function s_size(jsq: JSequence): Nat # jsequence_size
}

__internal entity SSequence provides Object {
    __safe function s_size(ssq: SSequence): Nat # ssequence_size
}

__internal entity USequence provides Object {
    __safe function s_size(usq: USequence): Nat # usequence_size
}

__internal entity ListOps provides Object {
    ////////////////
    //Called from Lib AND Builtin
    __assume_safe s_safeAs<T, U>(v: T): U # list_safeas
    __safe function s_or2(b1: Bool, b2: Bool): Bool # list_or2
    __safe function s_or3(b1: Bool, b2: Bool, b3: Bool): Bool # flat_or3
    __safe function s_and2(b1: Bool, b2: Bool): Bool # list_and2
    __safe function s_and3(b1: Bool, b2: Bool, b3: Bool): Bool # flat_and3

    __safe function s_size<T>(l: List<T>): Nat # list_size

    __assume_safe function s_range_int(start: Int, end: Int): List<Int> # list_rangeofint
    __assume_safe function s_range_nat(start: Nat, end: Nat): List<Nat> # list_rangeofnat
    __assume_safe function s_fill<T>(k: Nat, val: T): List<T> # list_fill

    __assume_safe function s_zip<T, U>(l1: List<T>, l2: List<U>, size: Nat): List<[T, U]> # list_zip
    __assume_safe function s_zip_index<T>(l1: List<T>, size: Nat): List<[Nat, T]> # list_zipindex

    ////////////////
    //Builtin
    __assume_safe function s_safe_get_impl<T>(l: List<T>, i: Nat): T # list_safe_get

    //Return an error if there is an application of the pred to an element in the list that is an error -- otherwise list value
    recursive? function s_safe_check_pred_impl<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_safe_check_pred
    recursive? function s_safe_check_pred_idx_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> # list_safe_check_pred_idx

    //Return an error if there is an application of the function to an element in the list that is an error -- otherwise list value
    recursive? function s_safe_check_fn_impl<T, U>(l: List<T>, count: Nat, f: recursive? fn(_: T) -> U): List<T> # list_safe_check_fn
    recursive? function s_safe_check_fn_idx_impl<T, U>(l: List<T>, count: Nat, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<T> # list_safe_check_fn_idx

    recursive? function s_safe_check_pred_pair_impl<T, U>[recursive?](l: List<T>, lcount: Nat, ol: List<U>, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): [List<T>, List<U>] # list_safe_check_pred_pair
    recursive? function s_safe_check_pred_picks_impl<T, U>[recursive?](l: List<T>, count: Nat, p: recursive? pred(_: T, _: T) -> Bool): List<T> # list_safe_check_pred_picks

    recursive? function s_has_pred_check_impl<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_has_pred_check
    recursive? function s_has_pred_check_idx_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> # list_has_pred_check_idx

    recursive? function s_all_pred_check_impl<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_all_pred_check
    recursive? function s_all_pred_check_idx_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> # list_all_pred_check_idx

    recursive? function s_find_index_pred_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat # list_find_index_pred
    recursive? function s_find_index_pred_idx_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat # list_find_index_pred_idx

    recursive? function s_find_last_index_pred_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat # list_find_last_index_pred
    recursive? function s_find_last_index_pred_idx_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat # list_find_last_index_pred_idx

    __assume_safe function s_concat2_impl(l1: List<T>, l2: List<T>, count: Nat): List<T> # list_concat2
    __assume_safe function s_slice_impl(l: List<T>, start: Nat, end: Nat, count: Nat): List<T> # list_slice

    //assume non-empty, safe, and exists at least one satisfying
    recursive? function s_computeISequence<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): ISequence # list_computeisequence
    recursive? function s_computeJSequence<T, U>(l: List<T>, lcount: Nat, ol: List<U>, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> # list_computejsequence

    //assume non-empty and safe
    recursive? function s_computeSSequence<T>(l: List<T>, count: Nat, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> # list_computessequence
    recursive? function s_computeUSequence<T>(l: List<T>, count: Nat, eq: recursive? pred(_: T, _: T) -> Bool): List<T> # list_computeusequence

    ////////////////
    //Called from lib
    function s_smallFlat<T>(l: List<T>, count: Nat): List<T> {
        if(count == 0) {
            return List<T>@{};
        }
        elif(count == 1) {
            return List<T>@{ListOps::s_safe_get<T>(l, 0)};
        }
        elif(count == 2) {
            return List<T>@{ListOps::s_safe_get<T>(l, 0), ListOps::s_safe_get<T>(l, 1)};
        }
        elif(count == 3) {
            return List<T>@{ListOps::s_safe_get<T>(l, 0), ListOps::s_safe_get<T>(l, 1), ListOps::s_safe_get<T>(l, 2)};
        }
        elif(count == 4) {
            return List<T>@{ListOps::s_safe_get<T>(l, 0), ListOps::s_safe_get<T>(l, 1), ListOps::s_safe_get<T>(l, 2), ListOps::s_safe_get<T>(l, 3)};
        }
        elif(count == 5) {
            return List<T>@{ListOps::s_safe_get<T>(l, 0), ListOps::s_safe_get<T>(l, 1), ListOps::s_safe_get<T>(l, 2), ListOps::s_safe_get<T>(l, 3), ListOps::s_safe_get<T>(l, 4)};
        }
        else {
            return List<T>@{ListOps::s_safe_get<T>(l, 0), ListOps::s_safe_get<T>(l, 1), ListOps::s_safe_get<T>(l, 2), ListOps::s_safe_get<T>(l, 3), ListOps::s_safe_get<T>(l, 4), ListOps::s_safe_get<T>(l, 5)};
        }
    }

    function s_smallConcat<T>(l: List<T>, count: Nat): List<T> {
        if(count == 0) {
            return List<T>@{};
        }
        elif(count == 1) {
            return List<T>@{ListConcatOps::s_at[recursive]<T>(l, 0)};
        }
        elif(count == 2) {
            return List<T>@{ListOps::s_at[recursive]<T>(l, 0), ListOps::s_at[recursive]<T>(l, 1)};
        }
        elif(count == 3) {
            return List<T>@{ListOps::s_at[recursive]<T>(l, 0), ListOps::s_at[recursive]<T>(l, 1), ListOps::s_at[recursive]<T>(l, 2)};
        }
        elif(count == 4) {
            return List<T>@{ListOps::s_at[recursive]<T>(l, 0), ListOps::s_at[recursive]<T>(l, 1), ListOps::s_at[recursive]<T>(l, 2), ListOps::s_at[recursive]<T>(l, 3)};
        }
        elif(count == 5) {
            return List<T>@{ListOps::s_at[recursive]<T>(l, 0), ListOps::s_at[recursive]<T>(l, 1), ListOps::s_at[recursive]<T>(l, 2), ListOps::s_at[recursive]<T>(l, 3), ListOps::s_at[recursive]<T>(l, 4)};
        }
        else {
            return List<T>@{ListOps::s_at[recursive]<T>(l, 0), ListOps::s_at[recursive]<T>(l, 1), ListOps::s_at[recursive]<T>(l, 2), ListOps::s_at[recursive]<T>(l, 3), ListOps::s_at[recursive]<T>(l, 4), ListOps::s_at[recursive]<T>(l, 5)};
        }
    }

    function s_smallSlice<T>(l: List<T>, start: Nat, end: Nat, count: Nat): List<T> {
        if(count == 0) {
            return List<T>@{};
        }
        elif(count == 1) {
            return List<T>@{ListOps::s_safe_get<T>(l, start)};
        }
        elif(count == 2) {
            return List<T>@{ListOps::s_safe_get<T>(l, start), ListOps::s_safe_get<T>(l, start + 1)};
        }
        elif(count == 3) {
            return List<T>@{ListOps::s_safe_get<T>(l, start), ListOps::s_safe_get<T>(l, start + 1), ListOps::s_safe_get<T>(l, start + 2)};
        }
        elif(count == 4) {
            return List<T>@{ListOps::s_safe_get<T>(l, start), ListOps::s_safe_get<T>(l, start + 1), ListOps::s_safe_get<T>(l, start + 2), ListOps::s_safe_get<T>(l, start + 3)};
        }
        elif(count == 5) {
            return List<T>@{ListOps::s_safe_get<T>(l, start), ListOps::s_safe_get<T>(l, start + 1), ListOps::s_safe_get<T>(l, start + 2), ListOps::s_safe_get<T>(l, start + 3), ListOps::s_safe_get<T>(l, start + 4)};
        }
        else {
            return List<T>@{ListOps::s_safe_get<T>(l, start), ListOps::s_safe_get<T>(l, start + 1), ListOps::s_safe_get<T>(l, start + 2), ListOps::s_safe_get<T>(l, start + 3), ListOps::s_safe_get<T>(l, start + 4), ListOps::s_safe_get<T>(l, start + 5)};
        }
    }

    function s_safe_get<T>(l: List<T>, i: Nat): T {
#if SMALL_MODEL_ENABLED
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_at<T>(l, i);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_at<T>(l, i);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_at<T>[recursive](l, i);
        }
        else {
#endif
            return ListOps::s_safe_get_impl<T>(l, i);
#if SMALL_MODEL_ENABLED
        }
#endif
    }

    recursive? function s_has_pred_check_base<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        let sl = ListOps::s_safe_check_pred_impl<T>[recursive?](l, ListOps::s_size<T>(l), p);
        return ListOps::s_has_pred_check_impl<T>(sl, ListOps::s_size<T>(sl), p);
    }

    recursive? function s_has_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListFlatOps::s_empty<T>(l)) {
            return false;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_has_pred_check<T>[recursive?](l, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_has_pred_check<T>[recursive?](l, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_has_pred_check<T>[recursive](l, p);
        }
#endif
        else {
            return ListOps::s_has_pred_check_base<T>[recursive?](l, p);
        }
    }

    recursive? function s_has_pred_check_idx_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let sl = ListOps::s_safe_check_pred_idx_impl<T>[recursive?](l, ListOps::s_size<T>(l), bidx, p);
        return ListOps::s_has_pred_check_idx_impl<T>(sl, ListOps::s_size<T>(sl), bidx, p);
    }

    recursive? function s_has_pred_check_idx<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_has_pred_check_idx<T>[recursive?](l, 0, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_has_pred_check_idx<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_has_pred_check_idx<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_has_pred_check_idx_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_all_pred_check_base<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        let sl = ListOps::s_safe_check_pred_impl<T>[recursive?](l, ListOps::s_size<T>(l), p);
        return ListOps::s_all_pred_check_impl<T>(sl, ListOps::s_size<T>(sl), p);
    }

    recursive? function s_all_pred_check<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListFlatOps::s_empty<T>(l)) {
            return true;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_all_pred_check<T>[recursive?](l, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_all_pred_check<T>[recursive?](l, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_all_pred_check<T>[recursive](l, p);
        }
#endif
        else {
            return ListOps::s_all_pred_check_base<T>[recursive?](l, p);
        }
    }

    recursive? function s_all_pred_check_idx_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let sl = ListOperators::s_safe_check_pred_idx_impl<T>[recursive?](l, ListOps::s_size<T>(l), bidx, p);
        return ListOperators::s_all_pred_check_idx_impl<T>(sl, ListOps::s_size<T>(sl), bidx, p);
    }

    recursive? function s_all_pred_check_idx<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return true;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_all_pred_check_idx<T>[recursive?](l, 0, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_all_pred_check_idx<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_all_pred_check_idx<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_all_pred_check_idx_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_find_index_pred_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let sl = ListOperators::s_safe_check_pred_impl<T>[recursive?](l, ListOperators::s_size<T>(l), p);
        let count = ListOperators::s_size<T>(sl);

        if(ListOperators::s_has_pred_check_impl<T>[recursive?](sl, count, p)) {
            return ListOperators::s_find_index_pred_impl<T>[recursive?](sl, count, bidx, p);
        }
        else {
            return none;
        }
    }

    recursive? function s_find_index_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_index_pred<T>[recursive?](l, 0, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_find_index_pred<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_index_pred<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_find_index_pred_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_find_index_pred_idx_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let sl = ListOperators::s_safe_check_pred_idx_impl<T>[recursive?](l, ListOperators::s_size<T>(l), bidx, p);
        let count = ListOperators::s_size<T>(sl);

        if(ListOperators::s_has_pred_check_idx_impl<T>[recursive?](sl, count, bidx, p)) {
            return ListOperators::s_find_index_pred_idx_impl<T>[recursive?](sl, count, bidx, p);
        }
        else {
            return none;
        }
    }

    recursive? function s_find_index_pred_idx<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_index_pred_idx<T>[recursive?](l, 0, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_find_index_pred_idx<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_index_pred_idx<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_find_index_pred_idx_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_find_last_index_pred_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let sl = ListOperators::s_safe_check_pred_impl<T>[recursive?](l, ListOperators::s_size<T>(l), p);
        let count = ListOperators::s_size<T>(sl);

        if(ListOperators::s_has_pred_check_impl<T>[recursive?](sl, count, p)) {
            return ListOperators::s_find_last_index_pred_impl<T>[recursive?](sl, count, bidx, p);
        }
        else {
            return none;
        }
    }

    recursive? function s_find_last_index_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_last_index_pred<T>[recursive?](l, 0, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_find_last_index_pred<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_last_index_pred<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_find_last_index_pred_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_find_index_pred_idx_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let sl = ListOperators::s_safe_check_pred_idx_impl<T>[recursive?](l, ListOperators::s_size<T>(l), bidx, p);
        let count = ListOperators::s_size<T>(sl);

        if(ListOperators::s_has_pred_check_idx_impl<T>[recursive?](sl, count, bidx, p)) {
            return ListOperators::s_find_last_index_pred_idx_impl<T>[recursive?](sl, count, bidx, p);
        }
        else {
            return none;
        }
    }

    recursive? function s_find_index_pred_idx<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_last_index_pred_idx<T>[recursive?](l, 0, p);
        }
        elif(ListBlockOps::s_isBlockList<T>(l)) {
            return ListBlockOps::s_find_last_index_pred_idx<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_last_index_pred_idx<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_find_index_pred_idx_base<T>[recursive?](l, 0, p);
        }
    }

    function s_concat2<T>(l1: List<T>, l2: List<T>): List<T> {
        let l1empty = ListFlatOps::s_empty<T>(l1);
        let l2empty = ListFlatOps::s_empty<T>(l2);

        if(ListOps::s_and2(l1empty, l2empty)) {
            return List<T>@{};
        }
        else {
            if(l1empty) {
                return l2;
            }
            elif(l2empty) {
                return l1;
            }
            else {
                let l1size = ListOps::s_size<T>(l1);
                let l2size = ListOps::s_size<T>(l2);
                let ncount = l1size + l2size;

                let cc = ListOps::s_concat2_impl<T>(l1, l2, ncount);
#if SMALL_MODEL_ENABLED
                if(ncount <= 6) {
                    return ListOps::s_smallConcat(cc, ncount);
                }
                else {
#endif
                    return cc;
#if SMALL_MODEL_ENABLED
                }
#endif
            }
        }
    }

    function s_slice<T>(l: List<T>, start: Nat, end: Nat): List<T> {
        let count = end - start;

        if(count == 0) {
            return List<T>@{};
        }
        elif (count == ListOps::s_size<T>(l)) {
            return l;
        }
        else {
#if SMALL_MODEL_ENABLED
            if(count <= 6) {
                return ListOps::s_smallSlice(l, start, end, count);
            }
            else {
#endif
                return ListOps::s_slice_impl<T>(l, start, end, count);  
#if SMALL_MODEL_ENABLED
            }    
#endif
        }
    }


    recursive? function s_map_Helper<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        if(ListOperators::s_empty<T>(l)) {
            return List<U>@{};
        }
        else {
            let sl = ListOperators::s_safeCheckFn<T, U>[recursive?](l, f);

            //TODO: here special case for small model
            return ListOperators::s_map_Constructor<T, U>[recursive?](sl, ListOperators::s_size<T>(sl), f);
        }
    }

    recursive? function s_filter_Helper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, recursive? pred(v: T) => !p[recursive?](v))) {
                    let isq = ListOperators::s_computeISequence<T>[recursive?](sl, count, p);
                    return ListOperators::s_filter_Constructor<T>[recursive?](sl, isq, count, p);
                }
                else {
                    return sl;
                }
            }
            else {
                return List<T>@{};
            }
        }
    }

    //Core accessors

    ////
    //Constructors 
    __assume_safe function s_reverse_Constructor(l: List<T>, count: Nat): List<T> # list_reverse

    recursive? function s_filter_Constructor<T>(l: List<T>, isq: ISequence, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_filter_helper

    recursive? function s_map_Constructor<T, U>(l: List<T>, count: Nat, f: recursive? fn(_: T) -> U): List<U> # list_map

    recursive? function s_join_Constructor<T, U>(l: List<T>, ol: List<U>, jsq: JSequence, lcount: Nat, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> # list_join_helper

    recursive? function s_sort_Constructor<T>(l: List<T>, ssq: SSequence, count: Nat, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> # list_sort_helper
    recursive? function s_unique_Constructor<T>(l: List<T>, usq: USequence, count: Nat, eq: recursive? pred(_: T, _: T) -> Bool): List<T> # list_filter_helper

   
    ////////////////
    //In code support operations
    ////////////////

    

    

    function s_reverse_Helper<T>(l: List<T>): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let count = ListOperators::s_size<T>(l);
            if (count == 1) {
                return l;
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_reverse_Constructor<T>(l, count);  
            }
        }
    }

    recursive? function s_countIf_Helper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, recursive? pred(v: T) => !p[recursive?](v))) {
                    let isq = ListOperators::s_computeISequence[recursive?](sl, count, p);
                    return ISequence::s_size(isq);
                }
                else {
                    return count;
                }
            }
            else {
                return 0n;
            }
        }
    }

   

    recursive? function s_join_Helper<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        if(ListOperators::s_empty(l)) {
            return List<[T, U]>@{};
        }
        elif(ListOperators::s_empty(ol)) {
            return List<[T, U]>@{};
        }
        else {
            let sl, sol = ListOperators::s_safeCheckPred_Pair<T, U>[recursive?](l, ol, p);
            let count = ListOperators::s_size<T>(sl);
            let ocount = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheckPair_Core<T, U>[recursive?](sl, count, sol, ocount, p)) {
                let jsq = ListOperators::s_computeJSequence<T>[recursive?](sl, count, sol, ocount, p);
                return ListOperators::s_join_Constructor<T>[recursive?](sl, sol, jsq, count, ocount, p);
            }
            else {
                return List<[T, U]>@{};
            }
        }
    }

    recursive? function s_sort_Helper<T>(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        elif (ListOperators::s_size<T>(l) == 1) {
            return l;
        }
        else {
            let sl = ListOperators::s_safeCheckPred_PairSingle<T>[recursive?](l, cmp);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            let ssq = ListOperators::s_computeSSequence<T>[recursive?](sl, count, cmp);
            return ListOperators::s_sort_Constructor<T>[recursive?](sl, ssq, count, cmp);
        }
    }

    recursive? function s_unique_Helper<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        elif (ListOperators::s_size<T>(l) == 1) {
            return l;
        }
        else {
            let sl = ListOperators::s_safeCheckPred_PairSingle<T>[recursive?](l, cmp);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            let usq = ListOperators::s_computeUSequence<T>[recursive?](sl, count, cmp);
            return ListOperators::s_unique_Constructor<T>[recursive?](sl, usq, count, cmp);
        }
    }
}

__internal entity ListKeyOperators provides Object {
    ////////////////
    //Built Implemented Functions
    ////////////////

    //assume non-empty
    function s_hasCheck_Core<T grounded KeyType>(l: List<T>, count: Nat, val: T): Bool # list_hascheck
    function s_hasCheckMapKV_Core<T grounded KeyType, U>(l: List<[T, U]>, count: Nat, val: T): Bool # list_hascheckmapkv

    //assume non-empty
    function s_findIndexOf_KeyHelperCore<T grounded KeyType>(l: List<T>, count: Nat, val: T): Nat # list_findindexof_keyhelper
    function s_findIndexOfLast_KeyHelperCore<T grounded KeyType>(l: List<T>, count: Nat, val: T): Nat # list_findindexoflast_keyhelper
    function s_findIndexOfMapKV_KeyHelperCore<T grounded KeyType, U>(l: List<[T, U]>, count: Nat, val: T): Nat # list_findindexofmapkv_keyhelper

    function s_overlapsMapKV_KeyHelperCore<T grounded KeyType, U>(l1: List<[T, U]>, count1: Nat, l2: List<[T, U]>, count2: Nat): Bool # list_overlapsmapkv_keyhelper

    ////////////////
    //In code support operations
    ////////////////

    function s_hasCheck<T grounded KeyType>(l: List<T>, val: T): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            //TODO: here special case for small model
            return ListKeyOperators::s_hasCheck_Core<T>(l, ListOperators::s_size<T>(l), val);
        }
    }

    function s_hasCheckMapKV<T grounded KeyType, U>(l: List<[T, U]>, val: T): Bool {
        if(ListOperators<[T, U]>::s_empty(l)) {
            return false;
        }
        else {
            //TODO: here special case for small model
            return ListKeyOperators<[T, U]>::s_hasCheckMapKV_Core(l, ListOperators<[T, U]>::s_size(l), val);
        }
    }

    function s_findIndexOf_KeyHelper<T grounded KeyType>(l: List<T>, val: T): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let count = ListOperators::s_size<T>(l);

            //TODO: here special case for small model
            if(ListKeyOperators::s_hasCheck_Core<T>(l, count, val)) {
                return ListKeyOperators::s_findIndexOf_KeyHelperCore<T>(l, count, val);
            }
            else {
                return count;
            }
        }
    }

    function s_findIndexOfLast_KeyHelper<T grounded KeyType>(l: List<T>, val: T): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let count = ListOperators::s_size<T>(l);

            //TODO: here special case for small model
            if(ListKeyOperators::s_hasCheck_Core<T>(l, count, val)) {
                return ListKeyOperators::s_findIndexOfLast_KeyHelperCore<T>(l, count, val);
            }
            else {
                return count;
            }
        }
    }

    function s_findIndexOfMapKV_KeyHelper<T grounded KeyType, U>(l: List<[T, U]>, val: T): Nat {
        if(ListOperators::s_empty<[T, U]>(l)) {
            return 0n;
        }
        else {
            let count = ListOperators::s_size<[T, U]>(l);

            //TODO: here special case for small model
            if(ListKeyOperators::s_hasCheckMapKV_Core<T, U>(l, count, val)) {
                return ListKeyOperators::s_findIndexOfMapKV_KeyHelperCore<T, U>(l, count, val);
            }
            else {
                return count;
            }
        }
    }

    function s_overlapsMapKV_KeyHelper<T grounded KeyType, U>(l1: List<[T, U]>, l2: List<[T, U]>): Bool {
        if(ListOperators::s_empty<[T, U]>(l1)) {
            return false;
        }
        elif(ListOperators::s_empty<[T, U]>(l2)) {
            return false;
        }
        else {
            let count1 = ListOperators::s_size<[T, U]>(l1);
            let count2 = ListOperators::s_size<[T, U]>(l2);

            //TODO: here special case for small model
            return ListKeyOperators::s_overlapsMapKV_KeyHelperCore<T, U>(l1, count1, l2, count2);
        }
    }
}

__internal entity ListArithOperators provides Object {
    ////////////////
    //Built Implemented Functions
    ////////////////

    //assume non-empty
    function s_minIdx_Core<T unique Orderable>(l: List<[Nat, T]>): Nat # list_minidx
    function s_maxIdx_Core<T unique Orderable>(l: List<[Nat, T]>): Nat # list_maxidx

#if UF_APPROX
    function s_sum_Core<T unique Algebraic>(l: List<T>): T # list_sum
#endif

    ////////////////
    //In code support operations
    ////////////////

    function s_minIdx_Helper<T unique Orderable>(l: List<T>): Nat {
        let count = ListOperators::s_size<T>(l);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(l, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(l, 0n);
            let b = ListOperators::s_safe_get<T>(l, 1n);
            if(a <= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = l.index();
            return ListOperators::s_minIdx_Core<T>(zl);
        }
    }
    
    function s_maxIdx_Helper<T unique Orderable>(l: List<T>): Nat {
        let count = ListOperators::s_size<T>(l);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(l, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(l, 0n);
            let b = ListOperators::s_safe_get<T>(l, 1n);
            if(a >= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = l.index();
            return ListOperators::s_maxIdx_Core<T>(zl);
        }
    }

    recursive? function s_argminIdx_Helper<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): Nat {
        let fl = l.map(f);
        let count = ListOperators::s_size<T>(fl);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(fl, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(fl, 0n);
            let b = ListOperators::s_safe_get<T>(fl, 1n);
            if(a <= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = fl.index();
            return ListOperators::s_minIdx_Core<U>(zl);
        }
    }
    
    recursive? function s_argmaxIdx_Helper<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): Nat {
         let fl = l.map(f);
        let count = ListOperators::s_size<T>(fl);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(fl, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(fl, 0n);
            let b = ListOperators::s_safe_get<T>(fl, 1n);
            if(a <= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = fl.index();
            return ListOperators::s_maxIdx_Core<U>(sl);
        }
    }

#if UF_APPROX
    function s_sum_Helper<T unique Algebraic>(l: List<T>): T {
        if(ListOperators::s_empty<T>(l)) {
            return T::zero;
        }
        else {
            let count = ListOperators::s_size<T>(l);
            
            if(count == 1n) {
                return ListOperators::s_safe_get<T>(l, 0n);
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_sum_Core<T>(l);
            }
        }
    }
#else
    recursive function s_sum_Core<T unique Algebraic>(l: List<T>, acc: T, cpos: Nat, count: Nat): T {
        if(cpos == count) {
            return acc;
        }
        else {
            let nacc = acc + ListOperators::s_safe_get<T>(l, cpos);
            return ListOperators::s_sum_Core<T>[recursive](l, nacc, cpos + 1n, count);
        }
    }

    function s_sum_Helper<T unique Algebraic>(l: List<T>): T {
        if(ListOperators::s_empty<T>(l)) {
            return T::zero;
        }
        else {
            let count = ListOperators::s_size<T>(l);
            
            if(count == 1n) {
                return ListOperators::s_safe_get<T>(l, 0n);
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_sum_Core<T>[recursive](l, T::zero, 0n, count);
            }
        }
    }
#endif
}
