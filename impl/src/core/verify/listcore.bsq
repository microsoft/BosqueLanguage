//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

__internal entity ListFlatOps provides Some {
    __safe function s_empty<T>(l: List<T>): Bool # list_empty

    __safe function s_is1<T>(l: List<T>): Bool # flat_list_is1
    __assume_safe function s_1at0<T>(l: List<T>): T # flat_list_1at0

    __safe function s_is2<T>(l: List<T>): Bool # flat_list_is2
    __assume_safe function s_2at0<T>(l: List<T>): T # flat_list_2at0
    __assume_safe function s_2at1<T>(l: List<T>): T # flat_list_2at1

    __safe function s_is3<T>(l: List<T>): Bool # flat_list_is3
    __assume_safe function s_3at0<T>(l: List<T>): T # flat_list_3at0
    __assume_safe function s_3at1<T>(l: List<T>): T # flat_list_3at1
    __assume_safe function s_3at2<T>(l: List<T>): T # flat_list_3at2

    //equiv s_empty | s_is1 | s_is2 | s_is3
    __safe function s_isFlatList<T>(l: List<T>): Bool # list_isflat

    ////
    //s_at
    function s_at_1<T>(l: List<T>, i: Nat): T {
        return ListFlatOps::s_1at0<T>(l);
    }
    function s_at_2<T>(l: List<T>, i: Nat): T {
        if(i == 0n) {
            return ListFlatOps::s_2at0<T>(l);
        }
        else {
            return ListFlatOps::s_2at1<T>(l);
        }
    }
    function s_at_3<T>(l: List<T>, i: Nat): T {
        if(i == 0n) {
            return ListFlatOps::s_3at0<T>(l);
        }
        elif(i == 1n) {
            return ListFlatOps::s_3at1<T>(l);
        }
        else {
            return ListFlatOps::s_3at2<T>(l);
        }
    }
    function s_at<T>(l: List<T>, i: Nat): T {
        if(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_at_1<T>(l, i);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_at_2<T>(l, i);
        }
        else {
            return ListFlatOps::s_at_3<T>(l, i);
        }
    }

    ////
    //s_slice_front
    function s_slice_front_1<T>(l: List<T>, start: Nat): List<T> {
        if(start == 0n) {
            return l;
        }
        else {
            return List<T>@{};
        }
    }
    function s_slice_front_2<T>(l: List<T>, start: Nat): List<T> {
        if(start == 0n) {
            return l;
        }
        elif(start == 1n) {
            return List<T>@{ListFlatOps::s_2at1<T>(l)};
        }
        else {
            return List<T>@{};
        }
    }
    function s_slice_front_3<T>(l: List<T>, start: Nat): List<T> {
        if(start == 0n) {
            return l;
        }
        elif(start == 1n) {
            return List<T>@{ListFlatOps::s_3at1<T>(l), ListFlatOps::s_3at2<T>(l)};
        }
        elif(start == 2n) {
            return List<T>@{ListFlatOps::s_3at2<T>(l)};
        }
        else {
            return List<T>@{};
        }
    }
    function s_slice_front<T>(l: List<T>, start: Nat): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_slice_front_1<T>(l, start);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_slice_front_2<T>(l, start);
        }
        else {
            return ListFlatOps::s_slice_front_3<T>(l, start);
        }
    }

    ////
    //s_slice_back
    function s_slice_back_1<T>(l: List<T>, end: Nat): List<T> {
        if(end == 1n) {
            return l;
        }
        else {
            return List<T>@{};
        }
    }
    function s_slice_back_2<T>(l: List<T>, end: Nat): List<T> {
        if(end == 2n) {
            return l;
        }
        elif(end == 1n) {
            return List<T>@{ListFlatOps::s_2at0<T>(l)};
        }
        else {
            return List<T>@{};
        }
    }
    function s_slice_back_3<T>(l: List<T>, end: Nat): List<T> {
        if(end == 3n) {
            return l;
        }
        elif(end == 2n) {
            return List<T>@{ListFlatOps::s_3at0<T>(l), ListFlatOps::s_3at1<T>(l)};
        }
        elif(end == 1n) {
            return List<T>@{ListFlatOps::s_3at0<T>(l)};
        }
        else {
            return List<T>@{};
        }
    }
    function s_slice_back<T>(l: List<T>, end: Nat): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_slice_back_1<T>(l, end);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_slice_back_2<T>(l, end);
        }
        else {
            return ListFlatOps::s_slice_back_3<T>(l, end);
        }
    }

    ////
    //s_slice
    function s_slice<T>(l: List<T>, start: Nat, end: Nat): List<T> {
        let ff = ListFlatOps::s_slice_front<T>(l, start);
        let ll = ListFlatOps::s_slice_back<T>(ff, end - start);

        return ll;
    }

    ////
    //s_has_pred
    recursive? function s_has_pred_1<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return p[recursive?](ListFlatOps::s_1at0<T>(l));
    }
    recursive? function s_has_pred_2<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return ListOps::s_or2(p[recursive?](ListFlatOps::s_2at0<T>(l)), p[recursive?](ListFlatOps::s_2at1<T>(l)));
    }
    recursive? function s_has_pred_3<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return ListOps::s_or3(p[recursive?](ListFlatOps::s_3at0<T>(l)), p[recursive?](ListFlatOps::s_3at1<T>(l)), p[recursive?](ListFlatOps::s_3at2<T>(l)));
    }
    recursive? function s_has_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListFlatOps::s_empty<T>(l)) {
            return false;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_has_pred_1<T>[recursive?](l, p);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_has_pred_2<T>[recursive?](l, p);
        }
        else {
            return ListFlatOps::s_has_pred_3<T>[recursive?](l, p);
        }
    }

    ////
    //s_has_pred_idx
    recursive? function s_has_pred_idx_1<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return p[recursive?](ListFlatOps::s_1at0<T>(l), bidx);
    }
    recursive? function s_has_pred_idx_2<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return ListOps::s_or2(p[recursive?](ListFlatOps::s_2at0<T>(l), bidx), p[recursive?](ListFlatOps::s_2at1<T>(l), bidx + 1n));
    }
    recursive? function s_has_pred_idx_3<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return ListOps::s_or3(p[recursive?](ListFlatOps::s_3at0<T>(l), bidx), p[recursive?](ListFlatOps::s_3at1<T>(l), bidx + 1n), p[recursive?](ListFlatOps::s_3at2<T>(l), bidx + 2n));
    }
    recursive? function s_has_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListFlatOps::s_empty<T>(l)) {
            return false;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_has_pred_idx_1<T>[recursive?](l, bidx, p);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_has_pred_idx_2<T>[recursive?](l, bidx, p);
        }
        else {
            return ListFlatOps::s_has_pred_idx_3<T>[recursive?](l, bidx, p);
        }
    }

    ////
    //s_find_pred
    recursive? function s_find_pred_1<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_1at0<T>(l))) {
            return bidx;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_pred_2<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_2at0<T>(l))) {
            return bidx;
        } 
        elif(p[recursive?](ListFlatOps::s_2at1<T>(l))) {
            return bidx + 1n;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_pred_3<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_3at0<T>(l))) {
            return bidx;
        }
        elif(p[recursive?](ListFlatOps::s_3at1<T>(l))) {
            return bidx + 1n;
        }
        elif(p[recursive?](ListFlatOps::s_3at2<T>(l))) {
            return bidx + 2n;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_find_pred_1<T>[recursive?](l, bidx, p);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_find_pred_2<T>[recursive?](l, bidx, p);
        }
        else {
            return ListFlatOps::s_find_pred_3<T>[recursive?](l, bidx, p);
        }
    }

    ////
    //s_find_pred_idx
    recursive? function s_find_pred_idx_1<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_1at0<T>(l), bidx)) {
            return bidx;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_pred_idx_2<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_2at0<T>(l), bidx)) {
            return bidx;
        } 
        elif(p[recursive?](ListFlatOps::s_2at1<T>(l), bidx + 1n)) {
            return bidx + 1n;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_pred_idx_3<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_3at0<T>(l), bidx)) {
            return bidx;
        }
        elif(p[recursive?](ListFlatOps::s_3at1<T>(l), bidx + 1n)) {
            return bidx + 1n;
        }
        elif(p[recursive?](ListFlatOps::s_3at2<T>(l), bidx + 2n)) {
            return bidx + 2n;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_find_pred_idx_1<T>[recursive?](l, bidx, p);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_find_pred_idx_2<T>[recursive?](l, bidx, p);
        }
        else {
            return ListFlatOps::s_find_pred_idx_3<T>[recursive?](l, bidx, p);
        }
    }


    ////
    //s_find_last_pred
    recursive? function s_find_last_pred_1<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
         if(p[recursive?](ListFlatOps::s_1at0<T>(l))) {
            return bidx;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_last_pred_2<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_2at1<T>(l))) {
            return bidx + 1n;
        } 
        elif(p[recursive?](ListFlatOps::s_2at0<T>(l))) {
            return bidx;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_last_pred_3<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_3at2<T>(l))) {
            return bidx + 2n;
        }
        elif(p[recursive?](ListFlatOps::s_3at1<T>(l))) {
            return bidx + 1n;
        }
        elif(p[recursive?](ListFlatOps::s_3at0<T>(l))) {
            return bidx;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_last_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_find_last_pred_1<T>[recursive?](l, bidx, p);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_find_last_pred_2<T>[recursive?](l, bidx, p);
        }
        else {
            return ListFlatOps::s_find_last_pred_3<T>[recursive?](l, bidx, p);
        }
    }

    ////
    //s_find_last_pred_idx
    recursive? function s_find_last_pred_idx_1<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
         if(p[recursive?](ListFlatOps::s_1at0<T>(l), bidx)) {
            return bidx;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_last_pred_idx_2<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_2at1<T>(l), bidx + 1n)) {
            return bidx + 1n;
        } 
        elif(p[recursive?](ListFlatOps::s_2at0<T>(l), bidx)) {
            return bidx;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_last_pred_idx_3<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(p[recursive?](ListFlatOps::s_3at2<T>(l), bidx + 2n)) {
            return bidx + 2n;
        }
        elif(p[recursive?](ListFlatOps::s_3at1<T>(l), bidx + 1n)) {
            return bidx + 1n;
        }
        elif(p[recursive?](ListFlatOps::s_3at0<T>(l), bidx)) {
            return bidx;
        }
        else {
            return none;
        }
    }
    recursive? function s_find_last_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_find_last_pred_idx_1<T>[recursive?](l, bidx, p);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_find_last_pred_idx_2<T>[recursive?](l, bidx, p);
        }
        else {
            return ListFlatOps::s_find_last_pred_idx_3<T>[recursive?](l, bidx, p);
        }
    }

    ////
    //s_map
    recursive? function s_map_1<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        return List<U>@{f[recursive?](ListFlatOps::s_1at0<T>(l))};
    }
    recursive? function s_map_2<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        return List<U>@{f[recursive?](ListFlatOps::s_2at0<T>(l)), f[recursive?](ListFlatOps::s_2at1<T>(l))};
    }
    recursive? function s_map_3<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        return List<U>@{f[recursive?](ListFlatOps::s_3at0<T>(l)), f[recursive?](ListFlatOps::s_3at1<T>(l)), f[recursive?](ListFlatOps::s_3at2<T>(l))};
    }
    recursive? function s_map<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<U>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_map_1<T, U>[recursive?](l, f);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_map_2<T, U>[recursive?](l, f);
        }
        else {
            return ListFlatOps::s_map_3<T, U>[recursive?](l, f);
        }
    }

    ////
    //s_map_idx
    recursive? function s_map_idx_1<T, U>(l: List<T>, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        return List<U>@{f[recursive?](ListFlatOps::s_1at0<T>(l), bidx)};
    }
    recursive? function s_map_idx_2<T, U>(l: List<T>, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        return List<U>@{f[recursive?](ListFlatOps::s_2at0<T>(l), bidx), f[recursive?](ListFlatOps::s_2at1<T>(l), bidx + 1n)};
    }
    recursive? function s_map_idx_3<T, U>(l: List<T>, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        return List<U>@{f[recursive?](ListFlatOps::s_3at0<T>(l), bidx), f[recursive?](ListFlatOps::s_3at1<T>(l), bidx + 1n), f[recursive?](ListFlatOps::s_3at2<T>(l), bidx + 2n)};
    }
    recursive? function s_map_idx<T, U>(l: List<T>, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<U>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_map_idx_1<T, U>[recursive?](l, bidx, f);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_map_idx_2<T, U>[recursive?](l, bidx, f);
        }
        else {
            return ListFlatOps::s_map_idx_3<T, U>[recursive?](l, bidx, f);
        }
    }

    ////
    //s_filter
    recursive? function s_filter_1<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(p[recursive?](ListFlatOps::s_1at0<T>(l))) {
            return l;
        }
        else {
            return List<T>@{};
        }
    }
    recursive? function s_filter_2<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        let at0 = ListFlatOps::s_2at0<T>(l);
        let pat0 = p[recursive?](at0);
        let at1 = ListFlatOps::s_2at1<T>(l);
        let pat1 = p[recursive?](at1);

        if(ListOps::s_and2(pat0, pat1)) {
            return l;
        }
        elif(pat0) {
            return List<T>@{at0};
        }
        elif(pat1) {
            return List<T>@{at1};
        }
        else {
            return List<T>@{};
        }
    }
    recursive? function s_filter_3<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        let at0 = ListFlatOps::s_3at0<T>(l);
        let pat0 = p[recursive?](at0);
        let at1 = ListFlatOps::s_3at1<T>(l);
        let pat1 = p[recursive?](at1);
        let at2 = ListFlatOps::s_3at2<T>(l);
        let pat2 = p[recursive?](at2);

        if(ListOps::s_and3(pat0, pat1, pat2)) {
            return l;
        }
        elif(ListOps::s_and2(pat0, pat1)) {
            return List<T>@{at0, at1};
        }
        elif(ListOps::s_and2(pat0, pat2)) {
            return List<T>@{at0, at2};
        }
        elif(ListOps::s_and2(pat1, pat2)) {
            return List<T>@{at1, at2};
        }
        elif(pat0) {
            return List<T>@{at0};
        }
        elif(pat1) {
            return List<T>@{at1};
        }
        elif(pat2) {
            return List<T>@{at2};
        }
        else {
            return List<T>@{};
        }
    }
    recursive? function s_filter<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_filter_1<T>[recursive?](l, p);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_filter_2<T>[recursive?](l, p);
        }
        else {
            return ListFlatOps::s_filter_3<T>[recursive?](l, p);
        }
    }

    ////
    //s_filter_idx
    recursive? function s_filter_idx_1<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(p[recursive?](ListFlatOps::s_1at0<T>(l), bidx)) {
            return l;
        }
        else {
            return List<T>@{};
        }
    }
    recursive? function s_filter_idx_2<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let at0 = ListFlatOps::s_2at0<T>(l);
        let pat0 = p[recursive?](at0, bidx);
        let at1 = ListFlatOps::s_2at1<T>(l);
        let pat1 = p[recursive?](at1, bidx + 1n);

        if(ListOps::s_and2(pat0, pat1)) {
            return l;
        }
        elif(pat0) {
            return List<T>@{at0};
        }
        elif(pat1) {
            return List<T>@{at1};
        }
        else {
            return List<T>@{};
        }
    }
    recursive? function s_filter_idx_3<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let at0 = ListFlatOps::s_3at0<T>(l);
        let pat0 = p[recursive?](at0, bidx);
        let at1 = ListFlatOps::s_3at1<T>(l);
        let pat1 = p[recursive?](at1, bidx + 1n);
        let at2 = ListFlatOps::s_3at2<T>(l);
        let pat2 = p[recursive?](at2, bidx + 2n);

        if(ListOps::s_and3(pat0, pat1, pat2)) {
            return l;
        }
        elif(ListOps::s_and2(pat0, pat1)) {
            return List<T>@{at0, at1};
        }
        elif(ListOps::s_and2(pat0, pat2)) {
            return List<T>@{at0, at2};
        }
        elif(ListOps::s_and2(pat1, pat2)) {
            return List<T>@{at1, at2};
        }
        elif(pat0) {
            return List<T>@{at0};
        }
        elif(pat1) {
            return List<T>@{at1};
        }
        elif(pat2) {
            return List<T>@{at2};
        }
        else {
            return List<T>@{};
        }
    }
    recursive? function s_filter_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_filter_idx_1<T>[recursive?](l, bidx, p);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_filter_idx_2<T>[recursive?](l, bidx, p);
        }
        else {
            return ListFlatOps::s_filter_idx_3<T>[recursive?](l, bidx, p);
        }
    }

    ////
    //s_min_arg
    recursive? function s_min_arg_1<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] {
        let at0 = ListFlatOps::s_1at0<T>(l);
        return [bidx, at0];
    }
    recursive? function s_min_arg_2<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] {
        let at0 = f[recursive?](ListFlatOps::s_2at0<T>(l));
        let at1 = f[recursive?](ListFlatOps::s_2at1<T>(l));

        if(at1 < at0) {
            return [bidx + 1n, at1];
        } 
        else {
            return [bidx, at0];
        }
    }
    recursive? function s_min_arg_3<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] {
        let at0 = f[recursive?](ListFlatOps::s_3at0<T>(l));
        let at1 = f[recursive?](ListFlatOps::s_3at1<T>(l));
        let at2 = f[recursive?](ListFlatOps::s_3at2<T>(l));

        if(ListOps::s_and2(at2 < at0, at2 < at1)) {
            return [bidx + 2n, at2];
        } 
        elif(at1 < at0) {
            return [bidx + 1n, at1];
        } 
        else {
            return [bidx, at0];
        }
    }
    recursive? function s_min_arg<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] {
        if(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_min_arg1<T, U>[recursive?](l, bidx, f);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_min_arg2<T, U>[recursive?](l, bidx, f);
        }
        else {
            return ListFlatOps::s_min_arg3<T, U>[recursive?](l, bidx, f);
        }
    }

    ////
    //s_max_arg
    recursive? function s_max_arg_1<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): [Nat, U] {
        let at0 = ListFlatOps::s_1at0<T>(l);
        return [bidx, at0];
    }
    recursive? function s_max_arg_2<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): [Nat, U] {
        let at0 = f[recursive?](ListFlatOps::s_2at0<T>(l));
        let at1 = f[recursive?](ListFlatOps::s_2at1<T>(l));

        if(at1 > at0) {
            return [bidx + 1n, at1];
        } 
        else {
            return [bidx, at0];
        }
    }
    recursive? function s_max_arg_3<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): [Nat, U] {
        let at0 = f[recursive?](ListFlatOps::s_3at0<T>(l));
        let at1 = f[recursive?](ListFlatOps::s_3at1<T>(l));
        let at2 = f[recursive?](ListFlatOps::s_3at2<T>(l));

        if(ListOps::s_and2(at2 > at0, at2 > at1)) {
            return [bidx + 2n, at2];
        } 
        elif(at1 > at0) {
            return [bidx + 1n, at1];
        } 
        else {
            return [bidx, at0];
        }
    }
    recursive? function s_max_arg<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): [Nat, U] {
        if(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_max_arg1<T, U>[recursive?](l, bidx, f);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_max_arg2<T, U>[recursive?](l, bidx, f);
        }
        else {
            return ListFlatOps::s_max_arg3<T, U>[recursive?](l, bidx, f);
        }
    }

    ////
    //s_sum
    function s_sum_1<T unique Algebraic>(l: List<T>): T {
        return ListFlatOps::s_1at0<T>(l);
    }
    function s_sum_2<T unique Algebraic>(l: List<T>): T {
        return ListFlatOps::s_2at0<T>(l) + ListFlatOps::s_2at1<T>(l);
    }
    function s_sum_3<T unique Algebraic>(l: List<T>): T {
        return ListFlatOps::s_3at0<T>(l) + ListFlatOps::s_3at1<T>(l) + ListFlatOps::s_3at2<T>(l);
    }
    function s_sum<T unique Algebraic>(l: List<T>): T {
        if(ListFlatOps::s_empty<T>(l)) {
            return T::zero;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_sum_1<T>(l);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_sum_2<T>(l);
        }
        else {
            return ListFlatOps::s_sum_3<T>(l);
        }
    }

    ////
    //s_zip_index
    function s_zip_index_1<T>(l: List<T>, bidx: Nat): List<[Nat, T]> {
        return List<[Nat, T]>@{[bidx, ListFlatOps::s_1at0<T>(l)]};
    }
    function s_zip_index_2<T>(l: List<T>, bidx: Nat): List<[Nat, T]> {
        return List<[Nat, T]>@{[bidx, ListFlatOps::s_2at0<T>(l)], [bidx + 1n, ListFlatOps::s_2at1<T>(l)]};
    }
    function s_zip_index_3<T>(l: List<T>, bidx: Nat): List<[Nat, T]> {
        return List<[Nat, T]>@{[bidx, ListFlatOps::s_3at0<T>(l)], [bidx + 1, ListFlatOps::s_3at1<T>(l)], [bidx + 2, ListFlatOps::s_3at2<T>(l)]};
    }
    function s_zip_index<T>(l: List<T>, bidx: Nat): List<[Nat, T]> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<[Nat, T]>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_zip_index_1<T>(l, bidx);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_zip_index_2<T>(l, bidx);
        }
        else {
            return ListFlatOps::s_zip_index_3<T>(l, bidx);
        }
    }

    ////
    //s_join_item
    recursive? function s_join_item_1<T, U>(v: T, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        let at0 = ListFlatOps::s_1at0<U>(ol);
        let pat0 = p[recursive?](v, at0);

        if(pat0) {
            return List<[T, U]>@{[v, at0]};    
        }
        else {
            return List<[T, U]>@{};
        }
    }
    recursive? function s_join_item_2<T, U>(v: T, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        let at0 = ListFlatOps::s_2at0<U>(ol);
        let pat0 = p[recursive?](v, at0);
        let at1 = ListFlatOps::s_2at1<U>(ol);
        let pat1 = p[recursive?](v, at1);

        if(ListOps::s_and2(pat0, pat1)) {
            return List<[T, U]>@{[v, at0], [v, at1]};    
        }
        elif(pat0) {
            return List<[T, U]>@{[v, at0]};    
        }
        elif(pat1) {
            return List<[T, U]>@{[v, at1]};    
        }
        else {
            return List<[T, U]>@{};
        }
    }
    recursive? function s_join_item_3<T, U>(v: T, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        let at0 = ListFlatOps::s_3at0<U>(ol);
        let pat0 = p[recursive?](v, at0);
        let at1 = ListFlatOps::s_3at1<U>(ol);
        let pat1 = p[recursive?](v, at1);
        let at2 = ListFlatOps::s_3at2<U>(ol);
        let pat2 = p[recursive?](v, at2);

        if(ListOps::s_and3(pat0, pat1, pat2)) {
            return List<[T, U]>@{[v, at0], [v, at1], [v, at2]};
        }
        elif(ListOps::s_and2(pat0, pat1)) {
            return List<[T, U]>@{[v, at0], [v, at1]};
        }
        elif(ListOps::s_and2(pat0, pat2)) {
            return List<[T, U]>@{[v, at0], [v, at2]};
        }
        elif(ListOps::s_and2(pat1, pat2)) {
            return List<[T, U]>@{[v, at1], [v, at2]};
        }
        elif(pat0) {
            return List<[T, U]>@{[v, at0]};
        }
        elif(pat1) {
            return List<[T, U]>@{[v, at1]};
        }
        elif(pat2) {
            return List<[T, U]>@{[v, at2]};
        }
        else {
            return List<U>@{};
        }
    }
    recursive? function s_join_item<T, U>(v: T, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        if(ListFlatOps::s_empty<U>(ol)) {
            return List<[T, U]>@{};
        }
        elif(ListFlatOps::s_is1<T>(ol)) {
            return ListFlatOps::s_join_item_1<T, U>[recursive?](v, ol, p);
        }
        elif(ListFlatOps::s_is2<T>(ol)) {
            return ListFlatOps::s_join_item_2<T, U>[recursive?](v, ol, p);
        }
        else {
            return ListFlatOps::s_join_item_3<T, U>[recursive?](v, ol, p);   
        }
    }

    ////
    //s_join
    recursive? function s_join_1<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        return ListFlatOps::s_join_item<T, U>[recursive?](ListFlatOps::s_1at0<T>(l), ol, p);
    }
    recursive? function s_join_2<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        let l0 = ListFlatOps::s_join_item<T, U>[recursive?](ListFlatOps::s_2at0<T>(l), ol, p);
        let l1 = ListFlatOps::s_join_item<T, U>[recursive?](ListFlatOps::s_2at1<T>(l), ol, p);

        return ListConcatOps::s_concat2<[T, U]>(l0, l1);
    }
    recursive? function s_join_3<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        let l0 = ListFlatOps::s_join_item<T, U>[recursive?](ListFlatOps::s_3at0<T>(l), ol, p);
        let l1 = ListFlatOps::s_join_item<T, U>[recursive?](ListFlatOps::s_3at1<T>(l), ol, p);
        let l2 = ListFlatOps::s_join_item<T, U>[recursive?](ListFlatOps::s_3at2<T>(l), ol, p);

        return ListConcatOps::s_concat2<[T, U]>(ListConcatOps::s_concat2<[T, U]>(l0, l1), l2);
    }
    recursive? function s_join<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<[T, U]>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_join_1<T, U>[recursive?](l, ol, p);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_join_2<T, U>[recursive?](l, ol, p);
        }
        else {
            return ListFlatOps::s_join_3<T, U>[recursive?](l, ol, p);   
        }
    }

    ////
    //s_small_unique
    recursive? function s_small_unique_1<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        return l;
    }
    recursive? function s_small_unique_2<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        let at0 = ListFlatOps::s_2at0<T>(l);
        let at1 = ListFlatOps::s_2at1<T>(l);
        if(!eq[recursive](at0.0, at1.0)) {
            return l;
        }
        else {
            return List<T>@{at0};
        }
    }
    recursive? function s_small_unique_3<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        let at0 = ListFlatOps::s_3at0<T>(l);
        let at1 = ListFlatOps::s_3at1<T>(l);
        let at2 = ListFlatOps::s_3at2<T>(l);

        let eq01 = !eq[recursive](at0.0, at1.0);
        let eq02 = !eq[recursive](at0.0, at1.2);
        let eq12 = !eq[recursive](at0.1, at1.2);

        if(ListOps::s_and3(!eq01, !eq02, !eq12)) {
            return l;
        }
        elif(ListOps::s_and2(!eq01, ListOps::s_or2(eq02, eq12))) {
            return List<T>@{at0, at1};
        }
        elif(ListOps::s_and2(eq01, !eq02)) {
            return List<T>@{at0, at2};
        }
        else {
            return List<T>@{at0};
        }
    }
    recursive? function s_small_unique<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_small_unique_1<T>[recursive?](l, eq);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_small_unique_2<T>[recursive?](l, eq);
        }
        else {
            return ListFlatOps::s_small_unique_3<T>[recursive?](l, eq);
        }
    }

    ////
    //s_small_key_unique
    function s_small_key_unique_1<T grounded KeyType>(l: List<T>): List<T> {
        return l;
    }
    function s_small_key_unique_2<T grounded KeyType>(l: List<T>): List<T> {
        let at0 = ListFlatOps::s_2at0<T>(l);
        let at1 = ListFlatOps::s_2at1<T>(l);
        if(!KeyType::equal<T>(at0, at1)) {
            return l;
        }
        else {
            return List<T>@{at0};
        }
    }
    function s_small_key_unique_3<T grounded KeyType>(l: List<T>): List<T> {
        let at0 = ListFlatOps::s_3at0<T>(l);
        let at1 = ListFlatOps::s_3at1<T>(l);
        let at2 = ListFlatOps::s_3at2<T>(l);

        let eq01 = !KeyType::equal<T>(at0, at1);
        let eq02 = !KeyType::equal<T>(at0, at2);
        let eq12 = !KeyType::equal<T>(at1, at2);

        if(ListOps::s_and3(!eq01, !eq02, !eq12)) {
            return l;
        }
        elif(ListOps::s_and2(!eq01, ListOps::s_or2(eq02, eq12))) {
            return List<T>@{at0, at1};
        }
        elif(ListOps::s_and2(eq01, !eq02)) {
            return List<T>@{at0, at2};
        }
        else {
            return List<T>@{at0};
        }
    }
    function s_small_key_unique<T grounded KeyType>(l: List<T>): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_small_key_unique_1<T>(l, eq);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_small_key_unique_2<T>(l, eq);
        }
        else {
            return ListFlatOps::s_small_key_unique_3<T>(l, eq);
        }
    }

    ////
    //s_small_isunique
    function s_small_isunique_1<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): Bool {
        return true;
    }
    recursive? function s_small_isunique_2<K grounded KeyType, V>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): Bool {
        let at0 = ListFlatOps::s_2at0<T>(l);
        let at1 = ListFlatOps::s_2at1<T>(l);
        return !eq[recursive](at0.0, at1.0);
    }
    recursive? function s_small_isunique_3<K grounded KeyType, V>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): Bool {
        let at0 = ListFlatOps::s_3at0<T>(l);
        let at1 = ListFlatOps::s_3at1<T>(l);
        let at2 = ListFlatOps::s_3at1<T>(l);

        let eq01 = !eq[recursive](at0.0, at1.0);
        let eq02 = !eq[recursive](at0.0, at1.2);
        let eq12 = !eq[recursive](at0.1, at1.2);

        return ListOps::s_and3(!eq01, !eq02, !eq12);
    }
    recursive? function s_small_isunique<K grounded KeyType, V>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): Bool {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_small_isunique_1<T>[recursive?](l, eq);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_small_isunique_2<T>[recursive?](l, eq);
        }
        else {
            return ListFlatOps::s_small_isunique_3<T>[recursive?](l, eq);
        }
    }

    ////
    //s_small_chk_kv_unique
    function s_small_chk_kv_unique_1<K grounded KeyType, V>(l: List<T>): Bool {
        return true;
    }
    recursive? function s_small_chk_kv_unique_2<K grounded KeyType, V>(l: List<T>): Bool {
        let at0 = ListFlatOps::s_2at0<T>(l);
        let at1 = ListFlatOps::s_2at1<T>(l);
        return !KeyType::equal<K>(at0.0, at1.0);
    }
    recursive? function s_small_chk_kv_unique_3<K grounded KeyType, V>(l: List<T>): Bool {
        let at0 = ListFlatOps::s_3at0<T>(l);
        let at1 = ListFlatOps::s_3at1<T>(l);
        let at2 = ListFlatOps::s_3at1<T>(l);

       return ListOps::s_and3(!KeyType::equal<K>(at0.0, at1.0), !KeyType::equal<K>(at0.0, at2.0), !KeyType::equal<K>(at1.0, at2.0));
    }
    recursive? function s_small_chk_kv_unique<K grounded KeyType, V>(l: List<T>): Bool {
        if(ListFlatOps::s_empty<T>(l)) {
            return true;
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_small_chk_kv_unique_1<T>[recursive?](l, cmp);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_small_chk_kv_unique_2<T>[recursive?](l, cmp);
        }
        else {
            return ListFlatOps::s_small_chk_kv_unique_3<T>[recursive?](l, cmp);
        }
    }

    ////
    //s_small_sort
    recursive? function s_small_sort_1<T unique Orderable>(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        return l;
    }
    recursive? function s_small_sort_2<T unique Orderable>(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        let at0 = ListFlatOps::s_2at0<T>(l);
        let at1 = ListFlatOps::s_2at1<T>(l);
        if(!cmp(at1, at0)) {
            return l;
        }
        else {
            return List<T>@{at1, at0};
        }
    }
    recursive? function s_small_sort_3<T unique Orderable>(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        let at0 = ListFlatOps::s_3at0<T>(l);
        let at1 = ListFlatOps::s_3at1<T>(l);
        let at2 = ListFlatOps::s_3at1<T>(l);

        let l10 = cmp(at1, at0);
        let l20 = cmp(at2, at0);
        let l21 = cmp(at2, at1);

        if(ListOps::s_and2(l20, l21)) {
            if(l10) {
                return List<T>@{at2, at1, at0};
            }
            else {
                return List<T>@{at2, at0, at1};
            }
        }
        elif(ListOps::s_and2(l10, !l21)) {
            if(l20) {
                return List<T>@{at1, at2, at0};
            }
            else {
                return List<T>@{at1, at0, at2};
            }
        }
        else {
            if(l21) {
                return List<T>@{at0, at2, at1};
            }
            else {
                return List<T>@{at0, at1, at2};
            }
        }
    }
    recursive? function s_small_sort<T unique Orderable>(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListFlatOps::s_is1<T>(l)) {
            return ListFlatOps::s_small_sort_1<T>[recursive?](l, cmp);
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return ListFlatOps::s_small_sort_2<T>[recursive?](l, cmp);
        }
        else {
            return ListFlatOps::s_small_sort_3<T>[recursive?](l, cmp);
        }
    }

    ////
    //s_small_range_int
    function s_small_range_int(start: Int, end: Int): List<Int> {
        let count = end - start;
        if(count == 0i) {
            return List<Int>@{};
        }
        elif(count == 1i) {
            return List<Int>@{start};
        }
        elif(count == 2i) {
            return List<Int>@{start, start + 1i};
        }
        else {
            return List<Int>@{start, start + 1i, start + 2i};
        }
    }
    
    ////
    //s_small_range_nat
    function s_small_range_nat(start: Nat, end: Nat): List<Nat> {
        let count = end - start;
        if(count == 0n) {
            return List<Nat>@{};
        }
        elif(count == 1n) {
            return List<Nat>@{start};
        }
        elif(count == 2n) {
            return List<Nat>@{start, start + 1n};
        }
        else {
            return List<Nat>@{start, start + 1n, start + 2n};
        }
    }

    ////
    //s_small_fill
    function s_small_fill<T>(k: Nat, val: T): List<T> {
        if(k == 0n) {
            return List<T>@{};
        }
        elif(k == 1n) {
            return List<T>@{val};
        }
        elif(k == 2n) {
            return List<T>@{val, val};
        }
        else {
            return List<T>@{val, val, val};
        }
    }

    ////
    //s_small_reverse
    function s_small_reverse<T>(l: List<T>): List<T> {
        if(ListOps::s_or2(ListFlatOps::s_empty<T>(l), ListFlatOps::s_is1<T>(l))) {
            return l;
        }
        elif(ListFlatOps::s_is2<T>(l)) {
            return List<T>@{ListFlatOps::s_2at1<T>(l), ListFlatOps::s_2at0<T>(l)};
        }
        elif(ListFlatOps::s_is3<T>(l)) {
            return List<T>@{ListFlatOps::s_3at2<T>(l), ListFlatOps::s_3at1<T>(l), ListFlatOps::s_3at0<T>(l)};
        }
        else {
            return List<T>@{ListFlatOps::s_4at3<T>(l), ListFlatOps::s_4at2<T>(l), ListFlatOps::s_4at1<T>(l), ListFlatOps::s_4at0<T>(l)};
        }
    }

    ////
    //s_small_zip
    function s_small_zip<T, U>(l1: List<T>, l2: List<U>, size: Nat): List<[T, U]> {
        if(ListFlatOps::s_empty<T>(l1)) {
            return List<[T, U]>@{};
        }
        elif(ListFlatOps::s_is1<T>(l1)) {
            return List<[T, U]>@{[ListFlatOps::s_1at0<T>(l1), ListFlatOps::s_1at0<T>(l2)]};
        }
        elif(ListFlatOps::s_is2<T>(l1)) {
            return List<[T, U]>@{[ListFlatOps::s_2at0<T>(l1), ListFlatOps::s_2at0<T>(l2)], [ListFlatOps::s_2at1<T>(l1), ListFlatOps::s_2at1<T>(l2)]};
        }
        elif(ListFlatOps::s_is3<T>(l1)) {
            return List<[T, U]>@{[ListFlatOps::s_3at0<T>(l1), ListFlatOps::s_3at0<T>(l2)], [ListFlatOps::s_3at1<T>(l1), ListFlatOps::s_3at1<T>(l2)], [ListFlatOps::s_3at2<T>(l1), ListFlatOps::s_3at2<T>(l2)]};
        }
        else {
            return List<[T, U]>@{[ListFlatOps::s_4at0<T>(l1), ListFlatOps::s_4at0<T>(l2)], [ListFlatOps::s_4at1<T>(l1), ListFlatOps::s_4at1<T>(l2)], [ListFlatOps::s_4at2<T>(l1), ListFlatOps::s_4at2<T>(l2)], [ListFlatOps::s_4at3<T>(l1), ListFlatOps::s_4at3<T>(l2)]};
        }
    }
}

__internal entity ListConcatOps provides Some {
    __safe function s_left<T>(l: List<T>): List<T> # concat_list_left
    __safe function s_right<T>(l: List<T>): List<T> # concat_list_right

    __safe function s_isConcatList<T>(l: List<T>): Bool # list_isconcat

    recursive function s_concat_lropt_at<T>(l: List<T>, i: Nat): T {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_at<T>(l, i);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_at<T>[recursive](l, i);
        }
        else {
            return ListOps::s_safe_get_impl<T>(l, i);
        }
    }

    recursive function s_at<T>(l: List<T>, i: Nat): T {
        let ll = ListConcatOps::s_left<T>(l);
        let count = ListOps::s_size<T>(ll);

        if(i < count) {
            return ListConcatOps::s_concat_lropt_at<T>[recursive](ll, i);
        }
        else {
            let rl = ListConcatOps::s_right<T>(l);
            let ri = i - count;

            return ListConcatOps::s_concat_lropt_at<T>[recursive](rl, ri);
        }
    }

    recursive function s_concat_lropt_slice_front<T>(l: List<T>, start: Nat): List<T> {
        if(start == 0n) {
            return l;
        }
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_slice_front<T>(l, start);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_slice_front<T>[recursive](l, start);
        }
        else {
            let end = ListOps::s_size<T>(l);
            let count = end - start;
            return ListOps::s_slice_impl<T>(l, start, end, count);
        }
    }

    recursive function s_slice_front<T>(l: List<T>, start: Nat): List<T> {
        let ll = ListConcatOps::s_left<T>(l);
        let lr = ListConcatOps::s_right<T>(l);

        let llsize = ListOps::s_size<T>(ll);
        if(start < llsize) {
            let nl = ListConcatOps::s_concat_lropt_slice_front<T>[recursive](ll, start);
            return ListOps::s_concat2<T>(nl, lr);
        }
        else {
            return ListConcatOps::s_concat_lropt_slice_front<T>[recursive](lr, start - llsize);
        }
    }

    recursive function s_concat_lropt_slice_back<T>(l: List<T>, end: Nat): List<T> {
        if(end == ListOps::s_size<T>(l)) {
            return l;
        }
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_slice_back<T>(l, end);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_slice_back<T>[recursive](l, end);
        }
        else {
            return ListOps::s_slice_impl<T>(l, 0, end, end);
        }
    }

    recursive function s_slice_back<T>(l: List<T>, end: Nat): List<T> {
        let ll = ListConcatOps::s_left<T>(l);
        let lr = ListConcatOps::s_right<T>(l);

        let llsize = ListOps::s_size<T>(ll);
        if(end < llsize) {
            return ListConcatOps::s_concat_lropt_slice_back<T>[recursive](ll, end);
        }
        else {
            let nr = ListConcatOps::s_concat_lropt_slice_back<T>[recursive](lr, end - llsize);
            return ListOps::s_concat2<T>(ll, nr);
        }
    }

    recursive function s_concat_lropt_has_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_has_pred<T>(l, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_has_pred<T>[recursive](l, p);
        }
        else {
            return ListOps::s_has_pred_base<T>(l, p);
        }
    }

    recursive function s_has_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return ListOps::s_or2(
            ListConcatOps::s_concat_lropt_has_pred<T>[recursive](ListConcatOps::s_left<T>(l), p),
            ListConcatOps::s_concat_lropt_has_pred<T>[recursive](ListConcatOps::s_right<T>(l), p)
        );
    }

    recursive function s_concat_lropt_has_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_has_pred_idx<T>(l, bidx, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_has_pred_idx<T>[recursive](l, bidx, p);
        }
        else {
            return ListOps::s_has_pred_idx_base<T>(l, bidx, p);
        }
    }

    recursive function s_has_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return ListOps::s_or2(
            ListConcatOps::s_concat_lropt_has_pred_idx<T>[recursive](ListConcatOps::s_left<T>(l), bidx, p),
            ListConcatOps::s_concat_lropt_has_pred_idx<T>[recursive](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListConcatOps::s_left<T>(l)), p)
        );
    }

    recursive function s_concat_lropt_find_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_pred<T>[recursive?](l, bidx, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_pred<T>[recursive](l, bidx, p);
        }
        else {
            return ListOps::s_find_pred_base<T>[recursive?](l, bidx, p);
        }
    }

    recursive function s_find_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let ff = ListConcatOps::s_concat_lropt_find_pred<T>[recursive](ListConcatOps::s_left<T>(l), bidx, p);
        if(ff !== none) {
            return ff;
        }
        else {
            return ListFlatOps::s_concat_lropt_find_pred<T>[recursive](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListConcatOps::s_left<T>(l)), p);
        }
    }

    recursive function s_concat_lropt_find_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_index_idx<T>[recursive?](l, bidx, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_index_idx<T>[recursive](l, bidx, p);
        }
        else {
            return ListOps::s_find_pred_idx_base<T>[recursive?](l, bidx, p);
        }
    }

    recursive function s_find_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let ff = ListConcatOps::s_concat_lropt_find_pred_idx<T>[recursive](ListConcatOps::s_left<T>(l), bidx, p);
        if(ff !== none) {
            return ff;
        }
        else {
            return ListFlatOps::s_concat_lropt_find_pred_idx<T>[recursive](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListConcatOps::s_left<T>(l)), p);
        }
    }

    recursive function s_concat_lropt_find_last_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_last_pred<T>[recursive?](l, bidx, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_last_pred<T>[recursive](l, bidx, p);
        }
        else {
            return ListOps::s_find_last_pred_base<T>[recursive?](l, bidx, p);
        }
    }

    recursive function s_find_last_pred<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let ll = ListConcatOps::s_concat_lropt_find_last_pred<T>[recursive?](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListConcatOps::s_left<T>(l)), p);
        if(ll !== none) {
            return ll;
        }
        else {
            return ListFlatOps::s_concat_lropt_find_last_pred<T>[recursive?](ListConcatOps::s_left<T>(l), bidx, p);
        }
    }

    recursive function s_concat_lropt_find_last_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_last_ipred_idx<T>[recursive?](l, bidx, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_last_pred_idx<T>[recursive](l, bidx, p);
        }
        else {
            return ListOps::s_find_last_pred_idx_base<T>[recursive?](l, bidx, p);
        }
    }

    recursive function s_find_last_pred_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let ll = ListConcatOps::s_concat_lropt_find_last_pred_idx<T>[recursive?](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ListConcatOps::s_left<T>(l)), p);
        if(ll !== none) {
            return ll;
        }
        else {
            return ListFlatOps::s_concat_lropt_find_last_pred_idx<T>[recursive?](ListConcatOps::s_left<T>(l), bidx, p);
        }
    }

    recursive function s_concat_lropt_map<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_map<T, U>[recursive?](l, f);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_map<T, U>[recursive](l, f);
        }
        else {
            return ListOps::s_map_base<T, U>[recursive?](l, f);
        }
    }

    recursive function s_map<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        let llm = ListConcatOps::s_concat_lropt_map<T, U>[recursive](ListConcatOps::s_left<T>(l), f);
        let rlm = ListConcatOps::s_concat_lropt_map<T, U>[recursive](ListConcatOps::s_right<T>(l), f);

        return ListOps::s_concat2<U>(llm, rlm);
    }

    recursive function s_concat_lropt_map_idx<T, U>(l: List<T>, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_map_idx<T, U>[recursive?](l, bidx, f);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_map_idx<T, U>[recursive](l, bidx, f);
        }
        else {
            return ListOps::s_map_idx_base<T, U>[recursive?](l, bidx, f);
        }
    }

    recursive function s_map_idx<T, U>(l: List<T>, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        let ll = ListConcatOps::s_left<T>(l);
        let llm = ListConcatOps::s_concat_lropt_map_idx<T, U>[recursive](ll, bidx, f);
        let rlm = ListConcatOps::s_concat_lropt_map_idx<T, U>[recursive](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ll), f);

        return ListOps::s_concat2<U>(llm, rlm);
    }

    recursive function s_concat_lropt_filter<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_filter<T>[recursive?](l, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_filter<T>[recursive](l, p);
        }
        else {
            return ListOps::s_filter_base<T>[recursive?](l, p);
        }
    }

    recursive function s_filter<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        let llm = ListConcatOps::s_concat_lropt_filter<T>[recursive](ListConcatOps::s_left<T>(l), p);
        let rlm = ListConcatOps::s_concat_lropt_filter<T>[recursive](ListConcatOps::s_right<T>(l), p);

        return ListOps::s_concat2<T>(llm, rlm);
    }

    recursive function s_concat_lropt_filter_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_filter_idx<T>[recursive?](l, bidx, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_filter_idx<T>[recursive](l, bidx, p);
        }
        else {
            return ListOps::s_filter_idx_base<T>[recursive?](l, bidx, p);
        }
    }

    recursive function s_filter_idx<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let ll = ListConcatOps::s_left<T>(l);
        let llm = ListConcatOps::s_concat_lropt_filter_idx<T>[recursive](ll, bidx, p);
        let rlm = ListConcatOps::s_concat_lropt_filter_idx<T>[recursive](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ll), p);

        return ListOps::s_concat2<T>(llm, rlm);
    }

    recursive function s_concat_lropt_min_arg<T unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_min_arg<T>[recursive?](l, bidx, f);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_min_arg<T>[recursive](l, bidx, f);
        }
        else {
            return ListOps::s_min_arg_base<T>[recursive?](l, bidx, f);
        }
    }

    recursive function s_min_arg<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] {
        let ll = ListConcatOps::s_left<T>(l);
        let llm = ListConcatOps::s_concat_lropt_min_arg_idx<T>[recursive](ll, bidx, f);
        let rlm = ListConcatOps::s_concat_lropt_min_arg_idx<T>[recursive](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size(ll), f);

        if(rlm.1 < llm.1) {
            return rlm;
        }
        else {
            return llm;
        }
    }

    recursive function s_concat_lropt_max_arg<T unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_max_arg<T>[recursive?](l, bidx, f);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_max_arg<T>[recursive](l, bidx, f);
        }
        else {
            return ListOps::s_max_arg_base<T>[recursive?](l, bidx, f);
        }
    }

    recursive function s_max_arg_idx<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] {
        let ll = ListConcatOps::s_left<T>(l);
        let llm = ListConcatOps::s_concat_lropt_max_arg_idx<T>[recursive](ll, bidx, f);
        let rlm = ListConcatOps::s_concat_lropt_max_arg_idx<T>[recursive](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size(ll), f);

        if(rlm.1 > llm.1) {
            return rlm;
        }
        else {
            return llm;
        }
    }

    recursive function s_concat_lropt_sum<T unique Algebraic>(l: List<T>): T {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_sum<T>(l);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_sum<T>[recursive](l);
        }
        else {
            return ListOps::s_sum_base<T>(l);
        }
    }

    recursive function s_sum<T unique Algebraic>(l: List<T>): T {
        let llm = ListConcatOps::s_concat_lropt_sum<T>[recursive](ListConcatOps::s_left<T>(l));
        let rlm = ListConcatOps::s_concat_lropt_sum<T>[recursive](ListConcatOps::s_right<T>(l));

        return llm + rlm;
    }

    recursive function s_concat_lropt_zip_index<T>(l: List<T>, bidx: Nat): List<[Nat, T]> {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_zip_index<T>(l, bidx);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_zip_index<T>[recursive](l, bidx);
        }
        else {
            return ListOps::s_zip_index_base<T>(l, bidx);
        }
    }

    recursive function s_zip_index<T>(l: List<T>, bidx: Nat): List<[Nat, T]> {
        let ll = ListConcatOps::s_left<T>(l);
        let llm = ListConcatOps::s_concat_lropt_zip_index<T>[recursive](ll, bidx);
        let rlm = ListConcatOps::s_concat_lropt_zip_index<T>[recursive](ListConcatOps::s_right<T>(l), bidx + ListOps::s_size<T>(ll));

        return ListOps::s_concat2<T>(llm, rlm);
    }

    recursive function s_concat_lropt_join<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_join<T, U>[recursive?](l, ol, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_join<T, U>[recursive](l, ol, p);
        }
        else {
            return ListOps::s_join_base<T, U>[recursive?](l, ol, p);
        }
    }

    recursive? function s_join<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        let llm = ListConcatOps::s_concat_lropt_join<T>[recursive](ListConcatOps::s_left<T>(l), ol, p);
        let rlm = ListConcatOps::s_concat_lropt_join<T>[recursive](ListConcatOps::s_right<T>(l), ol, p);

        return ListOps::s_concat2<T>(llm, rlm);
    }
    
    //
    //Several functions don't map well in small model mode to appends
    //
    ////////
    //s_sort
    //s_range_int
    //s_range_nat
    //s_fill
    //s_reverse
    //s_zip
    ////////
}

__internal entity ISequence provides Some {
    __safe function s_size(isq: ISequence): Nat # isequence_size
}

__internal entity JSequence provides Some {
    __safe function s_size(jsq: JSequence): Nat # jsequence_size
}

__internal entity SSequence provides Some {
    __safe function s_size(ssq: SSequence): Nat # ssequence_size
}

__internal entity ListOps provides Some {
    ////////////////
    //Called from Lib AND Builtin
    __assume_safe function s_safeAs<T, U>(v: T): U # list_safeas
    __safe function s_or2(b1: Bool, b2: Bool): Bool # list_or2
    __safe function s_or3(b1: Bool, b2: Bool, b3: Bool): Bool # list_or3
    __safe function s_and2(b1: Bool, b2: Bool): Bool # list_and2
    __safe function s_and3(b1: Bool, b2: Bool, b3: Bool): Bool # list_and3

    __safe function s_size<T>(l: List<T>): Nat # list_size

    ////////////////
    //Builtin
    __assume_safe function s_safe_get_impl<T>(l: List<T>, i: Nat): T # list_safe_get

    //Return an error if there is an application of the pred to an element in the list that is an error -- otherwise list value
    recursive? function s_safe_pred_impl<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_safe_check_pred
    recursive? function s_safe_pred_idx_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> # list_safe_check_pred_idx

    //Return an error if there is an application of the function to an element in the list that is an error -- otherwise list value
    recursive? function s_safe_fn_impl<T, U>(l: List<T>, count: Nat, f: recursive? fn(_: T) -> U): List<T> # list_safe_check_fn
    recursive? function s_safe_fn_idx_impl<T, U>(l: List<T>, count: Nat, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<T> # list_safe_check_fn_idx

    recursive? function s_safe_pred_pair_impl<T, U>(l: List<T>, lcount: Nat, ol: List<U>, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): [List<T>, List<U>] # list_safe_check_pred_pair
    recursive? function s_has_pred_pair_impl<T, U>(l: List<T>, lcount: Nat, ol: List<U>, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): Bool # list_has_pred_pair
    
    recursive? function s_has_pred_impl<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): Bool # list_has_pred_check
    recursive? function s_has_pred_idx_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool # list_has_pred_check_idx

    recursive? function s_find_pred_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat # list_find_index_pred
    recursive? function s_find_pred_idx_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat # list_find_index_pred_idx

    recursive? function s_find_last_pred_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat # list_find_last_index_pred
    recursive? function s_find_last_pred_idx_impl<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat # list_find_last_index_pred_idx

    __assume_safe function s_concat2_impl<T>(l1: List<T>, l2: List<T>, count: Nat): List<T> # list_concat2
    __assume_safe function s_slice_impl<T>(l: List<T>, start: Nat, end: Nat, count: Nat): List<T> # list_slice

    __assume_safe function s_range_int_impl(start: Int, end: Int): List<Int> # list_rangeofint
    __assume_safe function s_range_nat_impl(start: Nat, end: Nat): List<Nat> # list_rangeofnat
    __assume_safe function s_fill_impl<T>(k: Nat, val: T): List<T> # list_fill
    __assume_safe function s_reverse_impl(l: List<T>, count: Nat): List<T> # list_reverse

    __assume_safe function s_zip_index_impl<T>(l: List<T>, bidx: Nat, size: Nat): List<[Nat, T]> # list_zipindex
    __assume_safe function s_zip_impl<T, U>(l1: List<T>, l2: List<U>, size: Nat): List<[T, U]> # list_zip

    //assume non-empty, safe, and exists at least one satisfying
    recursive? function s_computeISequence<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): ISequence # list_computeisequence
    recursive? function s_computeISequence_idx<T>(l: List<T>, count: Nat, bidx: Nat, p: recursive? pred(_: T) -> Bool): ISequence # list_computeisequence_idx
    
    //assume non-empty and safe
    recursive? function s_computeJSequence<T, U>(l: List<T>, lcount: Nat, ol: List<U>, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> # list_computejsequence
    recursive? function s_computeSSequence<T>(l: List<T>, count: Nat, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> # list_computessequence

    recursive? function s_map_impl<T, U>(l: List<T>, count: Nat, f: recursive? fn(_: T) -> U): List<U> # list_map
    recursive? function s_map_idx_impl<T, U>(l: List<T>, count: Nat, bidx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> # list_map_idx

    recursive? function s_filter_impl<T>(l: List<T>, isq: ISequence, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_filter
    recursive? function s_filter_idx_impl<T>(l: List<T>, isq: ISequence, count: Nat, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> # list_filter_idx

    recursive? function s_min_arg_impl<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] # list_min_arg
    recursive? function s_max_arg_impl<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): [Nat, U] # list_max_arg

    recursive? function s_join_impl<T, U>(l: List<T>, ol: List<U>, jsq: JSequence, lcount: Nat, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> # list_join
    recursive? function s_sort_impl<T>(l: List<T>, ssq: SSequence, count: Nat, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> # list_sort

    ////////////////
    //Called from lib
    function s_safe_get<T>(l: List<T>, i: Nat): T {
#if SMALL_MODEL_ENABLED
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_at<T>(l, i);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_at<T>[recursive](l, i);
        }
        else {
#endif
            return ListOps::s_safe_get_impl<T>(l, i);
#if SMALL_MODEL_ENABLED
        }
#endif
    }

    recursive? function s_has_pred_base<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        let sl = ListOps::s_safe_pred_impl<T>[recursive?](l, ListOps::s_size<T>(l), p);
        return ListOps::s_has_pred_impl<T>[recursive?](sl, ListOps::s_size<T>(sl), p);
    }

    recursive? function s_has_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListFlatOps::s_empty<T>(l)) {
            return false;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_has_pred<T>[recursive?](l, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_has_pred<T>[recursive](l, p);
        }
#endif
        else {
            return ListOps::s_has_pred_base<T>[recursive?](l, p);
        }
    }

    recursive? function s_has_pred_idx_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let sl = ListOps::s_safe_pred_idx_impl<T>[recursive?](l, ListOps::s_size<T>(l), bidx, p);
        return ListOps::s_has_pred_idx_impl<T>[recursive?](sl, ListOps::s_size<T>(sl), bidx, p);
    }

    recursive? function s_has_pred_idx<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListFlatOps::s_empty<T>(l)) {
            return false;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_has_pred_idx<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_has_pred_idx<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_has_pred_idx_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_find_pred_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let sl = ListOps::s_safe_pred_impl<T>[recursive?](l, ListOps::s_size<T>(l), p);
        let count = ListOps::s_size<T>(sl);

        if(ListOps::s_has_pred_impl<T>[recursive?](sl, count, p)) {
            return ListOps::s_find_pred_impl<T>[recursive?](sl, count, bidx, p);
        }
        else {
            return none;
        }
    }

    recursive? function s_find_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_pred<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_pred<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_find_pred_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_find_pred_idx_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let sl = ListOps::s_safe_pred_idx_impl<T>[recursive?](l, ListOps::s_size<T>(l), bidx, p);
        let count = ListOps::s_size<T>(sl);

        if(ListOps::s_has_pred_idx_impl<T>[recursive?](sl, count, bidx, p)) {
            return ListOps::s_find_pred_idx_impl<T>[recursive?](sl, count, bidx, p);
        }
        else {
            return none;
        }
    }

    recursive? function s_find_pred_idx<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_pred_idx<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_pred_idx<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_find_pred_idx_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_find_last_pred_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let sl = ListOps::s_safe_pred_impl<T>[recursive?](l, ListOps::s_size<T>(l), p);
        let count = ListOps::s_size<T>(sl);

        if(ListOps::s_has_pred_impl<T>[recursive?](sl, count, p)) {
            return ListOps::s_find_last_pred_impl<T>[recursive?](sl, count, bidx, p);
        }
        else {
            return none;
        }
    }

    recursive? function s_find_last_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_last_pred<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_last_pred<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_find_last_pred_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_find_last_pred_idx_base<T>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let sl = ListOps::s_safe_pred_idx_impl<T>[recursive?](l, ListOps::s_size<T>(l), bidx, p);
        let count = ListOps::s_size<T>(sl);

        if(ListOps::s_has_pred_idx_impl<T>[recursive?](sl, count, bidx, p)) {
            return ListOps::s_find_last_pred_idx_impl<T>[recursive?](sl, count, bidx, p);
        }
        else {
            return none;
        }
    }

    recursive? function s_find_last_pred_idx<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListFlatOps::s_empty<T>(l)) {
            return none;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_find_last_pred_idx<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_find_last_pred_idx<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_find_last_pred_idx_base<T>[recursive?](l, 0, p);
        }
    }

    function s_concat2<T>(l1: List<T>, l2: List<T>): List<T> {
        let l1empty = ListFlatOps::s_empty<T>(l1);
        let l2empty = ListFlatOps::s_empty<T>(l2);

        if(ListOps::s_and2(l1empty, l2empty)) {
            return List<T>@{};
        }
        else {
            if(l1empty) {
                return l2;
            }
            elif(l2empty) {
                return l1;
            }
            else {
                let l1size = ListOps::s_size<T>(l1);
                let l2size = ListOps::s_size<T>(l2);
                let ncount = l1size + l2size;

                return ListOps::s_concat2_impl<T>(l1, l2, ncount);
            }
        }
    }

    function s_slice<T>(l: List<T>, start: Nat, end: Nat): List<T> {
        let count = end - start;

        if(count == 0n) {
            return List<T>@{};
        }
        elif (count == ListOps::s_size<T>(l)) {
            return l;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_slice<T>(l, start, end);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            let ff = ListConcatOps::s_slice_front(l, start);
            if(ListFlatOps::s_isFlatList<T>(ff)) {
                return ListFlatOps::s_slice_back<T>(ff, end - start);
            }
            elif(ListConcatOps::s_isConcatList<T>(ff)) {
                return ListConcatOps::s_slice_back<T>(ff, end - start);
            }
            else {
                return ListOps::s_slice_impl<T>(l, 0, end - start, end - start);    
            }
        }
#endif
        else {
            return ListOps::s_slice_impl<T>(l, start, end, count);
        }
    }

    recursive? function s_map_base<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        let sl = ListOps::s_safe_fn_impl<T, U>[recursive?](l, ListOps::s_size<T>(l), f);
        return ListOps::s_map_impl<T, U>[recursive?](sl, ListOps::s_size<T>(sl), f);
    }

    recursive? function s_map<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<U>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_map<T, U>[recursive?](l, f);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_map<T, U>[recursive](l, f);
        }
#endif
        else {
           return ListOps::s_map_base<T, U>[recursive?](l, f);
        }
    }

    recursive? function s_map_idx_base<T, U>(l: List<T>, bidx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let sl = ListOps::s_safe_fn_idx_impl<T, U>[recursive?](l, bidx, f);
        return ListOps::s_map_idx_impl<T, U>[recursive?](sl, ListOps::s_size<T>(sl), bidx, f);
    }

    recursive? function s_map_idx<T, U>(l: List<T>, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<U>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_map_idx<T, U>[recursive?](l, 0, f);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_map_idx<T, U>[recursive](l, 0, f);
        }
#endif
        else {
           return ListOps::s_map_idx_base<T, U>[recursive?](l, 0, f);
        }
    }

    recursive? function s_filter_base<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        let sl = ListOps::s_safe_pred_impl<T>[recursive?](l, ListOps::s_size<T>(l), p);
        let count = ListOps::s_size<T>(sl);

        if(!ListOps::s_has_pred_impl<T>[recursive?](sl, count, p)) {
            return List<T>@{};
        }
        elif(!ListOps::s_has_pred_impl<T>[recursive?](sl, count, recursive? pred(v: T): Bool => !p[recursive?](v))) {
            return sl;
        }
        else {
            let isq = ListOps::s_computeISequence<T>[recursive?](sl, count, p);
            return ListOps::s_filter_impl<T>[recursive?](sl, isq, count, p);
        }
    }

    recursive? function s_filter<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_filter<T>[recursive?](l, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_filter<T>[recursive](l, p);
        }
#endif
        else {
            return ListOps::s_filter_base<T>[recursive?](l, p);
        }
    }

    recursive? function s_filter_idx_base<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let sl = ListOps::s_safe_pred_idx_impl<T>[recursive?](l, ListOps::s_size<T>(l), bidx, p);
        let count = ListOps::s_size<T>(sl);

        if(!ListOps::s_has_pred_idx_impl<T>[recursive?](sl, count, bidx, p)) {
            return List<T>@{};
        }
        elif(!ListOps::s_has_pred_idx_impl<T>[recursive?](sl, count, bidx, recursive? pred(v: T, i: Nat): Bool => !p[recursive?](v, i))) {
            return sl;
        }
        else {
            let isq = ListOps::s_computeISequence_idx<T>[recursive?](sl, count, bidx, p);
            return ListOps::s_filter_idx_impl<T>[recursive?](sl, isq, count, bidx, p);
        }
    }

    recursive? function s_filter_idx<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_filter_idx<T>[recursive?](l, 0, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_filter_idx<T>[recursive](l, 0, p);
        }
#endif
        else {
            return ListOps::s_filter_idx_base<T>[recursive?](l, 0, p);
        }
    }

    recursive? function s_min_arg_base<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): Nat {
        return ListOps::s_min_arg_impl<T>[recursive?](l, bidx, f);
    }

    recursive? function s_min_arg<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): Nat {
#if SMALL_MODEL_ENABLED
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_min_arg<T>[recursive?](l, 0, f).0;
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_min_arg<T>[recursive](l, 0, f).0;
        }
        else {
#endif
            return ListOps::s_min_arg_base<T>[recursive?](l, 0, f).0;
#if SMALL_MODEL_ENABLED
        }
#endif
    }
    
    recursive? function s_max_arg_base<T, U unique Orderable>(l: List<T>, bidx: Nat, f: recursive? fn(_: T) -> U): Nat {
        return ListOps::s_max_arg_impl<T>[recursive?](l, bidx, f);
    }

    recursive? function s_max_arg<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): Nat {
#if SMALL_MODEL_ENABLED
        if(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_max_arg<T>[recursive?](l, 0, f).0;
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_max_arg<T>[recursive](l, 0, f).0;
        }
        else {
#endif
            return ListOps::s_max_arg_base<T>[recursive?](l, 0, f).0;
#if SMALL_MODEL_ENABLED
        }
#endif
    }

#if UF_APPROX
    function s_sum_impl<T unique Algebraic>(l: List<T>): T # list_sum

    function s_sum_base<T unique Algebraic>(l: List<T>): T {
        return ListOps::s_sum_impl<T>(l);
    }

    function s_sum<T unique Algebraic>(l: List<T>): T {
        if(ListFlatOps::s_empty<T>(l)) {
            return T::zero;
        }
        else {
            let count = ListOps::s_size<T>(l);
            
            if(count == 1n) {
                return ListOps::s_safe_get<T>(l, 0n);
            }
            else {
                return ListOps::s_sum_base<T>(l);
            }
        }
    }
#else
    recursive function s_sum_rec<T unique Algebraic>(l: List<T>, acc: T, cpos: Nat, count: Nat): T {
        if(cpos == count) {
            return acc;
        }
        else {
            let nacc = acc + ListOps::s_safe_get<T>(l, cpos);
            return ListOps::s_sum_rec<T>[recursive](l, nacc, cpos + 1n, count);
        }
    }

    function s_sum_base<T unique Algebraic>(l: List<T>): T {
        return ListOps::s_sum_rec<T>[recursive](l, T::zero, 0n, ListOps::s_size<T>(l));
    }

    function s_sum<T unique Algebraic>(l: List<T>): T {
        if(ListFlatOps::s_empty<T>(l)) {
            return T::zero;
        }
        else {
            let count = ListOps::s_size<T>(l);
            
            if(count == 1n) {
                return ListOps::s_safe_get<T>(l, 0n);
            }
#if SMALL_MODEL_ENABLED
            elif(ListFlatOps::s_isFlatList<T>(l)) {
                return ListFlatOps::s_sum<T>(l);
            }
            elif(ListConcatOps::s_isConcatList<T>(l)) {
                return ListConcatOps::s_sum<T>[recursive](l);
            }
#endif
            else {
                return ListOps::s_sum_base<T>(l);
            }
        }
    }
#endif

   
    ////////////////
    //In code support operations
    ////////////////

    recursive? function s_zip_index_base<T>(l: List<T>, bidx: Nat): List<T> {
        return ListOps::s_zip_index_impl<T>(l, bidx, ListOps::s_size<T>(l));
    }

    recursive function s_zip_index<T>(l: List<T>): List<[Nat, T]> {
       if(ListFlatOps::s_empty<T>(l)) {
            return List<[Nat, T]>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_zip_index<T>(l, 0);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_zip_index<T>(l, 0);
        }
#endif
        else {
           return ListOps::s_zip_index_base<T>(l, 0);
        }
    }

    recursive? function s_join_base<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        let llp = ListOps::s_safe_pred_pair_impl<T, U>[recursive?](l, ListOps::s_size<T>(l), ol, ListOps::s_size<T>(ol), p);
        let slcount = ListOps::s_size<T>(llp.0);
        let solcount = ListOps::s_size<U>(llp.1);

        if(!ListOps::s_has_pred_pair_impl<T, U>[recursive?](llp.0, slcount, llp.1, solcount, p)) {
            return List<T>@{};
        }
        else {
            let jsq = ListOps::s_computeJSequence<T, U>[recursive?](llp.0, slcount, llp.1, solcount, p);
            return ListOps::s_join_impl<T, U>[recursive?](llp.0, slcount, jsq, llp.1, solcount, p);
        }
    }

    recursive? function s_join<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
       if(ListFlatOps::s_empty<T>(l)) {
            return List<[T, U]>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_join<T, U>(l, ol, p);
        }
        elif(ListConcatOps::s_isConcatList<T>(l)) {
            return ListConcatOps::s_join<T, U>(l, ol, p);
        }
#endif
        else {
           return ListOps::s_join_base<T, U>(l, ol, p);
        }
    }

    function s_unique<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListOps::s_size<T>(l) == 1) {
            return l;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_small_unique<T>[recursive?](l, eq);
        }
#endif
        else {
            return ListOps::s_filter_idx<T>(l, recursive? pred(v: T, i: Nat): Bool => {
                return !ListOps::s_has_pred_idx<T>(l, recursive? pred(u: T, j: Nat): Bool => {
                    ListOps::s_and2(i != j, eq[recursive?](u, v));
                });
            });
        }
    }

    function s_key_unique<T grounded KeyType>(l: List<K>): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListOps::s_size<T>(l) == 1) {
            return l;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_small_key_unique<T>(l);
        }
#endif
        else {
            return ListOps::s_filter_idx<T>(l, pred(v: T, i: Nat): Bool => {
                return !ListOps::s_has_pred_idx<T>(l, pred(u: T, j: Nat): Bool => {
                    ListOps::s_and2(i != j, KeyType::equal<T>(u, v));
                });
            });
        }
    }

    function s_isunique<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListOps::s_size<T>(l) == 1) {
            return l;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_small_isunique<T>[recursive?](l, eq);
        }
#endif
        else {
            return !ListOps::s_has_pred_idx<T>(l, recursive? pred(v: T, i: Nat): Bool => {
                return ListOps::s_has_pred_idx<T>(l, recursive? pred(u: T, j: Nat): Bool => {
                    ListOps::s_and2(i != j, eq[recursive?](u, v));
                });
            });
        }
    }

    function s_chk_kv_unique<K grounded KeyType, V>(l: List<[K, V]>): Bool {
        if(ListFlatOps::s_empty<[K ,V]>(l)) {
            return true;
        }
        elif(ListOps::s_size<[K, V]>(l) == 1) {
            return true;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<[K, V]>(l)) {
            return ListFlatOps::s_small_chk_kv_unique<K, V>(l);
        }
#endif
        else {
            return !ListOps::s_has_pred_idx<[K, V]>(l, pred(v: [K, V], i: Nat): Bool => {
                return ListOps::s_has_pred_idx<[K, V]>(l, pred(u: [K, V], j: Nat): Bool => {
                    ListOps::s_and2(i != j, KeyType::equal<K>(u.0, v.0));
                });
            });
        }
    }

    function s_sort<T>(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
        elif(ListOps::s_size<T>(l) == 1) {
            return l;
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_small_sort<K, V>[recursive?](l, cmp);
        }
#endif
        else {
            let sl = ListOps::s_safe_pred_pair_impl<T, T>[recursive?](l, ListOps::s_size<T>(l), l, ListOps::s_size<T>(l), cmp).0;
            let count = ListOps::s_size<T>(llp.0);

            let jsq = ListOps::s_computeSSequence<T>[recursive?](sl, count, cmp);
            return ListOps::s_sort_impl<T>[recursive?](sl, count, jsq, cmp);
        }
    }

    function s_range_int(start: Int, end: Int): List<Int> {
        let count = end - start;
        if(count == 0i) {
            return List<Int>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(count <= 3i) {
            return ListFlatOps::s_small_range_int(start, end);
        }
        elif(count <= 6i) {
            let ll = ListFlatOps::s_small_range_int(start, start + (count / 2i));
            let rl = ListFlatOps::s_small_range_int(start + (count / 2i), end);
            return ListConcatOps::s_concat2<Int>(ll, rl);
        }
#endif
        else {
            return ListOps::s_range_int_impl(start, end);
        }
    }

    function s_range_nat(start: Nat, end: Nat): List<Nat> {
        let count = end - start;
        if(count == 0n) {
            return List<Nat>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(count <= 3n) {
            return ListFlatOps::s_small_range_nat(start, end);
        }
        elif(count <= 6n) {
            let ll = ListFlatOps::s_small_range_nat(start, start + (count / 2n));
            let rl = ListFlatOps::s_small_range_nat(start + (count / 2n), end);
            return ListConcatOps::s_concat2<Nat>(ll, rl);
        }
#endif
        else {
            return ListOps::s_range_nat_impl(start, end);
        }
    }

    function s_fill<T>(k: Nat, val: T): List<T> {
        if(k == 0n) {
            return List<T>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(count <= 3n) {
            return ListFlatOps::s_small_fill<T>(k, val);
        }
        elif(count <= 6n) {
            let llct = count / 2n;
            let ll = ListFlatOps::s_small_fill<T>(llct);
            let rl = ListFlatOps::s_small_fill<T>(count - llct);
            return ListConcatOps::s_concat2<T>(ll, rl);
        }
#endif
        else {
            return ListOps::s_fill_impl<T>(k, val);
        }
    }

    function s_reverse<T>(l: List<T>): List<T> {
        if(ListFlatOps::s_empty<T>(l)) {
            return List<T>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(ListFlatOps::s_isFlatList<T>(l)) {
            return ListFlatOps::s_small_reverse<T>(l);
        }
#endif
        else {
            return ListOps::s_reverse_impl<T>(l, ListOps::s_size<T>(l));
        }
    }

    function s_zip_1<T, U>(l1: List<T>, l2: List<U>, size: Nat): List<[T, U]> {
        return List<T>@{[ListOps::s_at<T>(l1, 0n), ListOps::s_at<U>(l2, 0n)]};
    }
    function s_zip_2<T, U>(l1: List<T>, l2: List<U>, size: Nat): List<[T, U]> {
        return List<T>@{[ListOps::s_at<T>(l1, 0n), ListOps::s_at<U>(l2, 0n)], [ListOps::s_at<T>(l1, 1n), ListOps::s_at<U>(l2, 1n)]};
    }
    function s_zip_3<T, U>(l1: List<T>, l2: List<U>, size: Nat): List<[T, U]> {
        return List<T>@{[ListOps::s_at<T>(l1, 0n), ListOps::s_at<U>(l2, 0n)], [ListOps::s_at<T>(l1, 1n), ListOps::s_at<U>(l2, 1n)], [ListOps::s_at<T>(l1, 2n), ListOps::s_at<U>(l2, 2n)]};
    }
    function s_zip<T, U>(l1: List<T>, l2: List<U>, size: Nat): List<[T, U]> {
        if(size == 0n) {
            return List<[T, U]>@{};
        }
#if SMALL_MODEL_ENABLED
        elif(size == 1n) {
            return ListOps::s_zip_1<T, U>(l1, l2, size);
        }
        elif(size == 2n) {
            return ListOps::s_zip_2<T, U>(l1, l2, size);
        }
        elif(size == 3n) {
            return ListOps::s_zip_3<T, U>(l1, l2, size);
        }
#endif
        else {
            return ListOps::s_zip_impl<T>(l1, l2, size);
        }
    }
}

