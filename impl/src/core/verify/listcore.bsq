//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

#if FINITE_IMPL
__internal entity ListOperators provides Object {
    //Core accessors
    __assume_safe s_safeAs<T, U>(v: T): U # list_safeas

    __safe function s_empty<T>(l: List<T>): Bool # list_empty
    
    __safe function s_is1<T>(l: List<T>): Bool # list_is1
    __safe function s_1at_0<T>(l: List<T>): T # list_1at_0

    __safe function s_is2<T>(l: List<T>): Bool # list_is2
    __safe function s_2at_0<T>(l: List<T>): T # list_2at_0
    __safe function s_2at_1<T>(l: List<T>): T # list_2at_1

    __safe function s_is3<T>(l: List<T>): Bool # list_is3
    __safe function s_1at_0<T>(l: List<T>): T # list_3at_0
    __safe function s_2at_1<T>(l: List<T>): T # list_3at_1
    __safe function s_3at_2<T>(l: List<T>): T # list_3at_2

    __safe function s_is3<T>(l: List<T>): Bool # list_is3
    __safe function s_1at_0<T>(l: List<T>): T # list_3at_0
    __safe function s_2at_1<T>(l: List<T>): T # list_3at_1
    __safe function s_3at_2<T>(l: List<T>): T # list_3at_2

    __safe function s_is4<T>(l: List<T>): Bool # list_is4
    __safe function s_4at_0<T>(l: List<T>): T # list_4at_0
    __safe function s_4at_1<T>(l: List<T>): T # list_4at_1
    __safe function s_4at_2<T>(l: List<T>): T # list_4at_2
    __safe function s_4at_3<T>(l: List<T>): T # list_4at_3

    __assume_safe function s_cons<T>(v: T, l: List<T>): List<T> # list_cons
    __assume_safe function s_safe_head<T>(l: List<T>): T # list_head
    __assume_safe function s_safe_tail<T>(l: List<T>): List<T> # list_tail

    function normalize(l: List<T>): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let e0 = ListOperators::s_safe_head<T>(l);
            let l0 = ListOperators::s_safe_tail<T>(l);
            if(ListOperators::s_empty<T>(l0)) {
                return List<T>@{e0};
            }
            else {
                let e1 = ListOperators::s_safe_head<T>(l0);
                let l1 = ListOperators::s_safe_tail<T>(l0);
                if(ListOperators::s_empty<T>(l1)) {
                    return List<T>@{e0, e1};
                }
                else {
                    let e2 = ListOperators::s_safe_head<T>(l1);
                    let l2 = ListOperators::s_safe_tail<T>(l1);
                    if(ListOperators::s_empty<T>(l2)) {
                        return List<T>@{e0, e1, e2};
                    }
                    else {
                        let e3 = ListOperators::s_safe_head<T>(l2);
                        let l3 = ListOperators::s_safe_tail<T>(l2);
                        if(ListOperators::s_empty<T>(l3)) {
                            return List<T>@{e0, e1, e2, e3};
                        }
                        else {
                            return l;
                        }
                    }
                }
            }
        }
    }

    function normalizeIntoLL(l: List<T>): List<T> {
        if(ListOperators::s_is1<T>(l)) {
            return ListOperators::s_cons<T>(ListOperators::s_1at_0<T>(l), List<T>@{});
        }
        elif(ListOperators::s_is2<T>(l)) {
            return ListOperators::s_cons<T>(ListOperators::s_2at_0<T>(l), 
                   ListOperators::s_cons<T>(ListOperators::s_2at_1<T>(l), List<T>@{}));
        }
        elif(ListOperators::s_is3<T>(l)) {
            return ListOperators::s_cons<T>(ListOperators::s_3at_0<T>(l),
                   ListOperators::s_cons<T>(ListOperators::s_3at_1<T>(l), 
                   ListOperators::s_cons<T>(ListOperators::s_3at_2<T>(l), List<T>@{})));
        }
        elif(ListOperators::s_is4<T>(l)) {
            return ListOperators::s_cons<T>(ListOperators::s_4at_0<T>(l),
                   ListOperators::s_cons<T>(ListOperators::s_4at_1<T>(l),
                   ListOperators::s_cons<T>(ListOperators::s_4at_2T>(l), 
                   ListOperators::s_cons<T>(ListOperators::s_4at_3<T>(l), List<T>@{}))));
        }
        else {
            return l;
        }
    }

    recursive function s_size_rec<T>(l: List<T>): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let rest = ListOperators::s_size_rec<T>[recursive](ListOperators::s_safe_tail<T>(l));
            return rest + 1;
        }
    }

    function s_size<T>(l: List<T>): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        elif(ListOperators::s_is1<T>(l)) {
            return 1n;
        }
        elif(ListOperators::s_is2<T>(l)) {
            return 2n;
        }
        elif(ListOperators::s_is3<T>(l)) {
            return 3n;
        }
        elif(ListOperators::s_is4<T>(l)) {
            return 4n;
        }
        else {
            return ListOperators::s_size_rec<T>[recursive](l);
        }
    }

    recursive function s_ints_rec(start: Int, end: Int): List<Int> {
        if(start == end) {
            return List<Int>@{};
        }
        else {
            let rest = ListOperators::s_ints_rec<Int>[recursive](start + 1, end);
            return ListOperators::s_cons<Int>(start, rest);
        }
    }

    recursive function s_ints(start: Int, end: Int): List<Int> {
        let dist = end - start;

        if(dist == 0) {
            return List<T>@{};
        }
        elif(dist == 1) {
            return List<T>@{start};
        }
        elif(dist == 2) {
            return List<T>@{start, start + 1n};
        }
        elif(dist == 3) {
            return List<T>@{start, start + 1n, start + 2n};
        }
        elif(dist == 4) {
            return List<T>@{start, start + 1n, start + 2n, start + 4n};
        }
        else {
            return ListOperators::s_ints_rec<T>[recursive](start, end);
        }
    }

    recursive function s_nats(start: Nat, end: Nat): List<Nat> {
        if(start == end) {
            return List<Nat>@{};
        }
        else {
            let rest = ListOperators::s_nats<Nat>[recursive](start + 1, end);
            return ListOperators::s_cons<Nat>(start, rest);
        }
    }

    recursive function s_index<T>(l: List<T>, curr: Nat): List<[Nat, T]> {
        if(ListOperators::s_empty<T>(l)) {
            return List<[Nat, T]>@{};
        }
        else {
            let rest = ListOperators::s_index<T>[recursive](ListOperators::s_safe_tail<T>(l), curr + 1);
            return ListOperators::s_cons<[Nat, T]>([curr, ListOperators::s_safe_head<T>(l)], rest);
        }
    }

    recursive function s_zip<T, U>(l: List<T>, ol: List<U>): List<[T, U]>  {
        if(ListOperators::s_empty<T>(l)) {
            check ListOperators::s_empty<U>(ol);
            return List<[T, U]>@{};
        }
        elif(ListOperators::s_empty<U>(ol)) {
            check ListOperators::s_empty<T>(l);
            return List<[T, U]>@{};
        }
        else {
            let rest = ListOperators::s_zip<T, U>[recursive](ListOperators::s_safe_tail<T>(l), ListOperators::s_safe_tail<U>(ol));
            return ListOperators::s_cons<[T, U]>([ListOperators::s_safe_head<T>(l), ListOperators::s_safe_head<U>(ol)], rest);
        }
    }

    recursive function fill<T>(k: Nat, val: T): List<T> {
        if(k == 0n) {
            return List<T>@{};
        }
        else {
            let rest = ListOperators::s_fill<T>[recursive](k - 1, val);
            return ListOperators::s_cons<T>(val, rest);
        }
    }

    recursive function s_concat2<T>(l1: List<T>, l2: List<T>): List<T> {
        if(ListOperators::s_empty<T>(l1)) {
            return l2;
        }
        else {
            let rest = ListOperators::s_concat2<T>[recursive](ListOperators::s_safe_tail<T>(l), l2);
            return ListOperators::s_cons<T>(ListOperators::s_safe_head<T>(l), rest);
        }
    }

    recursive function s_lconcat<T>(ll: List<List<T>>): List<T> {
        if(ListOperators::s_empty<List<T>>(ll)) {
            return List<T>@{};
        }
        else if(ListOperators::s_size<List<T>>(ll) == 1) {
            return ListOperators::s_safe_head<List<T>>(ll);
        }
        else {
            let rest = ListOperators::s_lconcat<T>[recursive](ListOperators::s_safe_tail<T>(ll));
            return ListOperators::s_concat2<T>[recursive](ListOperators::s_safe_head<List<T>>(ll), rest);
        }
    }

    recursive function s_back(l: List<T>): T {
        if(ListOperators::s_empty(ListOperators::s_safe_tail<T>(l))) {
            return ListOperators::s_safe_head<T>(l);
        }
        else {
            return ListOperators::s_back<T>[recursive](ListOperators::s_safe_tail<T>(l));
        }
    }

    recursive function s_get<T>(l: List<T>, i: Nat): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        elif(i == 0) {
            return l;
        }
        else {
            let rest = ListOperators::s_safe_tail<T>(l);
            return ListOperators::s_get<T>[recursive](rest, i - 1);
        }
    }

    recursive function s_haspred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            if(p[recursive?](ListOperators::s_safe_head<T>(l))) {
                return true;
            }
            else {
                return ListOperators::s_haspred<T>[recursive](ListOperators::s_safe_tail<T>(l), p);
            }
        }
    }

    recursive function s_haspred_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            if(p[recursive?](ListOperators::s_safe_head<T>(l), idx)) {
                return true;
            }
            else {
                return ListOperators::s_haspred_idx<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
            }
        }
    }

    recursive function s_haselem_none<T>(l: List<T>): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            if(ListOperators::s_safe_head<T>(l) === none) {
                return true;
            }
            else {
                return ListKeyOperators::s_haselem_none<T>[recursive](ListOperators::s_safe_tail<T>(l));
            }
        }
    }

    recursive function s_haselem_nothing<T>(l: List<T>, v: T): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            if(ListOperators::s_safe_head<T>(l) === nothing) {
                return true;
            }
            else {
                return ListKeyOperators::s_haselem_nothing<T>[recursive](ListOperators::s_safe_tail<T>(l), v);
            }
        }
    }

    recursive function s_countelem_none<T>(l: List<T>): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let rest = ListKeyOperators::s_countelem_key<T>[recursive](ListOperators::s_safe_tail<T>(l), v);
            if(ListOperators::s_safe_head<T>(l) === none) {
                return rest + 1;
            }
            else {
                return rest;
            }
        }
    }

    recursive function s_countelem_nothing<T>(l: List<T>): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let rest = ListKeyOperators::s_countelem_key<T>[recursive](ListOperators::s_safe_tail<T>(l), v);
            if(ListOperators::s_safe_head<T>(l) === nothing) {
                return rest + 1;
            }
            else {
                return rest;
            }
        }
    }

    recursive function s_countif<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let rest = ListOperators::s_countif<T>[recursive](ListOperators::s_safe_tail<T>(l), p);
            if(p[recursive?](ListOperators::s_safe_head<T>(l))) {
                return rest + 1n;
            }
            else {
                return rest;
            }
        }
    }

    recursive function s_countif_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let rest = ListOperators::s_countif_idx<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
            if(p[recursive?](ListOperators::s_safe_head<T>(l), idx)) {
                return rest + 1n;
            }
            else {
                return rest;
            }
        }
    }


    recursive function s_takewhile<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            if(!p[recursive?](vv)) {
                return List<T>@{};
            }
            else {
                let rest = ListOperators::s_takewhile<T>[recursive](ListOperators::s_safe_tail<T>(l), p);
                return ListOperators::s_cons<T>(vv, rest);
            }
        }
    }

    recursive function s_takewhile_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            if(!p[recursive?](vv, idx)) {
                return List<T>@{};
            }
            else {
                let rest = ListOperators::s_takewhile_idx<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
                return ListOperators::s_cons<T>(vv, rest);
            }
        }
    }

    recursive function s_takeuntil<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            if(p[recursive?](vv)) {
                return List<T>@{};
            }
            else {
                let rest = ListOperators::s_takeuntil<T>[recursive](ListOperators::s_safe_tail<T>(l), p);
                return ListOperators::s_cons<T>(vv, rest);
            }
        }
    }

    recursive function s_takeuntil_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            if(p[recursive?](vv, idx)) {
                return List<T>@{};
            }
            else {
                let rest = ListOperators::s_takeuntil_idx<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
                return ListOperators::s_cons<T>(vv, rest);
            }
        }
    }

    recursive function s_discardwhile<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            if(p[recursive?](ListOperators::s_safe_head<T>(l))) {
                return ListOperators::s_discarduntil<T>[recursive](ListOperators::s_safe_tail<T>(l), p);
            }
            else {
                return l;
            }
        }
    }

    recursive function s_discardwhile_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            if(p[recursive?](ListOperators::s_safe_head<T>(l), idx)) {
                return ListOperators::s_discarduntil_idx<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
            }
            else {
                return l;
            }
        }
    }

    recursive function s_discarduntil<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            if(p[recursive?](ListOperators::s_safe_head<T>(l))) {
                return l;
            }
            else {
                return ListOperators::s_discarduntil<T>[recursive](ListOperators::s_safe_tail<T>(l), p);
            }
        }
    }

    recursive function s_discarduntil_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            if(p[recursive?](ListOperators::s_safe_head<T>(l), idx)) {
                return l;
            }
            else {
                return ListOperators::s_discarduntil_idx<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
            }
        }
    }

    recursive function s_discarduntillast<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let taillast = ListOperators::s_discarduntillast<T>[recursive](ListOperators::s_safe_tail<T>(l), p);
            if(!ListOperators::s_empty<T>(taillast)) {
                return taillast;
            }
            else {
                if(p[recursive?](ListOperators::s_safe_head<T>(l))) {
                    return l;
                }
                else {
                    return List<T>@{}; 
                }
            }
        }
    }

    recursive function s_discarduntillast_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let taillast = ListOperators::s_discarduntillast_idx<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
            if(!ListOperators::s_empty<T>(taillast)) {
                return taillast;
            }
            else {
                if(p[recursive?](ListOperators::s_safe_head<T>(l), idx)) {
                    return l;
                }
                else {
                    return List<T>@{}; 
                }
            }
        }
    }

    recursive function s_countuntil<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            if(p[recursive?](vv)) {
                return idx;
            }
            else {
                return ListOperators::s_countuntil<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
            }
        }
    }

    recursive function s_countuntil_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            if(p[recursive?](vv, idx)) {
                return idx;
            }
            else {
                return ListOperators::s_countuntil<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
            }
        }
    }

    recursive function s_countuntillast<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let taillast = ListOperators::s_countuntillast<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);

            if(taillast === none) {
                if(p[recursive?](vv)) {
                    return idx;
                }
                else {
                    return none; 
                }
            }
            else {
                return taillast;
            }
        }
    }

    recursive function s_countuntillast_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let taillast = ListOperators::s_countuntillast_idx<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);

            if(taillast === none) {
                if(p[recursive?](vv, idx)) {
                    return idx;
                }
                else {
                    return none; 
                }
            }
            else {
                return taillast;
            }
        }
    }

    recursive function s_filter<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let rest = ListOperators::s_filter<T>[recursive](ListOperators::s_safe_tail<T>(l), p);
            if(p[recursive?](vv)) {
                return ListOperators::s_cons<T>(vv, rest);
            }
            else {
                return rest;
            }
        }
    }

    recursive function s_filter_idx<T>(l: List<T>, idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let rest = ListOperators::s_filter_idx<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, p);
            if(p[recursive?](vv, idx)) {
                return ListOperators::s_cons<T>(vv, rest);
            }
            else {
                return rest;
            }
        }
    }

    recursive function s_filter_type<T, U>(l: List<T>): List<U> {
        if(ListOperators::s_empty<T>(l)) {
            return List<U>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let rest = ListOperators::s_filter_type<T, U>[recursive](ListOperators::s_safe_tail<T>(l));
            if(vv.is<U>()) {
                return ListOperators::s_cons<U>(ListOperators::s_safeAs<U>(vv), rest);
            }
            else {
                return rest;
            }
        }
    }

    recursive function s_filter_some<T>(l: List<T>): List<T!Some> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T!Some>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let rest = ListOperators::s_filter_some<T>[recursive](ListOperators::s_safe_tail<T>(l));
            if(vv !== none) {
                return ListOperators::s_cons<T!Some>(vv, rest);
            }
            else {
                return rest;
            }
        }
    }

    recursive function s_filter_something<T unique IOption>(l: List<T>): List<T!IOptionT> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T!IOptionT>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let rest = ListOperators::s_filter_something<T>[recursive](ListOperators::s_safe_tail<T>(l));
            if(vv !== nothing) {
                return ListOperators::s_cons<T!IOptionT>(vv.value(), rest);
            }
            else {
                return rest;
            }
        }
    }
    
    recursive function s_cast_type<T, U>(l: List<T>): List<U> {
        if(ListOperators::s_empty<T>(l)) {
            return List<U>@{};
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let rest = ListOperators::s_cast_type<T, U>[recursive](ListOperators::s_safe_tail<T>(l));
            return ListOperators::s_cons<U>(vv.as<U>(), rest);
        }
    }

    recursive function s_slicefirst<T>(l: List<T>, k: Nat): List<T>? {
        if(k == 0) {
            return l;
        }
        elif(ListOperators::s_empty<T>(l)) {
            return none;
        }
        else {
            return ListOperators::s_slicefirst<T>[recursive](l, k - 1);
        }
    }

    recursive function s_slicelast<T>(l: List<T>, k: Nat): List<T> | Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0;
        }
        else {
            let lsf = ListOperators::s_slicelast<T>[recursive](l, k);
            if(lsf istype Nat) {
                if(lsf < k) {
                    return lsf + 1;
                }
                else {
                    return List@<T>{};
                } 
            }
            else {
                return ListOperators::s_cons<T>(ListOperators::s_safe_head<T>(l), lsf);
            }
        }
    }

    recursive function s_unique(l: List<T>, rl: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return ListOperators::s_reverse<T>(rl);
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let has = ListOperators::s_haspred<T>[recursive](rl, recursive pred(v: T): Bool => eq(vv, v));
            if(has) {
                ListOperators::s_unique<T>[recursive](ListOperators::s_safe_tail<T>(l), rl, eq);
            }
            else {
                const nrl = ListOperators::s_cons<T>(ListOperators::s_safe_head<T>(l), rl);
                ListOperators::s_unique<T>[recursive](ListOperators::s_safe_tail<T>(l), nrl, eq);
            }
        }
    }

    recursive function s_reverse(l: List<T>, rl: List<T>): List<T> {
        if(ListOperators::s_empty(l)) {
            return rl;
        }
        else {
            const nrl = ListOperators::s_cons<T>(ListOperators::s_safe_head<T>(l), rl);
            return ListOperators::s_reverse<T>[recursive](ListOperators::s_safe_tail<T>(l), nrl);
        }
    }

    recursive function s_map<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        if(ListOperators::s_empty<T>(l)) {
            return List<U>@{};
        }
        else {
            let u = f[recursive?](ListOperators::s_safe_head<T>(l));
            let rest = ListOperators::s_map<T, U>[recursive](ListOperators::s_safe_tail<T>(l), f);
            return ListOperators::s_cons<T>(u, rest);
        }
    }

    recursive function s_map_idx<T, U>(l: List<T>, idx: Nat, f: recursive? fn(_: T, _: Nat) -> U): List<U> {
        if(ListOperators::s_empty<T>(l)) {
            return List<U>@{};
        }
        else {
            let u = f[recursive?](ListOperators::s_safe_head<T>(l), idx);
            let rest = ListOperators::s_map_idx<T, U>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, f);
            return ListOperators::s_cons<T>(u, rest);
        }
    }
}

__internal entity ListKeyOperators provides Object {
    recursive function s_haselem_key<T grounded KeyType>(l: List<T>, v: T): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            if(KeyType::equal<T>(ListOperators::s_safe_head<T>(l), v)) {
                return true;
            }
            else {
                return ListKeyOperators::s_haselem_key<T>[recursive](ListOperators::s_safe_tail<T>(l), v);
            }
        }
    }

    recursive function s_countelem_key<T grounded KeyType>(l: List<T>, v: T): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let rest = ListKeyOperators::s_countelem_key<T>[recursive](ListOperators::s_safe_tail<T>(l), v);
            if(KeyType::equal<T>(ListOperators::s_safe_head<T>(l), v)) {
                return rest + 1;
            }
            else {
                return rest;
            }
        }
    }

    recursive function s_discarduntilequal<T grounded KeyType>(l: List<T>, v: T): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            if(KeyType::equal<T>(ListOperators::s_safe_head<T>(l), v)) {
                return l;
            }
            else {
                return ListOperators::s_discarduntilequal<T>[recursive](ListOperators::s_safe_tail<T>(l), v);
            }
        }
    }

    recursive function s_discarduntilequallast<T grounded KeyType>(l: List<T>, v: T): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let taillast = ListOperators::s_discarduntilequal<T>[recursive](ListOperators::s_safe_tail<T>(l), v);
            if(!ListOperators::s_empty<T>(taillast)) {
                return taillast;
            }
            else {
                if(KeyType::equal<T>(ListOperators::s_safe_head<T>(l), v)) {
                    return l;
                }
                else {
                    return List<T>@{}; 
                }
            }
        }
    }

    recursive function s_countuntilequal<T grounded KeyType>(l: List<T>, idx: Nat, v: T): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
        else {
            if(KeyType::equal<T>(ListOperators::s_safe_head<T>(l), v)) {
                return idx;
            }
            else {
                return ListOperators::s_countuntilequal<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, v);
            }
        }
    }

    recursive function s_countuntilequallast<T grounded KeyType>(l: List<T>, idx: Nat, v: T): Nat? {
        if(ListOperators::s_empty<T>(l)) {
            return none;
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let taillast = ListOperators::s_countuntilequallast<T>[recursive](ListOperators::s_safe_tail<T>(l), idx + 1, v);

            if(taillast === none) {
                if(KeyType::equal<T>(ListOperators::s_safe_head<T>(l), v)) {
                    return idx;
                }
                else {
                    return none; 
                }
            }
            else {
                return taillast;
            }
        }
    }

    recursive function s_unique_key<T grounded KeyType>(l: List<T>): List<T> {
        if(ListOperators::s_empty(l)) {
            return ListOperators::s_reverse<T>(rl);
        }
        else {
            let vv = ListOperators::s_safe_head<T>(l);
            let has = ListOperators::s_haselem_key<T>[recursive](rl, vv);
            if(has) {
                ListOperators::s_unique_key<T>[recursive](ListOperators::s_safe_tail<T>(l), rl, eq);
            }
            else {
                const nrl = ListOperators::s_cons<T>(ListOperators::s_safe_head<T>(l), rl);
                ListOperators::s_unique_key<T>[recursive](ListOperators::s_safe_tail<T>(l), nrl, eq);
            }
        }
    }
}

__internal entity ListArithOperators provides Object {
    recursive function s_argmin<T, U unique Orderable>(l: List<T>, v: T, u: U, f: recursive? fn(_: T) -> U): T {
        if(ListOperators::s_empty<T>(l)) {
            return v;
        }
        else {
            let vval = ListOperators::s_safe_head<T>(l);
            let uval = f[recursive?](vval);
            if(uval < u) {
                return ListArithOperators::s_argmin<T, U>[recursive](ListOperators::s_safe_tail<T>(l), vval, uval, f);
            }
            else {
                return ListArithOperators::s_argmin<T, U>[recursive](ListOperators::s_safe_tail<T>(l), v, u, f);
            }
        }
    }

    recursive function s_min<T unique Orderable>(l: List<T>, v: T): T {
        if(ListOperators::s_empty<T>(l)) {
            return v;
        }
        else {
            let vval = ListOperators::s_safe_head<T>(l);
            if(vval < v) {
                return ListArithOperators::s_min<T>[recursive](ListOperators::s_safe_tail<T>(l), vval);
            }
            else {
                return ListArithOperators::s_min<T>[recursive](ListOperators::s_safe_tail<T>(l), v);
            }
        }
    }

    recursive function s_argmax<T, U unique Orderable>(l: List<T>, v: T, u: U, f: recursive? fn(_: T) -> U): T {
        if(ListOperators::s_empty<T>(l)) {
            return v;
        }
        else {
            let vval = ListOperators::s_safe_head<T>(l);
            let uval = f[recursive?](vval);
            if(uval > u) {
                return ListArithOperators::s_argmin<T, U>[recursive](ListOperators::s_safe_tail<T>(l), vval, uval, f);
            }
            else {
                return ListArithOperators::s_argmin<T, U>[recursive](ListOperators::s_safe_tail<T>(l), v, u, f);
            }
        }
    }

    recursive function s_max<T unique Orderable>(l: List<T>, v: T): T {
        if(ListOperators::s_empty<T>(l)) {
            return v;
        }
        else {
            let vval = ListOperators::s_safe_head<T>(l);
            if(vval > v) {
                return ListArithOperators::s_min<T>[recursive](ListOperators::s_safe_tail<T>(l), vval);
            }
            else {
                return ListArithOperators::s_min<T>[recursive](ListOperators::s_safe_tail<T>(l), v);
            }
        }
    }

    recursive function s_sum<T unique Algebraic>(l: List<T>): T {
        if(ListOperators::s_empty<T>(l)) {
            return T::zero;
        }
        else {
            let rest = ListArithOperators::s_sum<T>[recursive](ListOperators::s_safe_tail<T>(l));
            return ListOperators::s_safe_head<T>(l) + rest; 
        }
    }
}

#else

__internal entity ISequence provides Object {
    __safe function s_size(isq: ISequence): Nat # isequence_size
}

__internal entity JSequence provides Object {
    __safe function s_size(jsq: JSequence): Nat # jsequence_size
}

__internal entity SSequence provides Object {
    __safe function s_size(ssq: SSequence): Nat # ssequence_size
}

__internal entity USequence provides Object {
    __safe function s_size(usq: USequence): Nat # usequence_size
}

__internal entity ListOperators provides Object {
    ////////////////
    //Built Implemented Functions
    ////////////////

    //Core accessors
    __assume_safe s_safeAs<T, U>(v: T): U # list_safeas

    __safe function s_size<T>(l: List<T>): Nat # list_size
    __safe function s_empty<T>(l: List<T>): Bool # list_empty
    __assume_safe function s_safe_get<T>(l: List<T>, i: Nat): T # list_safe_get

    //assume non-empty
    recursive? function s_safeCheckPred_Core<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_safecheckpred
    recursive? function s_safeCheckFn_Core<T, U>(l: List<T>, count: Nat, f: recursive? fn(_: T) -> U): List<T> # list_safecheckfn

    recursive? function s_safeCheckPred_PairCore<T, U>[recursive?](l: List<T>, ol: List<U>, lcount: Nat, olcount: Nat, recursive? pred(_: T, _: U) -> Bool): [List<T>, List<U>] # list_safecheckpair
    recursive? function s_safeCheckPred_PairSingleCore<T>[recursive?](l: List<T>, count: Nat, recursive? pred(_: T, _: T) -> Bool): List<T> # list_safecheckpairsingle

    //assume non-empty, safe, and exists at least one satisfying
    recursive? function s_computeISequence<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): ISequence # list_computeisequence
    recursive? function s_computeJSequence<T, U>(l: List<T>, lcount: Nat, ol: List<U>, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> # list_computejsequence

    //assume non-empty and safe
    recursive? function s_computeSSequence<T>(l: List<T>, count: Nat, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> # list_computessequence
    recursive? function s_computeUSequence<T>(l: List<T>, count: Nat, eq: recursive? pred(_: T, _: T) -> Bool): List<T> # list_computeusequence

    ////
    //Constructors 
    __assume_safe function s_rangeOfInt(start: Int, end: Int): List<Int> # list_rangeofint
    __assume_safe function s_rangeOfNat(start: Nat, end: Nat): List<Nat> # list_rangeofnat
    __assume_safe function s_fill<T>(k: Nat, val: T): List<T> # list_fill

    __assume_safe function s_zip<T, U>(l1: List<T>, l2: List<U>, size: Nat): List<[T, U]> # list_zip
    __assume_safe function s_zipindex<T>(l1: List<T>, size: Nat): List<[Nat, T]> # list_zipindex

    __assume_safe function s_concat2_Constructor(l1: List<T>, l2: List<T>, count: Nat): List<T> # list_concat2
    __assume_safe function s_slice_Constructor(l: List<T>, start: Nat, end: Nat, count: Nat): List<T> # list_slice
    __assume_safe function s_reverse_Constructor(l: List<T>, count: Nat): List<T> # list_reverse

    recursive? function s_filter_Constructor<T>(l: List<T>, isq: ISequence, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_filter_helper

    recursive? function s_map_Constructor<T, U>(l: List<T>, count: Nat, f: recursive? fn(_: T) -> U): List<U> # list_map

    recursive? function s_join_Constructor<T, U>(l: List<T>, ol: List<U>, jsq: JSequence, lcount: Nat, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> # list_join_helper

    recursive? function s_sort_Constructor<T>(l: List<T>, ssq: SSequence, count: Nat, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> # list_sort_helper
    recursive? function s_unique_Constructor<T>(l: List<T>, usq: USequence, count: Nat, eq: recursive? pred(_: T, _: T) -> Bool): List<T> # list_filter_helper

    ////
    //Destructors
    recursive? function s_hasPredCheck_Core<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): Bool # list_haspredcheck

    recursive? function s_hasPredCheckPair_Core<T, U>(l: List<T>, lcount: Nat, ol: List<U>, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): Bool # list_haspredcheckpair

    recursive? function s_findIndexOf_PredicateCore<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): Nat # list_findindexof_predicatehelper
    recursive? function s_findIndexOfLast_PredicateCore<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): Nat # list_findindexoflast_predicatehelper

    ////////////////
    //In code support operations
    ////////////////

    recursive? function s_safeCheckPred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            //TODO: here special case for small model
            return ListOperators::s_safeCheckPred_Core<T>[recursive?](l, ListOperators::s_size<T>(l), p);
        }
    }

    recursive? function s_safeCheckFn<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            //TODO: here special case for small model
            return ListOperators::s_safeCheckFn_Core<T, U>[recursive?](l, ListOperators::s_size<T>(l), f);
        }
    }

    recursive? function s_safeCheckPred_Pair<T, U>[recursive?](l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<T>, List<U> {
        if(ListOperators::s_empty<T>(l) && ListOperators::s_empty<U>(ol)) {
            return List<T>@{}, List<U>@{};
        }
        elif(ListOperators::s_empty<T>(l)) {
            return List<T>@{}, ol;
        }
        elif(ListOperators::s_empty<U>(ol)) {
            return l, List<U>@{};
        }
        else {
            //TODO: here special case for small model
            let lp = ListOperators::s_safeCheckPred_PairCore<T, U>[recursive?](l, ol, ListOperators::s_size<T>(l), ListOperators::s_size<U>(ol), p);
            return lp.0, lp.1;
        }
    }

    recursive? function s_safeCheckPred_PairSingle<T>[recursive?](l: List<T>, p: recursive? pred(_: T, _: U) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            //TODO: here special case for small model
            return ListOperators::s_safeCheckPred_PairSingleCore<T>[recursive?](l, ListOperators::s_size<T>(l), p);
        }
    }

    recursive? function s_hasPredCheck<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
        
            //TODO: here special case for small model
            return ListOperators::s_hasPredCheck_Core<T>(sl, ListOperators::s_size<T>(sl), p);
        }
    }

    function s_concat2_Helper<T>(l1: List<T>, l2: List<T>): List<T> {
        let l1empty = ListOperators::s_empty<T>(l1);
        let l2empty = ListOperators::s_empty<T>(l2);

        if(l1empty && l2empty) {
            return List<T>@{};
        }
        else {
            if(l1empty) {
                return l2;
            }
            elif(l2empty) {
                return l1;
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_concat2_Constructor<T>(l1, l2, ListOperators::s_size<T>(l1) + ListOperators::s_size<T>(l2));
            }
        }
    }

    function s_slice_Helper<T>(l: List<T>, start: Nat, end: Nat): List<T> {
        let count = end - start;

        if(count == 0) {
            return List<T>@{};
        }
        elif (count == ListOperators::s_size<T>(l)) {
            return l;
        }
        else {
            //TODO: here special case for small model
            return ListOperators::s_slice_Constructor<T>(l, start, end, count);  
        }
    }

    function s_reverse_Helper<T>(l: List<T>): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let count = ListOperators::s_size<T>(l);
            if (count == 1) {
                return l;
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_reverse_Constructor<T>(l, count);  
            }
        }
    }

    recursive? function s_findIndexOf_PredicateHelper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                return ListOperators::s_findIndexOf_PredicateCore<T>[recursive?](sl, count, p);
            }
            else {
                return count;
            }
        }
    }

    recursive? function s_findIndexOfLast_PredicateHelper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                return ListOperators::s_findIndexOfLast_PredicateCore<T>[recursive?](sl, count, p);
            }
            else {
                return count;
            }
        }
    }

    recursive? function s_countIf_Helper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, recursive? pred(v: T) => !p[recursive?](v))) {
                    let isq = ListOperators::s_computeISequence[recursive?](sl, count, p);
                    return ISequence::s_size(isq);
                }
                else {
                    return count;
                }
            }
            else {
                return 0n;
            }
        }
    }

    recursive? function s_filter_Helper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, recursive? pred(v: T) => !p[recursive?](v))) {
                    let isq = ListOperators::s_computeISequence<T>[recursive?](sl, count, p);
                    return ListOperators::s_filter_Constructor<T>[recursive?](sl, isq, count, p);
                }
                else {
                    return sl;
                }
            }
            else {
                return List<T>@{};
            }
        }
    }

    recursive? function s_map_Helper<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        if(ListOperators::s_empty<T>(l)) {
            return List<U>@{};
        }
        else {
            let sl = ListOperators::s_safeCheckFn<T, U>[recursive?](l, f);

            //TODO: here special case for small model
            return ListOperators::s_map_Constructor<T, U>[recursive?](sl, ListOperators::s_size<T>(sl), f);
        }
    }

    recursive? function s_join_Helper<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        if(ListOperators::s_empty(l)) {
            return List<[T, U]>@{};
        }
        elif(ListOperators::s_empty(ol)) {
            return List<[T, U]>@{};
        }
        else {
            let sl, sol = ListOperators::s_safeCheckPred_Pair<T, U>[recursive?](l, ol, p);
            let count = ListOperators::s_size<T>(sl);
            let ocount = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheckPair_Core<T, U>[recursive?](sl, count, sol, ocount, p)) {
                let jsq = ListOperators::s_computeJSequence<T>[recursive?](sl, count, sol, ocount, p);
                return ListOperators::s_join_Constructor<T>[recursive?](sl, sol, jsq, count, ocount, p);
            }
            else {
                return List<[T, U]>@{};
            }
        }
    }

    recursive? function s_sort_Helper<T>(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        elif (ListOperators::s_size<T>(l) == 1) {
            return l;
        }
        else {
            let sl = ListOperators::s_safeCheckPred_PairSingle<T>[recursive?](l, cmp);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            let ssq = ListOperators::s_computeSSequence<T>[recursive?](sl, count, cmp);
            return ListOperators::s_sort_Constructor<T>[recursive?](sl, ssq, count, cmp);
        }
    }

    recursive? function s_unique_Helper<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        elif (ListOperators::s_size<T>(l) == 1) {
            return l;
        }
        else {
            let sl = ListOperators::s_safeCheckPred_PairSingle<T>[recursive?](l, cmp);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            let usq = ListOperators::s_computeUSequence<T>[recursive?](sl, count, cmp);
            return ListOperators::s_unique_Constructor<T>[recursive?](sl, usq, count, cmp);
        }
    }
}

__internal entity ListKeyOperators provides Object {
    ////////////////
    //Built Implemented Functions
    ////////////////

    //assume non-empty
    function s_hasCheck_Core<T grounded KeyType>(l: List<T>, count: Nat, val: T): Bool # list_hascheck
    function s_hasCheckMapKV_Core<T grounded KeyType, U>(l: List<[T, U]>, count: Nat, val: T): Bool # list_hascheckmapkv

    //assume non-empty
    function s_findIndexOf_KeyHelperCore<T grounded KeyType>(l: List<T>, count: Nat, val: T): Nat # list_findindexof_keyhelper
    function s_findIndexOfLast_KeyHelperCore<T grounded KeyType>(l: List<T>, count: Nat, val: T): Nat # list_findindexoflast_keyhelper
    function s_findIndexOfMapKV_KeyHelperCore<T grounded KeyType, U>(l: List<[T, U]>, count: Nat, val: T): Nat # list_findindexofmapkv_keyhelper

    function s_overlapsMapKV_KeyHelperCore<T grounded KeyType, U>(l1: List<[T, U]>, count1: Nat, l2: List<[T, U]>, count2: Nat): Bool # list_overlapsmapkv_keyhelper

    ////////////////
    //In code support operations
    ////////////////

    function s_hasCheck<T grounded KeyType>(l: List<T>, val: T): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            //TODO: here special case for small model
            return ListKeyOperators::s_hasCheck_Core<T>(l, ListOperators::s_size<T>(l), val);
        }
    }

    function s_hasCheckMapKV<T grounded KeyType, U>(l: List<[T, U]>, val: T): Bool {
        if(ListOperators<[T, U]>::s_empty(l)) {
            return false;
        }
        else {
            //TODO: here special case for small model
            return ListKeyOperators<[T, U]>::s_hasCheckMapKV_Core(l, ListOperators<[T, U]>::s_size(l), val);
        }
    }

    function s_findIndexOf_KeyHelper<T grounded KeyType>(l: List<T>, val: T): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let count = ListOperators::s_size<T>(l);

            //TODO: here special case for small model
            if(ListKeyOperators::s_hasCheck_Core<T>(l, count, val)) {
                return ListKeyOperators::s_findIndexOf_KeyHelperCore<T>(l, count, val);
            }
            else {
                return count;
            }
        }
    }

    function s_findIndexOfLast_KeyHelper<T grounded KeyType>(l: List<T>, val: T): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let count = ListOperators::s_size<T>(l);

            //TODO: here special case for small model
            if(ListKeyOperators::s_hasCheck_Core<T>(l, count, val)) {
                return ListKeyOperators::s_findIndexOfLast_KeyHelperCore<T>(l, count, val);
            }
            else {
                return count;
            }
        }
    }

    function s_findIndexOfMapKV_KeyHelper<T grounded KeyType, U>(l: List<[T, U]>, val: T): Nat {
        if(ListOperators::s_empty<[T, U]>(l)) {
            return 0n;
        }
        else {
            let count = ListOperators::s_size<[T, U]>(l);

            //TODO: here special case for small model
            if(ListKeyOperators::s_hasCheckMapKV_Core<T, U>(l, count, val)) {
                return ListKeyOperators::s_findIndexOfMapKV_KeyHelperCore<T, U>(l, count, val);
            }
            else {
                return count;
            }
        }
    }

    function s_overlapsMapKV_KeyHelper<T grounded KeyType, U>(l1: List<[T, U]>, l2: List<[T, U]>): Bool {
        if(ListOperators::s_empty<[T, U]>(l1)) {
            return false;
        }
        elif(ListOperators::s_empty<[T, U]>(l2)) {
            return false;
        }
        else {
            let count1 = ListOperators::s_size<[T, U]>(l1);
            let count2 = ListOperators::s_size<[T, U]>(l2);

            //TODO: here special case for small model
            return ListKeyOperators::s_overlapsMapKV_KeyHelperCore<T, U>(l1, count1, l2, count2);
        }
    }
}

__internal entity ListArithOperators provides Object {
    ////////////////
    //Built Implemented Functions
    ////////////////

    //assume non-empty
    function s_minIdx_Core<T unique Orderable>(l: List<[Nat, T]>): Nat # list_minidx
    function s_maxIdx_Core<T unique Orderable>(l: List<[Nat, T]>): Nat # list_maxidx

#if UF_APPROX
    function s_sum_Core<T unique Algebraic>(l: List<T>): T # list_sum
#endif

    ////////////////
    //In code support operations
    ////////////////

    function s_minIdx_Helper<T unique Orderable>(l: List<T>): Nat {
        let count = ListOperators::s_size<T>(l);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(l, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(l, 0n);
            let b = ListOperators::s_safe_get<T>(l, 1n);
            if(a <= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = l.index();
            return ListOperators::s_minIdx_Core<T>(zl);
        }
    }
    
    function s_maxIdx_Helper<T unique Orderable>(l: List<T>): Nat {
        let count = ListOperators::s_size<T>(l);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(l, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(l, 0n);
            let b = ListOperators::s_safe_get<T>(l, 1n);
            if(a >= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = l.index();
            return ListOperators::s_maxIdx_Core<T>(zl);
        }
    }

    recursive? function s_argminIdx_Helper<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): Nat {
        let fl = l.map(f);
        let count = ListOperators::s_size<T>(fl);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(fl, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(fl, 0n);
            let b = ListOperators::s_safe_get<T>(fl, 1n);
            if(a <= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = fl.index();
            return ListOperators::s_minIdx_Core<U>(zl);
        }
    }
    
    recursive? function s_argmaxIdx_Helper<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): Nat {
         let fl = l.map(f);
        let count = ListOperators::s_size<T>(fl);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(fl, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(fl, 0n);
            let b = ListOperators::s_safe_get<T>(fl, 1n);
            if(a <= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = fl.index();
            return ListOperators::s_maxIdx_Core<U>(sl);
        }
    }

#if UF_APPROX
    function s_sum_Helper<T unique Algebraic>(l: List<T>): T {
        if(ListOperators::s_empty<T>(l)) {
            return T::zero;
        }
        else {
            let count = ListOperators::s_size<T>(l);
            
            if(count == 1n) {
                return ListOperators::s_safe_get<T>(l, 0n);
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_sum_Core<T>(l);
            }
        }
    }
#else
    recursive function s_sum_Core<T unique Algebraic>(l: List<T>, acc: T, cpos: Nat, count: Nat): T {
        if(cpos == count) {
            return acc;
        }
        else {
            let nacc = acc + ListOperators::s_safe_get<T>(l, cpos);
            return ListOperators::s_sum_Core<T>[recursive](l, nacc, cpos + 1n, count);
        }
    }

    function s_sum_Helper<T unique Algebraic>(l: List<T>): T {
        if(ListOperators::s_empty<T>(l)) {
            return T::zero;
        }
        else {
            let count = ListOperators::s_size<T>(l);
            
            if(count == 1n) {
                return ListOperators::s_safe_get<T>(l, 0n);
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_sum_Core<T>[recursive](l, T::zero, 0n, count);
            }
        }
    }
#endif
}
#endif
