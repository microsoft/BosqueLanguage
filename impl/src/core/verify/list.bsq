//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

__internal entity ISequence provides Object {
    __safe function s_size(l: List<T>): Nat # isequence_size
}

__internal entity JSequence provides Object {
    __safe function s_size(l: List<T>): Nat # jsequence_size
}

__internal entity SSequence provides Object {
    __safe function s_size(l: List<T>): Nat # ssequence_size
}

__internal entity USequence provides Object {
    __safe function s_size(l: List<T>): Nat # usequence_size
}

__internal entity ListOperators provides Object {
    ////////////////
    //Built Implemented Functions
    ////////////////

    //Core accessors
    __assume_safe s_safeAs<T, U>(v: T): U # list_safeas

    __safe function s_size<T>(l: List<T>): Nat # list_size
    __safe function s_empty<T>(l: List<T>): Bool # list_empty
    __assume_safe function s_safe_get<T>(l: List<T>, i: Nat): T # list_safe_get

    //assume non-empty
    recursive? function s_safeCheckPred_Core<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_safecheckpred
    recursive? function s_safeCheckFn_Core<T, U>(l: List<T>, count: Nat, f: recursive? fn(_: T) -> U): List<T> # list_safecheckfn

    recursive? function s_safeCheckPred_PairCore<T, U>[recursive?](l: List<T>, ol: List<U>, lcount: Nat, olcount: Nat, recursive? pred(_: T, _: U) -> Bool): [List<T>, List<U>] # list_safecheckpair
    recursive? function s_safeCheckPred_PairSingleCore<T>[recursive?](l: List<T>, count: Nat, recursive? pred(_: T, _: T) -> Bool): List<T> # list_safecheckpairsingle

    //assume non-empty, safe, and exists at least one satisfying
    recursive? function s_computeISequence<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): ISequence # list_computeisequence
    recursive? function s_computeJSequence<T, U>(l: List<T>, lcount: Nat, ol: List<U>, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> # list_computejsequence

    //assume non-empty and safe
    recursive? function s_computeSSequence<T>(l: List<T>, count: Nat, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> # list_computessequence
    recursive? function s_computeUSequence<T>(l: List<T>, count: Nat, eq: recursive? pred(_: T, _: T) -> Bool): List<T> # list_computeusequence

    ////
    //Constructors 
    __assume_safe function s_rangeOfInt(start: Int, end: Int): List<Int> # list_rangeofint
    __assume_safe function s_rangeOfNat(start: Nat, end: Nat): List<Nat> # list_rangeofnat
    __assume_safe function s_fill<T>(k: Nat, val: T): List<T> # list_fill

    __assume_safe function s_zip<T, U>(l1: List<T>, l2: List<U>, size: Nat): List<[T, U]> # list_zip
    __assume_safe function s_zipindex<T>(l1: List<T>, size: Nat): List<[Nat, T]> # list_zipindex

    __assume_safe function s_concat2_Constructor(l1: List<T>, l2: List<T>, count: Nat): List<T> # list_concat2
    __assume_safe function s_slice_Constructor(l: List<T>, start: Nat, end: Nat, count: Nat): List<T> # list_slice
    __assume_safe function s_reverse_Constructor(l: List<T>, count: Nat): List<T> # list_reverse

    recursive? function s_filter_Constructor<T>(l: List<T>, isq: ISequence, count: Nat, p: recursive? pred(_: T) -> Bool): List<T> # list_filter_helper

    recursive? function s_map_Constructor<T, U>(l: List<T>, count: Nat, f: recursive? fn(_: T) -> U): List<U> # list_map

    recursive? function s_join_Constructor<T, U>(l: List<T>, ol: List<U>, jsq: JSequence, lcount: Nat, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> # list_join_helper

    recursive? function s_sort_Constructor<T>(l: List<T>, ssq: SSequence, count: Nat, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> # list_sort_helper
    recursive? function s_unique_Constructor<T>(l: List<T>, usq: USequence, count: Nat, eq: recursive? pred(_: T, _: T) -> Bool): List<T> # list_filter_helper

    ////
    //Destructors
    recursive? function s_hasPredCheck_Core<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): Bool # list_haspredcheck

    recursive? function s_hasPredCheckPair_Core<T, U>(l: List<T>, lcount: Nat, ol: List<U>, olcount: Nat, p: recursive? pred(_: T, _: U) -> Bool): Bool # list_haspredcheckpair

    recursive? function s_findIndexOf_PredicateCore<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): Nat # list_findindexof_predicatehelper
    recursive? function s_findIndexOfLast_PredicateCore<T>(l: List<T>, count: Nat, p: recursive? pred(_: T) -> Bool): Nat # list_findindexoflast_predicatehelper

    ////////////////
    //In code support operations
    ////////////////

    recursive? function s_safeCheckPred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            //TODO: here special case for small model
            return ListOperators::s_safeCheckPred_Core<T>[recursive?](l, ListOperators::s_size<T>(l), p);
        }
    }

    recursive? function s_safeCheckFn<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            //TODO: here special case for small model
            return ListOperators::s_safeCheckFn_Core<T, U>[recursive?](l, ListOperators::s_size<T>(l), f);
        }
    }

    recursive? function s_safeCheckPred_Pair<T, U>[recursive?](l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<T>, List<U> {
        if(ListOperators::s_empty<T>(l) /\ ListOperators::s_empty<U>(ol)) {
            return List<T>@{}, List<U>@{};
        }
        elif(ListOperators::s_empty<T>(l)) {
            return List<T>@{}, ol;
        }
        elif(ListOperators::s_empty<T>(l) \/ ListOperators::s_empty<U>(ol)) {
            return l, List<U>@{};
        }
        else {
            //TODO: here special case for small model
            let lp = ListOperators::s_safeCheckPred_PairCore<T, U>[recursive?](l, ol, ListOperators::s_size<T>(l), ListOperators::s_size<U>(ol), p);
            return lp.0, lp.1;
        }
    }

    recursive? function s_safeCheckPred_PairSingle<T>[recursive?](l: List<T>, p: recursive? pred(_: T, _: U) -> Bool): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            //TODO: here special case for small model
            return ListOperators::s_safeCheckPred_PairSingleCore<T>[recursive?](l, ListOperators::s_size<T>(l), p);
        }
    }

    recursive? function s_hasPredCheck<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
        
            //TODO: here special case for small model
            return ListOperators::s_hasPredCheck_Core<T>(sl, ListOperators::s_size<T>(sl), p);
        }
    }

    function s_concat2_Helper<T>(l1: List<T>, l2: List<T>): List<T> {
        let l1empty = ListOperators::s_empty<T>(l1);
        let l2empty = ListOperators::s_empty<T>(l2);

        if(l1empty /\ l2empty) {
            return List<T>@{};
        }
        else {
            if(l1empty) {
                return l2;
            }
            elif(l2empty) {
                return l1;
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_concat2_Constructor<T>(l1, l2, ListOperators::s_size<T>(l1) + ListOperators::s_size<T>(l2));
            }
        }
    }

    function s_slice_Helper<T>(l: List<T>, start: Nat, end: Nat): List<T> {
        let count = end - start;

        if(count == 0) {
            return List<T>@{};
        }
        elif (count == ListOperators::s_size<T>(l)) {
            return l;
        }
        else {
            //TODO: here special case for small model
            return ListOperators::s_slice_Constructor<T>(l, start, end, count);  
        }
    }

    function s_reverse_Helper<T>(l: List<T>): List<T> {
        if(ListOperators::s_empty<T>(l)) {
            return List<T>@{};
        }
        else {
            let count = ListOperators::s_size<T>(l);
            if (count == 1) {
                return l;
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_reverse_Constructor<T>(l, count);  
            }
        }
    }

    recursive? function s_findIndexOf_PredicateHelper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                return ListOperators::s_findIndexOf_PredicateCore<T>[recursive?](sl, count, p);
            }
            else {
                return count;
            }
        }
    }

    recursive? function s_findIndexOfLast_PredicateHelper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                return ListOperators::s_findIndexOfLast_PredicateCore<T>[recursive?](sl, count, p);
            }
            else {
                return count;
            }
        }
    }

    recursive? function s_countIf_Helper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, recursive? pred(v: T) => !p[recursive?](v))) {
                    let isq = ListOperators::s_computeISequence[recursive?](sl, count, p);
                    return ISequence::s_size(isq);
                }
                else {
                    return count;
                }
            }
            else {
                return 0n;
            }
        }
    }

    recursive? function s_filter_Helper<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        else {
            let sl = ListOperators::s_safeCheckPred<T>[recursive?](l, p);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, p)) {
                if(ListOperators::s_hasPredCheck_Core<T>[recursive?](sl, count, recursive? pred(v: T) => !p[recursive?](v))) {
                    let isq = ListOperators::s_computeISequence<T>[recursive?](sl, count, p);
                    return ListOperators::s_filter_Constructor<T>[recursive?](sl, isq, count, p);
                }
                else {
                    return sl;
                }
            }
            else {
                return List<T>@{};
            }
        }
    }

    recursive? function s_map_Helper<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> {
        if(ListOperators::s_empty<T>(l)) {
            return List<U>@{};
        }
        else {
            let sl = ListOperators::s_safeCheckFn<T, U>[recursive?](l, f);

            //TODO: here special case for small model
            return ListOperators::s_map_Constructor<T, U>[recursive?](sl, ListOperators::s_size<T>(sl), f);
        }
    }

    recursive? function s_join_Helper<T, U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<[T, U]> {
        if(ListOperators::s_empty(l) \/ ListOperators::s_empty(ol)) {
            return List<[T, U]>@{};
        }
        else {
            let sl, sol = ListOperators::s_safeCheckPred_Pair<T, U>[recursive?](l, ol, p);
            let count = ListOperators::s_size<T>(sl);
            let ocount = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            if(ListOperators::s_hasPredCheckPair_Core<T, U>[recursive?](sl, count, sol, ocount, p)) {
                let jsq = ListOperators::s_computeJSequence<T>[recursive?](sl, count, sol, ocount, p);
                return ListOperators::s_join_Constructor<T>[recursive?](sl, sol, jsq, count, ocount, p);
            }
            else {
                return List<[T, U]>@{};
            }
        }
    }

    recursive? function s_sort_Helper<T>(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        elif (ListOperators::s_size<T>(l) == 1) {
            return l;
        }
        else {
            let sl = ListOperators::s_safeCheckPred_PairSingle<T>[recursive?](l, cmp);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            let ssq = ListOperators::s_computeSSequence<T>[recursive?](sl, count, cmp);
            return ListOperators::s_sort_Constructor<T>[recursive?](sl, ssq, count, cmp);
        }
    }

    recursive? function s_unique_Helper<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
        if(ListOperators::s_empty(l)) {
            return List<T>@{};
        }
        elif (ListOperators::s_size<T>(l) == 1) {
            return l;
        }
        else {
            let sl = ListOperators::s_safeCheckPred_PairSingle<T>[recursive?](l, cmp);
            let count = ListOperators::s_size<T>(sl);

            //TODO: here special case for small model
            let usq = ListOperators::s_computeUSequence<T>[recursive?](sl, count, cmp);
            return ListOperators::s_unique_Constructor<T>[recursive?](sl, usq, count, cmp);
        }
    }
}

__internal entity ListKeyOperators provides Object {
    ////////////////
    //Built Implemented Functions
    ////////////////

    //assume non-empty
    function s_hasCheck_Core<T grounded KeyType>(l: List<T>, count: Nat, val: T): Bool # list_hascheck
    function s_hasCheckMapKV_Core<T grounded KeyType, U>(l: List<[T, U]>, count: Nat, val: T): Bool # list_hascheckmapkv

    //assume non-empty
    function s_findIndexOf_KeyHelperCore<T grounded KeyType>(l: List<T>, count: Nat, val: T): Nat # list_findindexof_keyhelper
    function s_findIndexOfLast_KeyHelperCore<T grounded KeyType>(l: List<T>, count: Nat, val: T): Nat # list_findindexoflast_keyhelper
    function s_findIndexOfMapKV_KeyHelperCore<T grounded KeyType, U>(l: List<[T, U]>, count: Nat, val: T): Nat # list_findindexofmapkv_keyhelper

    function s_overlapsMapKV_KeyHelperCore<T grounded KeyType, U>(l1: List<[T, U]>, count1: Nat, l2: List<[T, U]>, count2: Nat): Bool # list_overlapsmapkv_keyhelper

    ////////////////
    //In code support operations
    ////////////////

    function s_hasCheck<T grounded KeyType>(l: List<T>, val: T): Bool {
        if(ListOperators::s_empty<T>(l)) {
            return false;
        }
        else {
            //TODO: here special case for small model
            return ListKeyOperators::s_hasCheck_Core<T>(l, ListOperators::s_size<T>(l), val);
        }
    }

    function s_hasCheckMapKV<T grounded KeyType, U>(l: List<[T, U]>, val: T): Bool {
        if(ListOperators<[T, U]>::s_empty(l)) {
            return false;
        }
        else {
            //TODO: here special case for small model
            return ListKeyOperators<[T, U]>::s_hasCheckMapKV_Core(l, ListOperators<[T, U]>::s_size(l), val);
        }
    }

    function s_findIndexOf_KeyHelper<T grounded KeyType>(l: List<T>, val: T): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let count = ListOperators::s_size<T>(l);

            //TODO: here special case for small model
            if(ListKeyOperators::s_hasCheck_Core<T>(l, count, val)) {
                return ListKeyOperators::s_findIndexOf_KeyHelperCore<T>(l, count, val);
            }
            else {
                return count;
            }
        }
    }

    function s_findIndexOfLast_KeyHelper<T grounded KeyType>(l: List<T>, val: T): Nat {
        if(ListOperators::s_empty<T>(l)) {
            return 0n;
        }
        else {
            let count = ListOperators::s_size<T>(l);

            //TODO: here special case for small model
            if(ListKeyOperators::s_hasCheck_Core<T>(l, count, val)) {
                return ListKeyOperators::s_findIndexOfLast_KeyHelperCore<T>(l, count, val);
            }
            else {
                return count;
            }
        }
    }

    function s_findIndexOfMapKV_KeyHelper<T grounded KeyType, U>(l: List<[T, U]>, val: T): Nat {
        if(ListOperators::s_empty<[T, U]>(l)) {
            return 0n;
        }
        else {
            let count = ListOperators::s_size<[T, U]>(l);

            //TODO: here special case for small model
            if(ListKeyOperators::s_hasCheckMapKV_Core<T, U>(l, count, val)) {
                return ListKeyOperators::s_findIndexOfMapKV_KeyHelperCore<T, U>(l, count, val);
            }
            else {
                return count;
            }
        }
    }

    function s_overlapsMapKV_KeyHelper<T grounded KeyType, U>(l1: List<[T, U]>, l2: List<[T, U]>): Bool {
        if(ListOperators::s_empty<[T, U]>(l1) \/ ListOperators::s_empty<[T, U]>(l2)) {
            return false;
        }
        else {
            let count1 = ListOperators::s_size<[T, U]>(l1);
            let count2 = ListOperators::s_size<[T, U]>(l2);

            //TODO: here special case for small model
            return ListKeyOperators::s_overlapsMapKV_KeyHelperCore<T, U>(l1, count1, l2, count2);
        }
    }
}

__internal entity ListArithOperators provides Object {
    ////////////////
    //Built Implemented Functions
    ////////////////

    //assume non-empty
    function s_minIdx_Core<T unique Orderable>(l: List<[Nat, T]>): Nat # list_minidx
    function s_maxIdx_Core<T unique Orderable>(l: List<[Nat, T]>): Nat # list_maxidx

#if UF_APPROX
    function s_sum_Core<T unique Algebraic>(l: List<T>): T # list_sum
#endif

    ////////////////
    //In code support operations
    ////////////////

    function s_minIdx_Helper<T unique Orderable>(l: List<T>): Nat {
        let count = ListOperators::s_size<T>(l);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(l, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(l, 0n);
            let b = ListOperators::s_safe_get<T>(l, 1n);
            if(a <= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = l.index();
            return ListOperators::s_minIdx_Core<T>(zl);
        }
    }
    
    function s_maxIdx_Helper<T unique Orderable>(l: List<T>): Nat {
        let count = ListOperators::s_size<T>(l);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(l, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(l, 0n);
            let b = ListOperators::s_safe_get<T>(l, 1n);
            if(a >= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = l.index();
            return ListOperators::s_maxIdx_Core<T>(zl);
        }
    }

    recursive? function s_argminIdx_Helper<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): Nat {
        let fl = l.map(f);
        let count = ListOperators::s_size<T>(fl);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(fl, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(fl, 0n);
            let b = ListOperators::s_safe_get<T>(fl, 1n);
            if(a <= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = fl.index();
            return ListOperators::s_minIdx_Core<U>(zl);
        }
    }
    
    recursive? function s_argmaxIdx_Helper<T, U unique Orderable>(l: List<T>, f: recursive? fn(_: T) -> U): Nat {
         let fl = l.map(f);
        let count = ListOperators::s_size<T>(fl);

        if(count == 1) {
            return ListOperators::s_safe_get<T>(fl, 0n); 
        }
        elif(count == 2) {
            let a = ListOperators::s_safe_get<T>(fl, 0n);
            let b = ListOperators::s_safe_get<T>(fl, 1n);
            if(a <= b) {
                return 0n;
            }
            else {
                return 1n;
            }
        }
        else {
            //TODO: here special case for small model
            let zl = fl.index();
            return ListOperators::s_maxIdx_Core<U>(sl);
        }
    }

#if UF_APPROX
    function s_sum_Helper<T unique Algebraic>(l: List<T>): T {
        if(ListOperators::s_empty<T>(l)) {
            return T::zero;
        }
        else {
            let count = ListOperators::s_size<T>(l);
            
            if(count == 1n) {
                return ListOperators::s_safe_get<T>(l, 0n);
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_sum_Core<T>(l);
            }
        }
    }
#else
    recursive function s_sum_Core<T unique Algebraic>(l: List<T>, acc: T, cpos: Nat, count: Nat): T {
        if(cpos == count) {
            return acc;
        }
        else {
            let nacc = acc + ListOperators::s_safe_get<T>(l, cpos);
            return ListOperators::s_sum_Core<T>[recursive](l, nacc, cpos + 1n, count);
        }
    }

    function s_sum_Helper<T unique Algebraic>(l: List<T>): T {
        if(ListOperators::s_empty<T>(l)) {
            return T::zero;
        }
        else {
            let count = ListOperators::s_size<T>(l);
            
            if(count == 1n) {
                return ListOperators::s_safe_get<T>(l, 0n);
            }
            else {
                //TODO: here special case for small model
                return ListOperators::s_sum_Core<T>[recursive](l, T::zero, 0n, count);
            }
        }
    }
#endif
}

__internal entity List<T> provides Object, Expandoable<T>, APIType when T APIType {
    function ints(start: Int, end: Int): List<Int>
        requires release start <= end;
    {
        if(start == end) {
            return List<Int>@{};
        }
        else {
            return ListOperators::s_rangeInt(start, end);
        }
    }

    function nats(start: Nat, end: Nat): List<Nat>
        requires release start <= end;
    {
        if(start == end) {
            return List<Nat>@{};
        }
        else {
            return ListOperators::s_rangeNat(start, end);
        }
    }

    method index(): List<[Nat, T]> {
        if(ListOperators::s_empty<T>(this)) {
            return List<[Nat, T]>@{};
        }
        else {
            return ListOperators::s_zipindex<T>(this, ListOperators::s_size<T>(this));
        }
    }

    method zip<U=?>(l: List<U>): List<[T, U]> 
        requires release ListOperators::s_size<T>(this) == ListOperators::s_size<U>(l);
    {
        if(ListOperators::s_empty<T>(this)) {
            return List<[T, U]>@{};
        }
        else {
            return ListOperators::s_zip<T, U>(this, l, ListOperators::s_size<T>(this));
        }
    }

    private function s_sliceRangeInBounds(l: List<T>, start: Nat, end: Nat): Bool {
        return start <= end /\ end <= ListOperators::s_size<T>(l); 
    }

    ////
    //Public interface
    ////

    function fill(k: Nat, val: T): List<T> {
        if(k == 0n) {
            return List<T>@{};
        }
        else {
            return List<T>::s_fill(k, val);
        }
    }

    function concat(...ll: List<List<T>>): List<T> {
        if(ListOperators<List<T>>::s_empty(ll)) {
            reutrn List<T>@{};
        }
        else {
            let count = ListOperators<List<T>>::s_size(ll);
            if(count == 1) {
                return ListOperators<List<T>>::s_safe_get(ll, 0n);
            }
            elif(count == 2) {
                return List<T>::s_concat2_Helper(ListOperators<List<T>>::s_safe_get(ll, 0n), ListOperators<List<T>>::s_safe_get(ll, 1n));
            }
            else if(count == 3) {
                let fl = List<T>::s_concat2_Helper(ListOperators<List<T>>::s_safe_get(ll, 0n), ListOperators<List<T>>::s_safe_get(ll, 1n));
                return List<T>::s_concat2_Helper(fl, ListOperators<List<T>>::s_safe_get(ll, 2n));
            }
            else {
                //TODO: we need to add a s_flatten constructor that is either an unroll for model generation or 
                //      an \forall k \exists i, j s.t. get(k) = ll.get(i).get(j) /\ \forall i, j => \exists k s.t. get(k) = ll.get(i).get(j) 
                check count == 4; 

                let fl = List<T>::s_concat2_Helper(ListOperators<List<T>>::s_safe_get(ll, 0n), ListOperators<List<T>>::s_safe_get(ll, 1n));
                let sl = List<T>::s_concat2_Helper(ListOperators<List<T>>::s_safe_get(ll, 2n), ListOperators<List<T>>::s_safe_get(ll, 3n));
                return List<T>::s_concat2_Helper(fl, sl);
            }
        }
    }

    method size(): Nat {
        return ListOperators::s_size<T>(this);
    }

    method empty(): Bool {
        return ListOperators::s_empty<T>(this);
    }

    method front(): T 
        requires release !ListOperators::s_empty<T>(this);
    {
        return ListOperators::s_safe_get<T>(this, 0n);
    }

    method frontOrNone(): T? {
        if(ListOperators::s_empty<T>(this)) {
            return none;
        }
        else {
            return ListOperators::s_safe_get<T>(this, 0n);
        }
    }

    method frontOption(): Option<T> {
        if(ListOperators::s_empty<T>(this)) {
            return nothing;
        }
        else {
            return something(ListOperators::s_safe_get<T>(this, 0n));
        }
    }

    method frontTry(out? res: T): Bool {
        if(!ListOperators::s_empty<T>(this)) {
            res = ListOperators::s_safe_get<T>(this, 0n);
            return true;
        }
        else {
            return false;
        }
    }

    method back(): T 
        requires release !ListOperators::s_empty<T>(this);
    {
        return ListOperators::s_safe_get<T>(this, ListOperators::s_size<T>(this) - 1n);
    }

    method backOrNone(): T? {
        if(ListOperators::s_empty<T>(this)) {
            return none;
        }
        else {
            return ListOperators::s_safe_get<T>(this, ListOperators::s_size<T>(this) - 1n);
        }
    }

    method backOption(): Option<T> {
        if(ListOperators::s_empty<T>(this)){
            return nothing;
        }
        else {
            return something(ListOperators::s_safe_get<T>(this, ListOperators::s_size<T>(this) - 1n));
        }
    }

    method backTry(out? res: T): Bool {
        if(!ListOperators::s_empty<T>(this)) {
            res = ListOperators::s_safe_get<T>(this, ListOperators::s_size<T>(this) - 1n);
            return true;
        }
        else {
            return false;
        }
    }

    method get(i: Nat): T 
        requires release i < ListOperators::s_size<T>(this);
    {
        return ListOperators::s_safe_get<T>(this, i);
    }

    method getOrNone(i: Nat): T? {
        if(i < ListOperators::s_size<T>(this)) {
            return ListOperators::s_safe_get<T>(this, i);
        }
        else {
            return none;
        }
    }

    method getOption(i: Nat): Option<T> {
        if(i < ListOperators::s_size<T>(this)) {
            return something(ListOperators::s_safe_get<T>(this, i));
        }
        else {
            return nothing;
        }
    }

    method getTry(i: Nat, out? res: T): Bool {
        if(i < ListOperators::s_size<T>(this)) {
            res = ListOperators::s_safe_get<T>(this, i);
            return true;
        }
        else {
            return false;
        }
    }

    recursive? method single(p: recursive? pred(_: T) -> Bool): T {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);
        let lastidx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        check lastidx == idx;
        check idx < ListOperators::s_size<T>(this);

        return ListOperators::s_safe_get<T>(this, idx);
    }

    recursive? method singleOrNone(p: recursive? pred(_: T) -> Bool): T? {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);
        let lastidx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        if((idx != lastidx) \/ (idx == ListOperators::s_size<T>(this))) {
            return none;
        }
        else {
            return ListOperators::s_safe_get<T>(this, idx);
        }
    }

    recursive? method singleOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);
        let lastidx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        if((idx != lastidx) \/ (idx == ListOperators::s_size<T>(this))) {
            return nothing;
        }
        else {
            return something(ListOperators::s_safe_get<T>(this, idx));
        }
    }

    recursive? method singleTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);
        let lastidx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        if((idx != lastidx) \/ (idx == ListOperators::s_size<T>(this))) {
            return false;
        }
        else {
            res = ListOperators::s_safe_get<T>(this, idx);
            return true;
        }
    }

    recursive? method allOf(p: recursive? pred(_: T) -> Bool): Bool {
        return !ListOperators::s_hasPredCheck<T>[recursive?](this, recursive? pred(v: T) => !p[recursive?](v));
    }

    recursive? method allOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let zl = this.index();
        return !ListOperators::s_hasPredCheck<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => !p[recursive?](v.1, v.0));
    }

    recursive? method noneOf(p: recursive? pred(_: T) -> Bool): Bool {
        return !ListOperators::s_hasPredCheck<T>[recursive?](this, p);
    }

    recursive? method noneOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let zl = this.index();
        return !ListOperators::s_hasPredCheck<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));
    }

    recursive? method someOf(p: recursive? pred(_: T) -> Bool): Bool {
        return ListOperators::s_hasPredCheck<T>[recursive?](this, p);
    }

    recursive? method someOf(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let zl = this.index();
        return ListOperators::s_hasPredCheck<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));
    }

    recursive? method countIf(p: recursive? pred(_: T) -> Bool): Nat {
        return ListOperators::s_countIf_Helper<T>[recursive?](this, p);
    }

    recursive? method countIf(p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
        let zl = this.index();
        return ListOperators::s_countIf_Helper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));
    }

    method {when T grounded KeyType} contains(v: T): Bool {
        return ListKeyOperators::s_hasCheck<T>(this, v);
    }

    method containsNone(): Bool {
        return ListOperators::s_hasPredCheck<T>[recursive?](this, pred(v: T) => v === none);
    }

    method containsNothing(): Bool {
        return ListOperators::s_hasPredCheck<T>[recursive?](this, pred(v: T) => v === nothing);
    }

    method {when T grounded KeyType} count(v: T): Int {
        return ListOperators::s_countIf_Helper<T>[recursive?](this, pred(e: T) => v === e);
    }

    method countNone(): Bool {
        return ListOperators::s_countIf_Helper<T>[recursive?](this, pred(v: T) => v === none);
    }

    method countNothing(): Bool {
        return ListOperators::s_countIf_Helper<T>[recursive?](this, pred(v: T) => v === nothing);
    }

    method {when T unique Orderable} min(): T 
        requires release !this.empty();
    {
        let midx = ListArithOperators::s_minIdx_Helper<T>(this);
        return ListOperators::s_safe_get<T>(this, midx);
    }

    method {when T unique Orderable} max(): T
        requires release !this.empty();
    {
        let midx = ListArithOperators::s_maxIdx_Helper<T>(this);
        return ListOperators::s_safe_get<T>(this, midx);
    }

    method {when T unique Orderable} minOrNone(): T? {
        if(this.empty()) {
            return none;
        }
        else {
            let midx = ListArithOperators::s_minIdx_Helper<T>(this);
            return ListOperators::s_safe_get<T>(this, midx);
        }
    }

    method {when T unique Orderable} maxOrNone(): T? {
        if(this.empty()) {
            return none;
        }
        else {
            let midx = ListArithOperators::s_maxIdx_Helper<T>(this);
            return ListOperators::s_safe_get<T>(this, midx);
        }
    }

    method {when T unique Orderable} minOption(): Option<T> {
        if(this.empty()) {
            return nothing;
        }
        else {
            let midx = ListArithOperators::s_minIdx_Helper<T>(this);
            return something(ListOperators::s_safe_get<T>(this, midx));
        }
    }

    method {when T unique Orderable} maxOrOption(): Option<T> {
        if(this.empty()) {
            return nothing;
        }
        else {
            let midx = ListArithOperators::s_maxIdx_Helper<T>(this);
            return something(ListOperators::s_safe_get<T>(this, midx));
        }
    }

    method {when T unique Orderable} minTry(out? res: T): Bool {
        if(this.empty()) {
            return false;
        }
        else {
            let midx = ListArithOperators::s_minIdx_Helper<T>(this);
            res = ListOperators::s_safe_get<T>(this, midx);
            return true;
        }
    }

    method {when T unique Orderable} maxTry(out? res: T): Bool {
        if(this.empty()) {
            return false;
        }
        else {
            let midx = ListArithOperators::s_maxIdx_Helper<T>(this);
            res = ListOperators::s_safe_get<T>(this, midx);
            return true;
        }
    }

    method argMin<U unique Orderable=?>(f: recursive? fn(_: T) -> U): T 
        requires release !this.empty();
    {
        let midx = ListArithOperators::s_argminIdx_Helper<T, U>[recursive?](this, f);
        return ListOperators::s_safe_get<T>(this, midx);
    }

    method argMax<U unique Orderable=?>(f: recursive? fn(_: T) -> U): T
        requires release !this.empty();
    {
        let midx = ListArithOperators::s_argmaxIdx_Helper<T, U>[recursive?](this, f);
        return ListOperators::s_safe_get<T>(this, midx);
    }

    method argMinOrNone<U unique Orderable=?>(f: recursive? fn(_: T) -> U): T? {
        if(this.empty()) {
            return none;
        }
        else {
            let midx = ListArithOperators::s_argminIdx_Helper<T, U>[recursive?](this, f);
            return ListOperators::s_safe_get<T>(this, midx);
        }
    }

    method argMaxOrNone<U unique Orderable=?>(f: recursive? fn(_: T) -> U): T? {
        if(this.empty()) {
            return none;
        }
        else {
            let midx = ListArithOperators::s_argmaxIdx_Helper<T, U>[recursive?](this, f);
            return ListOperators::s_safe_get<T>(this, midx);
        }
    }

    method argMinOption<U unique Orderable=?>(f: recursive? fn(_: T) -> U): Option<T> {
        if(this.empty()) {
            return nothing;
        }
        else {
            let midx = ListArithOperators::s_argminIdx_Helper<T, U>[recursive?](this, f);
            return something(ListOperators::s_safe_get<T>(this, midx));
        }
    }

    method argMaxOrOption<U unique Orderable=?>(f: recursive? fn(_: T) -> U): Option<T> {
        if(this.empty()) {
            return nothing;
        }
        else {
            let midx = ListArithOperators::s_argmaxIdx_Helper<T, U>[recursive?](this, f);
            return something(ListOperators::s_safe_get<T>(this, midx));
        }
    }

    method argMinTry<U unique Orderable=?>(out? res: T, f: recursive? fn(_: T) -> U): Bool {
        if(this.empty()) {
            return false;
        }
        else {
            let midx = ListArithOperators::s_argminIdx_Helper<T, U>[recursive?](this, f);
            res = ListOperators::s_safe_get<T>(this, midx);
            return true;
        }
    }

    method argMaxTry<U unique Orderable=?>(out? res: T, f: recursive? fn(_: T) -> U): Bool {
        if(this.empty()) {
            return false;
        }
        else {
            let midx = ListArithOperators::s_argmaxIdx_Helper<T, U>[recursive?](this, f);
            res = ListOperators::s_safe_get<T>(this, midx);
            return true;
        }
    }

    method {when T unique Algebraic} sum(): T {
        return ListArithOperators::s_sum_Helper<T>(this);
    }

    recursive? method find(p: recursive? pred(_: T) -> Bool): T {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        check idx != ListOperators::s_size<T>(this);
        return ListOperators::s_safe_get<T>(this, idx);
    }

    recursive? method find(p: recursive? pred(_: T, _: Nat) -> Bool): T {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        check idx != ListOperators::s_size<T>(this);
        return ListOperators::s_safe_get<T>(this, idx);
    }

    recursive? method findOrNone(p: recursive? pred(_: T) -> Bool): T? {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return ListOperators::s_safe_get<T>(this, idx);
        }
    }

    recursive? method findOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): T? {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return ListOperators::s_safe_get<T>(this, idx);
        }
    }

    recursive? method findOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(ListOperators::s_safe_get<T>(this, idx));
        }
    }

    recursive? method findOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<T> {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(ListOperators::s_safe_get<T>(this, idx));
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = ListOperators::s_safe_get<T>(this, idx);
            return true;
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = ListOperators::s_safe_get<T>(this, idx);
            return true;
        }
    }

    recursive? method findLast(p: recursive? pred(_: T) -> Bool): T {
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        check idx != ListOperators::s_size<T>(this);
        return ListOperators::s_safe_get<T>(this, idx);
    }

    recursive? method findLast(p: recursive? pred(_: T, _: Nat) -> Bool): T {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        check idx != ListOperators::s_size<T>(this);
        return ListOperators::s_safe_get<T>(this, idx);
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T) -> Bool): T? {
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return ListOperators::s_safe_get<T>(this, idx);
        }
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): T? {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return ListOperators::s_safe_get<T>(this, idx);
        }
    }

    recursive? method findLastOption(p: recursive? pred(_: T) -> Bool): Option<T> {
        let idx =  ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(ListOperators::s_safe_get<T>(this, idx));
        }
    }

    recursive? method findLastOption(d: T, p: recursive? pred(_: T, _: Nat) -> Bool): Option<T> {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(ListOperators::s_safe_get<T>(this, idx));
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T) -> Bool): Bool {
        let idx =  ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = ListOperators::s_safe_get<T>(this, idx);
            return true;
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = ListOperators::s_safe_get<T>(this, idx);
            return true;
        }
    }

    recursive? method findIndexOf(p: recursive? pred(_: T) -> Bool): Nat {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        check idx != ListOperators::s_size<T>(this);
        return idx;
    }

    recursive? method findIndexOf(p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        check idx != ListOperators::s_size<T>(this);
        return idx;
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T) -> Bool): Nat? {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfOption(p: recursive? pred(_: T) -> Bool): Option<Nat> {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    recursive? method findIndexOfOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<Nat> {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T) -> Bool): Bool {
        let idx = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T) -> Bool): Nat {
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        check idx != ListOperators::s_size<T>(this);
        return idx;
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        check idx != ListOperators::s_size<T>(this);
        return idx;
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T) -> Bool): Nat? {
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfLastOption(p: recursive? pred(_: T) -> Bool): Option<Nat> {
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    recursive? method findIndexOfLastOption(p: recursive? pred(_: T, _: Nat) -> Bool): Option<Nat> {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T) -> Bool): Bool {
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<T>[recursive?](this, p);

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOfLast_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    method {when T grounded KeyType} indexOf(v: T): Nat {
        let idx = ListOperators::s_findIndexOf_KeyHelper<T>(this, v);

        check idx != ListOperators::s_size<T>(this);
        return idx;
    }

    method {when T grounded KeyType} indexOfOrNone(v: T): Nat? {
        let idx = ListOperators::s_findIndexOf_KeyHelper<T>(this, v);

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return idx;
        }
    }

    method {when T grounded KeyType} indexOfOption(v: T): Option<Nat> {
        let idx = ListOperators::s_findIndexOf_KeyHelper<T>(this, v);

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    method {when T grounded KeyType} indexOfTry(out? res: T, v: T): Bool {
        let idx = ListOperators::s_findIndexOf_KeyHelper<T>(this, v);

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    method {when T grounded KeyType} indexOfLast(v: T): Nat {
        let idx = ListKeyOperators::s_findIndexOfLast_KeyHelper<T>(this, v);

        check idx != ListOperators::s_size<T>(this);
        return idx;
    }

    method {when T grounded KeyType} indexOfLastOrNone(v: T): Nat? {
        let idx = ListKeyOperators::s_findIndexOfLast_KeyHelper<T>(this, v);

        if(idx == ListOperators::s_size<T>(this)) {
            return none;
        }
        else {
            return idx;
        }
    }

    method {when T grounded KeyType} indexOfLastOption(v: T): Option<Nat> {
        let idx = ListKeyOperators::s_findIndexOfLast_KeyHelper<T>(this, v);

        if(idx == ListOperators::s_size<T>(this)) {
            return nothing;
        }
        else {
            return something(idx);
        }
    }

    method {when T grounded KeyType} indexOfLastTry(out? res: T, v: T): Bool {
        let idx = ListKeyOperators::s_findIndexOfLast_KeyHelper<T>(this, v);

        if(idx == ListOperators::s_size<T>(this)) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method filter(p: recursive? pred(_: T) -> Bool): List<T> {
        return ListOperators::s_filter_Helper<T>[recursive?](this, p);
    }

    recursive? method filter(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let zl = this.index();
        return ListOperators::s_filter_Helper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));
    }

    method filterType<U>(): List<U> {
        return this.filter(pred(v: T) => v.is<U>()).map<U>(fn(v: T): U => ListOperators::s_safeAs<T, U>(v));
    }

    method filterSome(): List<T!Some> {
        return this.filter(pred(v: T) => v !== none).map<T!Some>(fn(v: T): T!Some => ListOperators::s_safeAs<T, T!Some>(v));
    }

    method {when T unique IOption} filterSomething(): List<T!IOptionT> {
        return this.filter(pred(v: T) => v !== nothing).map<T!IOptionT>(fn(v: T): U => ListOperators::s_safeAs<Option<T!IOptionT>>(v).value());
    }

    method castType<U>(): List<U> {
        return this.map<U>(fn(v: T): U => v.as<U>());
    }

    method slice(start?: Nat=0n, end?: Nat=ListOperators::s_size<T>(this)): List<T> 
        requires release List<T>::s_sliceRangeInBounds(this, start, end);
    {
        return ListOperators::s_slice_Helper<T>(this, s, e);
    }

    method removeFirst(k: Nat): List<T> 
        requires release k <= ListOperators::s_size<T>(this);
    {
        return ListOperators::s_slice_Helper<T>(this, k, ListOperators::s_size<T>(this));
    }

    method removeLast(k: Nat): List<T> 
        requires release k <= ListOperators::s_size<T>(this);
    {
        return ListOperators::s_slice_Helper<T>(this, 0n, ListOperators::s_size<T>(this) - k);
    }

    recursive? method takeWhile(p: recursive? pred(_: T) -> Bool): List<T>  {
        let lpos = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, recursive? pred(v: T) => !p[recursive?](v));

        return ListOperators::s_slice_Helper<T>(this, 0n, lpos);
    }

    recursive? method takeWhile(p: recursive? pred(_: T, _: Nat) -> Bool): List<T>  {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => !p[recursive?](v.1, v.0));

        return ListOperators::s_slice_Helper<T>(this, 0n, lpos);
    }

    recursive? method discardWhile(p: recursive? pred(_: T) -> Bool): List<T> {
        let lpos = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, recursive? pred(v: T) => !p[recursive?](v));

        return ListOperators::s_slice_Helper<T>(this, lpos, end - lpos);
    }

    recursive? method discardWhile(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => !p[recursive?](v.1, v.0));

        return ListOperators::s_slice_Helper<T>(this, lpos, end - lpos);
    }

    recursive? method takeUntil(p: recursive? pred(_: T) -> Bool): List<T> {
        let lpos = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        return ListOperators::s_slice_Helper<T>(this, lpos, end - lpos);
    }

    recursive? method takeUntil(p: recursive? pred(_: T, _: Nat) -> Bool): List<T> {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        return ListOperators::s_slice_Helper<T>(this, lpos, end - lpos);
    }

    recursive? method discardUntil(p: recursive? pred(_: T) -> Bool): List<T>  {
        let lpos = ListOperators::s_findIndexOf_PredicateHelper<T>[recursive?](this, p);

        return ListOperators::s_slice_Helper<T>(this, lpos, end - lpos);
    }

    recursive? method discardUntil(p: recursive? pred(_: T, _: Nat) -> Bool): List<T>  {
        let zl = this.index();
        let idx = ListOperators::s_findIndexOf_PredicateHelper<[Nat, T]>[recursive?](zl, recursive? pred(v: [Nat, T]) => p[recursive?](v.1, v.0));

        return ListOperators::s_slice_Helper<T>(this, lpos, end - lpos);
    }

    method {when T grounded KeyType} uniqueKey(): List<T> {
        return ListOperators::s_unique_Helper<T>(this, pred(a: T, b: T): Bool => KeyType::equal(a === b));
    }

    recursive? method unique(eq: recursive? pred(_: T, _: T) -> Bool): List<T> {
       return ListOperators::s_unique_Helper<T>[recursive?](this, eq);
    }

    method reverse(): List<T> {
        return ListOperators::s_reverse_Helper<T>(this);
    }

    recursive? method map<U=?>(f: recursive? fn(_: T) -> U): List<U>  {
        return ListOperators::s_map_Helper<T, U>[recursive?](this, f);
    }

    recursive? method map<U=?>(f: recursive? fn(_: T, _: Nat) -> U): List<U>  {
        let zl = this.index();
        return ListOperators::s_map_Helper<[Nat, T], U>[recursive?](this, recursive? fn(v: [Nat, T]): U => f[recursive?](v.1, v.0));
    }

    recursive? method mapNone<U=?>(f: recursive? fn(_: T!Some) -> U): List<U>  {
        return ListOperators::s_map_Helper<T, U>[recursive?](this, recursive? fn(v: T): U => {
            if(v === none) {
                return none;
            }
            else {
                return f[recursive?](v);
            }
        });
    }

    recursive? method mapNone<U=?>(f: recursive? fn(_: T, _: Nat) -> U): List<U>  {
        let zl = this.index();

        return ListOperators::s_map_Helper<[Nat, T], U>[recursive?](this, recursive? fn(v: [Nat, T]): U => {
            let vt = v.1;
            if(vt === none) {
                return none;
            }
            else {
                return f[recursive?](vt, v.0);
            }
        });
    }

    recursive? method {when T unique IOption} mapOption<U=?>(f: recursive? fn(_: T!IOptionT) -> U): List<U>  {
        return ListOperators::s_map_Helper<T, U>[recursive?](this, recursive? fn(v: T): U => {
            if(v === nothing) {
                return nothing;
            }
            else {
                return f[recursive?](v.value());
            }
        });
    }

    recursive? method {when T unique IOption} mapOption<U=?>(f: recursive? fn(_: T!IOptionT, _: Nat) -> U): List<U>  {
        let zl = this.index();

        return ListOperators::s_map_Helper<[Nat, T], U>[recursive?](this, recursive? fn(v: [Nat, T]): U => {
            let vt = v.1;
            if(vt === nothing) {
                return nothing;
            }
            else {
                return f[recursive?](vt.value(), v.0);
            }
        });
    }

    method {when T grounded KeyType} project<U=?>(m: Map<T, U>): List<U> {
        return ListOperators::s_map_Helper<T, U>(this, fn(v: T): U => {
            return m.get(v);
        });
    }

    method {when T grounded KeyType} projectOrNone<U=?>(m: Map<T, U>): List<U?> {
        return ListOperators::s_map_Helper<T, U?>(this, fn(v: T): U? => {
            return m.getOrNone(v);
        });
    }

    method {when T grounded KeyType} projectImage<U=?>(m: Map<T, U>): List<U> {
        return this.filter(pred(v: T) => m.has(v)).map<U>(fn(v: T): U => m.get(v));
    }

    recursive? method join<U=?>(ol: List<U>, p: recursive? fn(_: T, _: U) -> Bool): List<[T, U]> {
        return ListOperators::s_join_Helper<T, U>[recursive?](this, ol, p);
    }

    recursive? method joinGroup<U=?>(ol: List<U>, p: recursive? fn(_: T, _: U) -> Bool): List<[T, List<U>]> {
        return ListOperators::s_map_Helper<T, [T, List<U>]>[recursive?](this, recursive? fn(v: T): [T, List<U>] => {
            let ul = ListOperators::s_filter_Helper<U>[recursive?](ol, pred(u: U) => p[recursive?](v, u));
            return [v, ul];
        });
    }

    method append(l: List<T>): List<T> {
        return ListOperators::s_concat2_Helper<T>(this, l);
    }

    method prepend(l: List<T>): List<T> {
        return ListOperators::s_concat2_Helper<T>(l, this);
    }

    recursive? method partition<K grounded KeyType=?>(pf: recursive? fn(_: T) -> K): Map<K, List<T>> {
        let allkeys = ListOperators::s_map_Helper<T, K>[recursive?](this, pf);
        let ukeys = ListOperators::s_unique_Helper<K>(allkeys);

        let kopts = allkeys.zip(this);
        let classes = ListOperators::s_map_Helper<K, [K, List<T>]>(ukeys, fn(k: K): [K, List<T>] => {
            let pl = ListOperators::s_filter_Helper<[K, T]>(kopts, pred(v: [K, T]) => k === v.0);
            let tl = ListOperators::s_map_Helper<[K, T], T>(pl, fn(vv: [K, T]): T => vv.1);

            return [k, tl];
        });

        return Map<K, T>@{...classes};
    }

    recursive? method sort(cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        return ListOperators::s_sort_Helper<T>[recursive?](this, cmp);
    }

    method pushBack(v: T): List<T> {
        return ListOperators::s_concat2_Helper(this, List<T>@{v});
    }

    method pushFront(v: T): List<T> {
        return ListOperators::s_concat2_Helper(List<T>@{v}, this);
    }

    method popBack(): List<T> 
        requires release !ListOperators::s_empty<T>(this);
    {
        return ListOperators::s_slice_Helper<T>(this, 0, ListOperators::s_size<T>(this) - 1);
    }

    method popFront(): List<T>
        requires release !ListOperators::s_empty<T>(this);
    {
        return ListOperators::s_slice_Helper<T>(this, 1, ListOperators::s_size<T>(this));
    }

    method set(i: Nat, v: T): List<T> 
        requires release i < ListOperators::s_size<T>(this);
    {
        let count = ListOperators::s_size<T>(this);
        let vl = List<T>@{v};

        if(count == 1) {
            return vl;
        }
        else {
            if(i == 0) {
                return ListOperators::s_concat2_Helper<T>(vl, ListOperators::s_slice_Helper<T>(this, 1, count));
            }
            elif(i == count - 1) {
                return ListOperators::s_concat2_Helper<T>(ListOperators::s_slice_Helper<T>(this, 0, count - 1), vl);
            }
            else {
                let front = ListOperators::s_slice_Helper<T>(this, 0, i);
                let back = ListOperators::s_slice_Helper<T>(this, i + 1, count);

                return ListOperators::s_concat2_Helper<T>(ListOperators::s_concat2_Helper<T>(front, vl), back);
            }
        } 
    }

    method remove(i: Nat): List<T>
        requires release i < ListOperators::s_size<T>(this);
    {
        let count = ListOperators::s_size<T>(this);

        if(count == 1) {
            return List<T>@{};
        }
        else {
            if(i == 0) {
                return ListOperators::s_slice_Helper<T>(this, 1, count);
            }
            elif(i == count - 1) {
                return ListOperators::s_slice_Helper<T>(this, 0, count - 1);
            }
            else {
                let front = ListOperators::s_slice_Helper<T>(this, 0, i);
                let back = ListOperators::s_slice_Helper<T>(this, i + 1, count);

                return ListOperators::s_concat2_Helper<T>(front), back);
            }
        } 
    }

    //
    //TODO: ref versions of the add/remove/set operators
    //

    //
    //TODO: Convert to Map<K, V> and Set<T> operations
    //
}
