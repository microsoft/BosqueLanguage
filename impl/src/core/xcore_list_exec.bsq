//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if EXEC_LIBS
internal function __list_literal_cons0<T>(): ListRepr<T> {
    return none;
}

internal function __list_literal_cons1<T>(v1: T): ListRepr<T> {
    let udf = s_undef<T>();
    return PartialVector<T>{Mask::s_init_k(1), v1, udf, udf, udf};
}

internal function __list_literal_cons2<T>(v1: T, v2: T): ListRepr<T> {
    let udf = s_undef<T>();
    return PartialVector<T>{Mask::s_init_k(2), v1, v2, udf, udf};
}

internal function __list_literal_cons3<T>(v1: T, v2: T, v3: T): ListRepr<T> {
    let udf = s_undef<T>();
    return PartialVector<T>{Mask::s_init_k(3), v1, v2, v3, udf};
}

internal function __list_literal_cons4<T>(v1: T, v2: T, v3: T, v4: T): ListRepr<T> {
    return PartialVector<T>{Mask::s_init_k(4), v1, v2, v3, v4};
}

internal function __list_literal_cons_add1<T>(ltp: [ListTree<T>?, ListTree<T>?], v1: T): [ListTree<T>?, rr: ListTree<T>?] {
    let ll = ltp.0;
    let rr = ltp.1;
    if(ll === none) {
        return [__list_literal_cons1<T>(v1), none];
    }
    elif(rr === none) {
        return [ll, __list_literal_cons1<T>(v1)];
    }
    else {
        let nrr = ListOps::s_append<T>(rr, __list_literal_cons1<T>(v1));
        if(ListOps::s_size<T>(ll) > ListOps::s_size<T>(nrr)) {
            return [ll, nrr];
        }
        else {
            let njl = ListOps::s_append<T>(ll, nrr);
            return [njl, none];
        }
    }
}

internal function __list_literal_cons_add2<T>(ltp: [ListTree<T>?, ListTree<T>?], v1: T, v2: T): [ListTree<T>?, rr: ListTree<T>?] {
    let ll = ltp.0;
    let rr = ltp.1;
    if(ll === none) {
        return [__list_literal_cons2<T>(v1, v2), none];
    }
    elif(rr === none) {
        return [ll, __list_literal_cons2<T>(v1, v2)];
    }
    else {
        let nrr = ListOps::s_append<T>(rr, __list_literal_cons2<T>(v1, v2));
        if(ListOps::s_size<T>(ll) > ListOps::s_size<T>(nrr)) {
            return [ll, nrr];
        }
        else {
            let njl = ListOps::s_append<T>(ll, nrr);
            return [njl, none];
        }
    }
}

internal function __list_literal_cons_add3<T>(ltp: [ListTree<T>?, ListTree<T>?], v1: T, v2: T, v3: T): [ListTree<T>?, rr: ListTree<T>?] {
    let ll = ltp.0;
    let rr = ltp.1;
    if(ll=== none) {
        return [__list_literal_cons3<T>(v1, v2, v3), none];
    }
    elif(rr === none) {
        return [ll, __list_literal_cons3<T>(v1, v2, v3)];
    }
    else {
        let nrr = ListOps::s_append<T>(rr, __list_literal_cons3<T>(v1, v2, v3));
        if(ListOps::s_size<T>(ll) > ListOps::s_size<T>(nrr)) {
            return [ll, nrr];
        }
        else {
            let njl = ListOps::s_append<T>(ll, nrr);
            return [njl, none];
        }
    }
}

internal function __list_literal_cons_add4<T>(ltp: [ListTree<T>?, ListTree<T>?], v1: T, v2: T, v3: T, v4: T): [ListTree<T>?, rr: ListTree<T>?] {
    let ll = ltp.0;
    let rr = ltp.1;
    if(ll === none) {
        return [__list_literal_cons4<T>(v1, v2, v3, v4), none];
    }
    elif(rr === none) {
        return [ll, __list_literal_cons4<T>(v1, v2, v3, v4)];
    }
    else {
        let nrr = ListOps::s_append<T>(rr, __list_literal_cons4<T>(v1, v2, v3, v4));
        if(ListOps::s_size<T>(ll) > ListOps::s_size<T>(nrr)) {
            return [ll, nrr];
        }
        else {
            let njl = ListOps::s_append<T>(ll, nrr);
            return [njl, none];
        }
    }
}

internal function __list_literal_cons_add_done<T>(ltp: [ListTree<T>?, ListTree<T>?]): ListRepr<T> {
    let ll = ltp.0;
    let rr = ltp.1;
    if(rr === none) {
        return ll;
    }
    else {
        return ListOps::s_append<T>(ll, rr);
    }
}

internal function __list_literal_cons_append<T>(l1: ListRepr<T>, l2: ListRepr<T>): ListRepr<T> {
    return ListOps::s_append(l1, l2);
}

internal entity ListOps provides Some {
    function s_size_ne<T>(l: ListRepr<T>): Nat = s_size_ne;

    recursive? function s_reduce_ne<T, U>(l: ListRepr<T>, iv: U, f: recursive? fn(_: U, _: T) -> U): U = s_reduce_ne;
    recursive? function s_reduce_idx_ne<T, U>(l: ListRepr<T>, iv: U, f: recursive? fn(_: U, _: T, _: Nat) -> U): U = s_reduce_idx_ne;

    function s_range_ne<T unique Int | Nat>(start: T, end: T, inc: T, count: T): ListRepr<T> = s_range_ne;
    function s_fill_ne<T>(count: Nat, v: T): ListRepr<T> = s_fill_ne;

    function s_append_ne<T>(ListRepr<T> ll, ListRepr<T> rr): ListRepr<T> = s_append_ne;

    function s_slice_start_ne<T>(l: ListRepr<T>, start: Nat): ListRepr<T> = s_slice_start;
    function s_slice_end_ne<T>(l: ListRepr<T>, end: Nat): ListRepr<T> = s_slice_end;
    function s_safe_get_ne<T>(l: ListRepr<T>, i: Nat): T = s_safe_get;

    recursive? function s_find_pred_ne<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat = s_find_pred_ne;
    recursive? function s_find_pred_idx_ne<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat = s_find_pred_idx_ne;
    recursive? function s_find_pred_last_ne<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat = s_find_pred_last_ne;
    recursive? function s_find_pred_last_idx_ne<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat = s_find_pred_last_idx_ne;

    recursive? function s_filter_pred_ne<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): List<T> = s_filter_pred_ne;
    recursive? function s_filter_pred_idx_ne<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): List<T> = s_filter_pred_idx_ne;

    recursive? function s_map_ne<T, U>(l: ListRepr<T>, p: recursive? pred(_: T) -> U): List<U> = s_map_ne;
    recursive? function s_map_idx_ne<T, U>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> U): List<U> = s_map_idx_ne;
    recursive? function s_map_sync_ne<T, U, V>(l1: ListRepr<T>, l2: ListRepr<U>, f: recursive? fn(_: T, _: U) -> V): ListRepr<V> = s_map_sync_ne

    function s_empty<T>(l: ListRepr<T>): Bool {
        return l === none;
    }

    function s_size<T>(l: ListRepr<T>): Nat
    {
        if(l === none) {
            return 0;
        }
        else {
            return ListOps::s_size_ne<T>(l);
        }
    }

    function s_range<T unique Int | Nat>(start: T, end: T, inc: T, count: Nat): ListRepr<T> {
        if(start == end) {
            return none;
        }
        else {
            return ListOps::s_range_ne<T>(start, end, inc, count);
        }
    }
    
    function s_fill<T>(count: Nat, v: T): ListRepr<T> {
        if(count == 0n) {
            return none;
        }
        else {
            return ListOps::s_fill_ne<T>(count, v);
        }
    }

    function s_zip_index<T>(l: ListRepr<T>): ListRepr<[Nat, T]> {
        return ListOps::s_map_idx<T, [Nat, T]>(l, fn(v: T, idx: Nat) => [idx, v]);
    }

    function s_zip<T, U>(l1: ListRepr<T>, l2: ListRepr<U>): ListRepr<[T, U]> {
        if(l1 == none) {
            return none;
        }
        else {
            return ListOps::s_map_sync_ne<T, U, [T, U]>(l1, l2, fn(v1: T, v2: U) => [v1, v2]);
        }
    }

    function s_append(l: ListRepr<T>, r: ListRepr<T>): ListRepr<T> {
        if(/\(l === none, r === none)) {
            return none;
        }
        elif(l === none) {
            return r;
        }
        elif(r === none) {
            return l;
        }
        else {
            return ListOps::s_append_ne<T>(l, r);
        }
    }

    recursive function s_concatrec<T>(ll: List<List<T>>, start: Nat, end: Nat): List<T> {
        let count = end - start;
        if(count == 1) {
            return ListOps::s_safe_get<List<T>>(ll, start);
        }
        else {
            let split = count / 2n;
            let la = List<T>::s_concat(ll, start, start + split);
            let ra = List<T>::s_concat(lr, start + split, end);

            return ListOps::s_append<T>(la, ra);
        }
    }

    function s_concat(ll: List<List<T>>): List<T> {
        let count = ListOps::s_size<List<T>>(ll);
        if(count == 1) {
            return ListOps::s_safe_get<List<T>>(ll, start);
        }
        else {
            let split = count / 2n;
            let la = List<T>::s_concat(ll, 0, split);
            let ra = List<T>::s_concat(lr, split, end);

            return ListOps::s_append<T>(la, ra);
        }
    }

    function s_slice_start(l: ListRepr<T>, start: Nat): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(start == 0) {
            return l;
        }
        else {
            return ListOps::s_slice_start_ne<T>(l, start);
        }
    }

    function s_slice_end(l: ListRepr<T>, end: Nat): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(end == 0) {
            return l;
        }
        else {
            return ListOps::s_slice_end_ne<T>(l, end);
        }
    }

    function s_safe_get<T>(l: ListRepr<T>, i: Nat): T {
        ListOps::s_safe_get_ne<T>(l, i);
    }

    recursive? function s_has_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        else {
            return ListOps::s_find_pred_ne<T>[recursive?](l, p) != ListOps::s_size<T>(l);
        }
    }

    recursive? function s_has_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        else {
            return ListOps::s_find_pred_idx_ne<T>[recursive?](l, p) != ListOps::s_size<T>(l);
        }
    }

    recursive? function s_find_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        else {
            return ListOps::s_find_pred_ne<T>[recursive?](l, p);
        }
    }

    recursive? function s_find_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        else {
            return ListOps::s_find_pred_idx_ne<T>[recursive?](l, p);
        }
    }

    recursive? function s_find_last_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        else {
            return ListOps::s_find_pred_last_ne<T>[recursive?](l, p);
        }
    }

    recursive? function s_find_last_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        else {
            return ListOps::s_find_pred_last_idx_ne<T>[recursive?](l, p);
        }
    }

    recursive? function s_filter_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): ListRepr<T> {
         if(l === none) {
            return none;
        }
        else {
            return ListOps::s_filter_pred_ne<T>[recursive?](l, p);
        }
    }

    recursive? function s_filter_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        else {
            return ListOps::s_filter_pred_idx_ne<T>[recursive?](l, p);
        }
    }

    recursive? function s_map<T, U>(l: ListRepr<T>, f: recursive? fn(_: T) -> U): ListRepr<U> {
        if(l === none) {
            return none;
        }
        else {
            return ListOps::s_map_ne<T, U>[recursive?](l, f);
        }
    }

    recursive? function s_map_idx<T, U>(l: ListRepr<T>, f: recursive? fn(_: T, _: Nat) -> U): ListRepr<U> {
        if(l === none) {
            return none;
        }
        else {
            return ListOps::s_map_idx_ne<T, U>[recursive?](l, f);
        }
    }

    recursive? function s_min_arg<T, U unique Orderable>(l: ListRepr<T>, f: recursive? fn(v: T) -> U): Nat {
        let u0 = f[recursive?](ListOps::s_safe_get_ne<T>(l, 0));
        let rr = ListOps::s_reduce_idx_ne<T, [Nat, U]>[recursive?](l, [0, u0], recursive? fn(acc: [Nat, U], v: T, idx: Nat): U => {
            let ui = f[recursive?](v);
            if(ui < acc.1) {
                return [idx, ui];
            }
            else {
                return acc;
            }
        });
    }

    recursive? function s_max_arg<T, U unique Orderable>(l: ListRepr<T>, f: recursive? fn(v: T) -> U): Nat {
        let u0 = f[recursive?](ListOps::s_safe_get_ne<T>(l, 0));
        let rr = ListOps::s_reduce_idx_ne<T, [Nat, U]>[recursive?](l, [0, u0], recursive? fn(acc: [Nat, U], v: T, idx: Nat): U => {
            let ui = f[recursive?](v);
            if(ui > acc.1) {
                return [idx, ui];
            }
            else {
                return acc;
            }
        });
    }

    function s_sum<T unique Algebraic>(l: ListRepr<T>): T {
        if(l === none) {
            return T::zero;
        }
        else {
            let acc = ListOps::s_safe_get_ne<T>(l, 0);
            let rr = ListOps::s_reduce_ne<T, T>(l, acc, fn(acc: T, v: T): T => acc + v);
        }
    }

    recursive? function s_sort<T>(l: ListRepr<T>, cmp: recursive? pred(_: T, _: T) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        else {
            return l.sort[recursive](cmp);
        }
    }

    recursive? function s_unique_from_sorted<T>(l: ListRepr<T>, eq: recursive? pred(_: T, _: T) -> Bool): ListRepr<T> {
        return ListOps::s_filter_pred_idx<T>(l, recursive? pred(v: T, idx: Nat): Bool => {
            if(idx == 0n) {
                return true;
            }
            else {
                let prev = ListOps::s_safe_get<T>(l, idx - 1n);
                return !eq[recursive?](prev, v);
            }
        });
    }
    
    function s_reverse(l: ListRepr<T>): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            return PartialVector<T>::s_reverse(l);
        }
        else {
            return l.reverse[recursive]();
        }
    }

    recursive? function s_reduce<T, U>(init: U, op: recursive? fn(_: U, _: T) -> U): U {
        if(l === none) {
            return init;
        }
        else {
            let acc = ListOps::s_safe_get_ne<T>(l, 0);
            xxxx;
            let rr = ListOps::s_reduce_ne<T, U>(l, acc, fn(acc: U, v: T): T => acc + v);
        }

        elif(l.is<PartialVector<T>>()) {
            return l.s_reduce_fn<U>[recursive?](init, op);
        }
        else {
            return l.reduce<U>[recursive](init, op);
        }
    }

    recursive? function s_reduce_idx<T, U>(init: U, op: recursive? fn(_: U, _: T, _: Nat) -> U): U {
        if(l === none) {
            return init;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.s_reduce_fn_idx<U>[recursive?](init, 0n, op);
        }
        else {
            return l.reduce_idx<U>[recursive](init, 0n, op);
        }
    }

    recursive? function s_transduce<T, E, U>(env: E, op: recursive? fn(_: E, _: T) -> U, E): ListRepr<U>, E {
        if(l === none) {
            return none, env;
        }
        else {
            var nl: ListRepr<U>;
            var nenv: E;

            if(l.is<PartialVector<T>>()) {
                nl, nenv = l.s_transduce_fn<E, U>[recursive?](env, op);
            }
            else {
                nl, nenv = l.transduce<E, U>[recursive](env, op);
            }

            return nl, nenv;
        }
    }
    }

    recursive? function s_transduce_idx<T, E, U>(env: E, op: recursive? fn(_: E, _: T, _: Nat) -> U, E): ListRepr<U>, E {
        if(l === none) {
            return none, env;
        }
        else {
            var nl: ListRepr<U>;
            var nenv: E;

            if(l.is<PartialVector<T>>()) {
                nl, nenv = l.s_transduce_fn_idx<E, U>[recursive?](env, 0n, op);
            }
            else {
                nl, nenv = l.transduce_idx<E, U>[recursive](env, 0n, op);
            }

            return nl, nenv;
        }
    }
}

__internal entity PartialVector4<T> provides Some {
    //Dummy placeholder
}

__internal entity PartialVector8<T> provides Some {
    //Dummy placeholder
}

__internal entity ListTree<T> provides Some {
    //Dummy placeholder
}

internal typedef ListRepr<T> = None | PartialVector4<T> | PartialVector8<T> | ListTree<T>;

#endif
