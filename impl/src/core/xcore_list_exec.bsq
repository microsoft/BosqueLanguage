//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

#if EXEC_LIBS
__internal entity ListOps provides Some {
    __assume_safe function s_safeAs<T, U>(v: T): U # list_safeas

    function s_empty(l: ListRepr<T>): Nat {
        return l === none;
    }

    function s_size<T>(l: ListRepr<T>): Nat {
        if(l === none) {
            return 0;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.count();
        }
        else {
            return l.count;
        }
    }

    function s_range<T unique Int | Nat>(start: T, end: T, inc: T, zero: T): ListRepr<Int> {
        if(start == end) {
            return none;
        }
        else {
            let count = end - start;
            if(count <= 4) {
                return PartialVector<T>::s_range(start, end, inc, zero);
            }
            else {
                return ListTree<T>::range[recursive](start, end, inc);
            }
        }
    }
    
    function s_fill<T>(count: Nat, v: T): ListRepr<T> {
        if(count == 0n) {
            return none;
        }
        else {
            if(count <= 4n) {
                return PartialVector<T>::s_fill(count, v);
            }
            else {
                return ListTree<T>::fill[recursive](count, v);
            }
        }
    }

    function s_zip_index<T>(l: ListRepr<T>): ListRepr<[Nat, T]> {
        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.s_zip_index(0);
        }
        else {
            return l.zip_index[recursive](0n);
        }
    }

    function s_zip<T, U>(l1: ListRepr<T>, l2: ListRepr<U>): ListRepr<[T, U]> {
        if(l === none) {
            return none;
        }
        elif(/\(l1.is<PartialVector<T>>(), l2.is<PartialVector<U>>())) {
            return l1.s_zip<U>(l2);
        }
        else {
            let ll1 = ListOps::s_safeAs<ListRepr<T>, ListTree<T>>(l1);
            let ll2 = ListOps::s_safeAs<ListRepr<U>, ListTree<U>>(l2);

            return ll1.zip<U>[recursive](ll2, 0);
        }
    }

    function s_append(l: ListRepr<T>, r: ListRepr<T>): ListRepr<T> {
        if(/\(l === none, r === none)) {
            return none;
        }
        elif(l === none) {
            return r;
        }
        elif(r === none) {
            return l;
        }
        else {
            return ListTree<T>::append(l, r);
        }
    }

    function s_slice_start(l: ListRepr<T>, start: Nat): ListRepr<T> {
        if(start == 0) {
            return l;
        }

        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            if(start == l.count()) {
                return none;
            }
            else {
                return PartialVector<T>::s_slice_start(l, start);
            }
        }
        else {
            if(start == l.count()) {
                return none;
            }
            else {
                return l.slice_start[recursive](start);
            }
        }
    }

    function s_slice_end(l: ListRepr<T>, end: Nat): ListRepr<T> {
        if(end == 0) {
            return none;
        }

        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            if(end == l.count()) {
                return l;
            }
            else {
                return PartialVector<T>::s_slice_end(l, end);
            }
        }
        else {
            if(end == l.count()) {
                return l;
            }
            else {
                return l.slice_end[recursive](end);
            }
        }
    }

    function s_safe_get<T>(l: ListRepr<T>, i: Nat): T {
        if(l.is<PartialVector<T>>()) {
            return PartialVector<T>::s_safe_get(l, i);
        }
        else {
            return ListOps::s_safeAs<ListRepr<T>, ListTree<T>>(l).safe_get[recursive](i);
        }
    }

    recursive? function s_has_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.find_pred[recursive?](p).some_true();
        }
        else {
            return l.has_pred[recursive](p);
        }
    }

    recursive? function s_has_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.find_pred_idx[recursive?](0, p).some_true();
        }
        else {
            return l.has_pred_idx[recursive](0, p);
        }
    }

    recursive? function s_find_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.find_pred[recursive?](p).min();
        }
        else {
            return l.find_pred[recursive](0, p);
        }
    }

    recursive? function s_find_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.find_pred_idx[recursive?](0, p).min();
        }
        else {
            return l.find_pred_idx[recursive](0, p);
        }
    }

    recursive? function s_find_last_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.find_last_pred[recursive?](p).max();
        }
        else {
            return l.find_last_pred[recursive](0, p);
        }
    }

    recursive? function s_find_last_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.find_last_pred_idx[recursive?](0, p).max();
        }
        else {
            return l.find_last_pred_idx[recursive](0, p);
        }
    }

    recursive? function s_filter_pred<T>(p: recursive? pred(_: T) -> Bool): ListRepr<T> {
         if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            let fm = l.apply_pred[recursive?](p);
            if(fm.empty()) {
                return none;
            }
            else {
                return PartialVector<T>::s_select(l, fm);
            }
        }
        else {
            return l.filter_pred_idx[recursive](0, p);
        }
    }

    recursive? function s_filter_pred_idx<T>(p: recursive? pred(_: T, _: Nat) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            let fm = l.apply_pred_idx[recursive?](0, p);
            if(fm.empty()) {
                return none;
            }
            else {
                return PartialVector<T>::s_select(l, fm);
            }
        }
        else {
            return l.filter_pred_idx[recursive](0, p);
        }
    }

    recursive? function s_map<T, U>(l: ListRepr<T>, f: recursive? fn(_: T) -> U): ListRepr<U> {
        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.map[recursive?](f);
        }
        else {
            return l.map[recursive](f);
        }
    }

    recursive? function s_map_idx<T, U>(l: ListRepr<T>, f: recursive? fn(_: T, _: U) -> Bool): ListRepr<U> {
        if(l === none) {
            return none;
        }
        elif(l.is<PartialVector<T>>()) {
            return l.map_idx[recursive?](0, f);
        }
        else {
            return l.map_idx[recursive](0, f);
        }
    }

    recursive? function s_min_arg<T, U unique Orderable>(l: ListRepr<T>, f: recursive? fn(v: T) -> U): Nat {
        if(l.is<PartialVector1<T>>()) {
            return 0n;
        }
        elif(l.is<PartialVector2<T>>()) {
            if(f[recursive?](l.v1) < f[recursive?](l.v0)) {
                return 1n;
            }
            else {
                return 0n;
            }
        }
        elif(l.is<PartialVector3<T>>()) {
            let lt21 = f[recursive?](l.v2) < f[recursive?](l.v1);
            let lt20 = f[recursive?](l.v2) < f[recursive?](l.v0);
            let lt10 = f[recursive?](l.v1) < f[recursive?](l.v0);
            if(/\(lt21, lt20)) {
                return 2n;
            }
            elif(lt10) {
                return 1n;
            }
            else {
                return 0n
            }
        }
        elif(l.is<PartialVector4<T>>()) {
            let lt21 = f[recursive?](l.v2) < f[recursive?](l.v1);
            let lt20 = f[recursive?](l.v2) < f[recursive?](l.v0);
            let lt10 = f[recursive?](l.v1) < f[recursive?](l.v0);
            if(/\(lt21, lt20)) {
                return 2n;
            }
            elif(lt10) {
                return 1n;
            }
            else {
                return 0n
            }
        }
        else {
            return ListOps::s_safeAs<ListRepr<T>, RecList<T>>(l).min_arg[recursive?](f);
        }
    }

    recursive? function s_max_arg<T, U unique Orderable>(l: ListRepr<T>, f: recursive? fn(v: T) -> U): Nat {
        if(l.is<Vector1<T>>()) {
            return 0n;
        }
        elif(l.is<Vector2<T>>()) {
            if(f[recursive?](l.v1) > f[recursive?](l.v0)) {
                return 1n;
            }
            else {
                return 0n;
            }
        }
        elif(l.is<Vector3<T>>()) {
            let gt21 = f[recursive?](l.v2) > f[recursive?](l.v1);
            let gt20 = f[recursive?](l.v2) > f[recursive?](l.v0);
            let gt10 = f[recursive?](l.v1) > f[recursive?](l.v0);
            if(/\(gt21, gt20)) {
                return 2n;
            }
            elif(gt10) {
                return 1n;
            }
            else {
                return 0n
            }
        }
        else {
            return ListOps::s_safeAs<ListRepr<T>, RecList<T>>(l).max_arg[recursive?](f);
        }
    }

    function s_sum<T unique Algebraic>(l: ListRepr<T>): T {
        if(l === none) {
            return T::zero;
        }
        elif(l.is<Vector1<T>>()) {
            return l.v0;
        }
        elif(l.is<Vector2<T>>()) {
            return l.v0 + l.v1;
        }
        elif(l.is<Vector3<T>>()) {
            return l.v0 + l.v1 + l.v2;
        }
        else {
            return l.sum();
        }
    }

    recursive? function s_sort<T>(l: ListRepr<T>, cmp: recursive? pred(_: T, _: T) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return l;
        }
        elif(l.is<Vector2<T>>()) {
            if(!cmp[recursive?](l.v1, l.v0)) {
                return l;
            }
            else {
                return List<T>@{at1, at0};
            }
        }
        elif(l.is<Vector3<T>>()) {
            let l10 = cmp[recursive?](l.v1, l.v0);
            let l20 = cmp[recursive?](l.v2, l.v0);
            let l21 = cmp[recursive?](l.v2, l.v1);

            if(/\(l20, l21)) {
                if(l10) {
                    return Vector3<T>{l.v2, l.v1, l.v0};
                }
                else {
                    return Vector3<T>{l.v2, l.v0, l.v1};
                }
            }
            elif(/\(l10, !l21)) {
                if(l20) {
                    return Vector3<T>{l.v1, l.v2, l.v0};
                }
                else {
                    return Vector3<T>{l.v1, l.v0, l.v2};
                }
            }
            else {
                if(l21) {
                    return Vector3<T>{l.v0, l.v2, l.v1};
                }
                else {
                    return Vector3<T>{l.v0, l.v1, l.v2};
                }
            }
        }
        else {
            return l.sort[recursive?](eq);
        }
    }

    recursive? function s_unique_from_sorted<T>(l: ListRepr<T>, eq: recursive? pred(_: T, _: T) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return l;
        }
        elif(l.is<Vector2<T>>()) {
            if(eq[recursive?](l.v0, l.v1)) {
                return Vector1<T>{l.v0};
            }
            else {
                return l;
            }
        }
        elif(l.is<Vector3<T>>()) {
            let eq01 = eq[recursive?](l.v0, l.v1);
            let eq02 = eq[recursive?](l.v0, l.v2);
            let eq12 = eq[recursive?](l.v1, l.v2);
            

            if(/\(eq01, eq02)) {
                return Vector1<T>{l.v0};
            }
            elif(eq01) {
                return Vector2<T>{l.v0, l.v2};
            }
            elif(eq02) {
                return Vector2<T>{l.v0, l.v1};
            }
            elif(eq12) {
                return Vector2<T>{l.v0, l.v1};
            }
            else {
                return l;
            }
        }
        else {
            return l.unique_from_sorted[recursive?](eq);
        }
    }
    
    function s_reverse(l: ListRepr<T>): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return l;
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>{l.v1, l.v0};
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>{l.v2, l.v1, l.v0};
        }
        else {
            return l.reverse();
        }
    }
}

entity ListTree<T> provides Some {
    field count: Nat;
    field left: ListTree<T> | PartialVector<T>;
    field right ListTree<T> | PartialVector<T>;

    invariant $count > 4;

    recursive {when T unique Int | Nat} function s_range(start: T, end: T, inc: T, zero: T): ListRepr<Int> {
        let count = end - start;
        if(count <= 4) {
            return PartialVector<T>::s_range(start, end, inc, zero);
        }
        else {
            let llc = count / (inc + inc);
            let rrc = count - llc;

            let llt = ListTree<T>::s_range[recursive](start, start + llc, inc, zero);
            let rrt = ListTree<T>::s_fill[recursive](start + llc, end, inc, zero);

            retur ListTree<T>{count, llt, rrt};
        }
    }
    
    recursive function s_fill<T>(count: Nat, v: T): ListRepr<T> {
        if(n <= 4) {
            return PartialVector<T>::s_fill(count, v);
        }
        else {
            let llc = count / 2n;
            let rrc = count - llc;

            let llt = ListTree<T>::s_fill[recursive](llc, v);
            let rrt = ListTree<T>::s_fill[recursive](rrc, v);

            return ListTree<T>{count, llt, rrt};
        }
    }

    recursive method s_zip_index<T>(idx: Nat): ListRepr<[Nat, T]> {
        let l = this.left;
        let r = this.right;

        var lcount: Nat;
        var nl: ListRepr<T>;
        if(l.is<PartialVector<T>>()) {
            lcount = l.count();
            nl = l.s_zip_index(idx);
        }
        else {
            lcount = l.count;
            nl = l.zip_index[recursive](idx)
        }

        let nidx = idx + lcount;
        var nr: ListRepr<T>;
        if(r.is<PartialVector<T>>()) {
            nr = r.s_zip_index(nidx);
        }
        else {
            nr = r.zip_index[recursive](nidx)
        }
        
        return ListTree<T>::append(nl, nr);
    }

    recursive method zip<U>(ol: ListRepr<U>, idx: Nat): ListRepr<[T, U]> {
        let l = this.left;
        let r = this.right;

        var lcount: Nat;
        var nl: ListRepr<T>;
        if(l.is<PartialVector<T>>()) {
            lcount = l.count();
            nl = l.s_zip_map<U>(idx, fn(i: Nat): U => ListOps::s_safe_get<U>(ol, i));
        }
        else {
            lcount = l.count;
            nl = l.zip<U>[recursive](ol, idx)
        }

        let nidx = idx + lcount;
        var nr: ListRepr<T>;
        if(r.is<PartialVector<T>>()) {
            nr = r.zip_map(idx, fn(i: Nat): U => ListOps::s_safe_get<U>(ol, i));
        }
        else {
            nr = r.zip[recursive](ol, nidx)
        }
        
        return ListTree<T>::append(nl, nr);
    }

    function append(l: ListTree<T> | PartialVector<T>, r: ListTree<T> | PartialVector<T>): ListRepr<T> {
        if(/\(l.is<PartialVector<T>>(), r.is<PartialVector<T>>())) {
            let nsize = l.count() + r.count();
            if(nsize <= 4) {
                return PartialVector<T>::s_append(l, r);
            }
        }

        var ls: Nat;
        if(l.is<PartialVector<T>>()) {
            ls = l.count();
        }
        else {
            ls = l.count;
        }

        var rs: Nat;
        if(r.is<PartialVector<T>>()) {
            rs = r.count();
        }
        else {
            rs = r.count;
        }

        return ListTree<T>{ls + rs, l, r};
    }

    recursive method slice_start(start: Nat): ListTree<T> | PartialVector<T> {
        if(start == 0) {
            return this;
        }
        
        assert start < this.count;

        let l = this.left;
        let r = this.right;

        var ls: Nat;
        if(l.is<PartialVector<T>>()) {
            ls = l.count();
        }
        else {
            ls = l.count;
        }

        if(ls <= start) {
            let nstart = start - ls;
            if(r.is<PartialVector<T>>()) {
                return PartialVector<T>::s_slice_start(r, nstart);
            }
            else {
                return r.slice_start[recursive](nstart);
            }
        }
        else {
            var nl: ListTree<T> | PartialVector<T>;
            if(l.is<PartialVector<T>>()) {
                nl = PartialVector<T>::s_slice_start(r, start);
            }
            else {
                nl = l.slice_start[recursive](start);
            }

            return ListTree<T>::append(nl, r);
        }
    }

    recursive method slice_end(end: Nat): ListTree<T> {
        if(end === this.count) {
            return this;
        }
        
        assert end != 0;

        let l = this.left;
        let r = this.right;

        var ls: Nat;
        if(l.is<PartialVector<T>>()) {
            ls = l.count();
        }
        else {
            ls = l.count;
        }

        if(ls >= end) {
            if(l.is<PartialVector<T>>()) {
                return PartialVector<T>::s_slice_end(l, end);
            }
            else {
                return r.slice_end[recursive](end);
            }
        }
        else {
            let nend = end - ls;
            var nr: ListTree<T> | PartialVector<T>;
            if(r.is<PartialVector<T>>()) {
                nr = PartialVector<T>::s_slice_end(r, nend);
            }
            else {
                nr = r.slice_end[recursive](nend);
            }

            return ListTree<T>::append(l, nr);
        }
    }

    recursive method safe_get(i: Nat): T {
        let l = this.left;
        if(l.is<PartialVector<T>>()) {
            return PartialVector<T>::s_safe_get(l, i);
        }
        else {
            if(i < l.count) {
                return l.safe_get[recursive](i);
            }
            else {
                let r = this.right;
                let ir = i - l.count;
                if(r.is<PartialVector<T>>()) {
                    return PartialVector<T>::s_safe_get(r, ir);
                }
                else {
                    return r.safe_get[recursive](ir);
                }
            }
        }
    }

    recursive method has_pred(p: recursive? pred(_: T) -> Bool): Bool {
        let l = this.left;
        let r = this.right;

        if(l.is<PartialVector<T>>() && l.find_pred[recursive?](p).some_true()) {
            return true;
        }

        if(r.is<PartialVector<T>>() && r.find_pred[recursive?](p).some_true()) {
            return true;
        }

        if(l.is<ListTree<T>>() && l.has_pred[recursive](p)) {
            return true;
        }

        if(r.is<ListTree<T>>() && r.has_pred[recursive](p)) {
            return true;
        }

        return false;
    }

    recursive method has_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let l = this.left;
        let r = this.right;

        var lcount: Nat;
        if(l.is<PartialVector<T>>()) {
            if(l.find_pred_idx[recursive?](idx, p).some_true()) {
                return true;
            }
            lcount = l.count();
        }
        else {
            if(l.has_pred_idx[recursive](idx, p)) {
                return true;
            }
            lcount = l.count;
        }

        let nidx = idx + lcount; 
        if(r.is<PartialVector<T>>()) {
            return r.find_pred_idx[recursive?](nidx, p).some_true();
        }
        else {
            return r.has_pred[recursive](nidx, p);
        }
    }

    recursive method find_pred(idx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let l = this.left;
        let r = this.right;

        var lcount: Nat;
        if(l.is<PartialVector<T>>()) {
            let lm = l.find_pred[recursive?](p);
            if(lm.some_true()) {
                return idx + lm.min();
            }
            lcount = l.count();
        }
        else {
            let lres = l.find_pred[recursive](idx, p)
            if(lres !== none) {
                return lres;
            }
            lcount = l.count;
        }

        let nidx = idx + lcount; 
        if(r.is<PartialVector<T>>()) {
            let rm = r.find_pred[recursive?](p);
            if(rm.some_true()) {
                return nidx + rm.min();
            }
            else {
                return none;
            }
        }
        else {
            return r.find_pred[recursive](nidx, p);
        }
    }

    recursive method find_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let l = this.left;
        let r = this.right;

        var lcount: Nat;
        if(l.is<PartialVector<T>>()) {
            let lm = l.find_pred_idx[recursive?](idx, p);
            if(lm.some_true()) {
                return idx + lm.min();
            }
            lcount = l.count();
        }
        else {
            let lres = l.find_pred_idx[recursive](idx, p)
            if(lres !== none) {
                return lres;
            }
            lcount = l.count;
        }

        let nidx = idx + lcount; 
        if(r.is<PartialVector<T>>()) {
            let rm = r.find_pred_idx[recursive?](nidx, p);
            if(rm.some_true()) {
                return nidx + rm.min();
            }
            else {
                return none;
            }
        }
        else {
            return r.find_pred_idx[recursive](nidx, p);
        }
    }

    recursive method find_last_pred(idx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let l = this.left;
        let r = this.right;

        var lcount: Nat;
        if(l.is<PartialVector<T>>()) {
            lcount = l.count();
        }
        else {
            lcount = l.count;
        }

        let nidx = idx + lcount;
        if(r.is<PartialVector<T>>()) {
            let rm = r.find_last_pred[recursive?](p);
            if(rm.some_true()) {
                return nidx + rm.max();
            }
        }
        else {
            let rres = r.find_last_pred[recursive](nidx, p)
            if(rres !== none) {
                return rres;
            }
        }

        if(l.is<PartialVector<T>>()) {
            let lm = l.find_last_pred_idx[recursive?](idx, p);
           if(lm.some_true()) {
                return idx + lm.max();
            }
            else {
                return none;
            }
        }
        else {
            return l.find_last_pred[recursive](idx, p)
        }
    }

    recursive method find_last_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let l = this.left;
        let r = this.right;

        var lcount: Nat;
        if(l.is<PartialVector<T>>()) {
            lcount = l.count();
        }
        else {
            lcount = l.count;
        }

        let nidx = idx + lcount;
        if(r.is<PartialVector<T>>()) {
            let rm = r.find_last_pred_idx[recursive?](nidx, p);
            if(rm.some_true()) {
                return nidx + rm.max();
            }
        }
        else {
            let rres = r.find_last_pred_idx[recursive](nidx, p)
            if(rres !== none) {
                return rres;
            }
        }

        if(l.is<PartialVector<T>>()) {
            let lm = l.find_last_pred_idx[recursive?](idx, p);
            if(lm.some_true()) {
                return idx + lm.max();
            }
            else {
                return none;
            }
        }
        else {
            return l.find_last_pred_idx[recursive](idx, p)
        }
    }

    recursive method filter_pred(p: recursive? pred(_: T) -> Bool): ListRepr<T> {
        let l = this.left;
        let r = this.right;

        var nl: ListRepr<T>;
        if(l.is<PartialVector<T>>()) {
            let lm = l.apply_pred[recursive?](p);
            if(lm.empty()) {
                nl = none;
            }
            else {
                nl = PartialVector<T>::s_select(l, lm);
            }
        }
        else {
            nl = l.filter_pred[recursive](p)
        }

        var nr: ListRepr<T>;
        if(r.is<PartialVector<T>>()) {
            let rm = r.apply_pred[recursive?](p);
            if(rm.empty()) {
                nr = none;
            }
            else {
                nr = PartialVector<T>::s_select(r, rm);
            }
        }
        else {
            nr = r.filter_pred[recursive](p)
        }

        if(/\(nl === none, nr === none)) {
            return none;
        }
        elif(nl === none) {
            return nr;
        }
        elif(nr === none) {
            return nl;
        }
        else {
            return ListTree<T>::append(nl, nr);
        }
    }

    recursive method filter_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): ListRepr<T> {
        let l = this.left;
        let r = this.right;

        var lcount: Nat;
        var nl: ListRepr<T>;
        if(l.is<PartialVector<T>>()) {
            lcount = l.count();
            let lm = l.apply_pred_idx[recursive?](idx, p);
            if(lm.empty()) {
                nl = none;
            }
            else {
                nl = PartialVector<T>::s_select(l, lm);
            }
        }
        else {
            lcount = l.count;
            nl = l.filter_pred_idx[recursive](idx, p)
        }

        let nidx = idx + lcount; 
        var nr: ListRepr<T>;
        if(r.is<PartialVector<T>>()) {
            let rm = r.apply_pred_idx[recursive?](nidx, p);
            if(rm.empty()) {
                nr = none;
            }
            else {
                nr = PartialVector<T>::s_select(r, rm);
            }
        }
        else {
            nr = r.filter_pred_idx[recursive](nidx, p)
        }

        if(/\(nl === none, nr === none)) {
            return none;
        }
        elif(nl === none) {
            return nr;
        }
        elif(nr === none) {
            return nl;
        }
        else {
            return ListTree<T>::append(nl, nr);
        }
    }

    recursive method map<U>(f: recursive? fn(_: T) -> U): ListRepr<U> {
        let l = this.left;
        let r = this.right;

        var nl: ListRepr<T>;
        if(l.is<PartialVector<T>>()) {
            nl = l.map<U>[recursive?](f);
        }
        else {
            nl = l.map<U>[recursive](f)
        }

        var nr: ListRepr<T>;
        if(r.is<PartialVector<T>>()) {
            nr = r.map<U>[recursive?](f);
        }
        else {
            nr = r.map[recursive](f)
        }
        
        return ListTree<T>::append(nl, nr);
    }

    recursive method map_idx<U>(idx: Nat, f: recursive? fn(_: T, _: Nat) -> U): ListRepr<U> {
        let l = this.left;
        let r = this.right;

        var lcount: Nat;
        var nl: ListRepr<T>;
        if(l.is<PartialVector<T>>()) {
            lcount = l.count();
            nl = l.map_idx<U>[recursive?](idx, f);
        }
        else {
            lcount = l.count;
            nl = l.map_idx<U>[recursive](idx, f)
        }

        let nidx = idx + lcount;
        var nr: ListRepr<T>;
        if(r.is<PartialVector<T>>()) {
            nr = r.map<U>[recursive?](nidx, f);
        }
        else {
            nr = r.map[recursive](nidx, f)
        }
        
        return ListTree<T>::append(nl, nr);
    }
}

typedef ListRepr<T> = None | PartialVector<T> | ListTree<T>;
 

#endif
