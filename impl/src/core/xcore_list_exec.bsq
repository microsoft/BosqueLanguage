//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

#if EXEC_LIBS
__internal entity ListOps provides Some {
    __assume_safe function s_safeAs<T, U>(v: T): U # list_safeas

    function s_asListTree<T>(l: ListRepr<T>): ListTree<T> {
        return ListOps::s_safeAs<ListRepr<T>, ListTree<T>>(l);
    }

    function s_empty(l: ListRepr<T>): Nat {
        return l === none;
    }

    function s_size<T>(l: ListRepr<T>): Nat {
        if(l === none) {
            return 0;
        }
        elif(l.is<PartialVector<T>>()) {
            return PartialVector<T>::s_popcount(l);
        }
        else {
            return l.count;
        }
    }

    function s_safe_get<T>(l: ListRepr<T>, i: Nat): T {
        if(l.is<PartialVector<T>>()) {
            return PartialVector<T>::s_safe_get(l, i);
        }
        else {
            return ListOps::s_asListTree<T>(l).safe_get[recursive](i);
        }
    }

    recursive? function s_has_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        elif(l.is<PartialVector<T>>()) {
            return Mask::s_some_true(PartialVector<T>::s_apply_pred[recursive?](l, p));
        }
        else {
            return l.has_pred[recursive](p);
        }
    }

    recursive? function s_has_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        elif(l.is<PartialVector<T>>()) {
            return Mask::s_some_true(PartialVector<T>::s_apply_pred_idx[recursive?](l, 0, p));
        }
        else {
            return l.has_pred_idx[recursive](0, p);
        }
    }

    recursive? function s_find_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat {
    }

    recursive? function s_find_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
    }

    recursive? function s_find_last_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat {
    }

    recursive? function s_find_last_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat {
    }

    recursive? function s_filter_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): ListRepr<T> {
    }

    recursive? function s_filter_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): ListRepr<T> {
    }

    recursive? function s_map<T, U>(l: ListRepr<T>, p: recursive? pred(_: T) -> U): ListRepr<U> {
    }

    recursive? function s_map_idx<T, U>(l: ListRepr<T>, p: recursive? pred(_: T, _: U) -> Bool): ListRepr<U> {
    }
}

entity ListTree<T> provides Some {
    field count: Nat;
    field left: ListTree<T> | PartialVector<T>;
    field right ListTree<T> | PartialVector<T>;

    recursive method safe_get(i: Nat): T {
        let l = this.left;
        if(l.is<ListPV<T>>()) {
            return ListPV<T>::s_safe_get(l, i);
        }
        else {
            if(i < l.count) {
                return l.safe_get[recursive](i);
            }
            else {
                let r = this.right;
                let ir = i - l.count;
                if(r.is<ListPV<T>>()) {
                    return ListPV<T>::s_safe_get(r, ir);
                }
                else {
                    return r.safe_get[recursive](ir);
                }
            }
        }
    }

    recursive method has_pred(p: recursive? pred(_: T) -> Bool): Bool {
        let l = this.left;
        let r = this.right;

        if(l.is<PartialVector<T>>() && Mask::s_some_true(PartialVector<T>::s_apply_pred[recursive?](l, p))) {
            return true;
        }

        if(r.is<PartialVector<T>>() && Mask::s_some_true(PartialVector<T>::s_apply_pred[recursive?](r, p))) {
            return true;
        }

        if(l.is<ListTree<T>>() && l.has_pred[recursive](p)) {
            return true;
        }

        if(r.is<ListTree<T>>() && r.has_pred[recursive](p)) {
            return true;
        }

        return false;
    }

    recursive method has_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        let l = this.left;
        let r = this.right;

        var lcount;
        if(l.is<PartialVector<T>>()) {
            if(Mask::s_some_true(PartialVector<T>::s_apply_pred_idx[recursive?](l, idx, p))) {
                return true;
            }
            lcount = PartialVector::s_popcount(l);
        }
        else {
            if(l.has_pred_idx[recursive](idx, p)) {
                return true;
            }
            lcount = l.count;
        }

        let nidx = idx + lcount; 
        if(r.is<PartialVector<T>>()) {
            return Mask::s_some_true(PartialVector<T>::s_apply_pred_idx[recursive?](r, nidx, p));
        }
        else {
            return r.has_pred[recursive](nidx, p)) {
        }
    }

    recursive method find_pred(p: recursive? pred(_: T) -> Bool): Nat? {
    }

    recursive method find_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
    }

    recursive method find_last_pred(p: recursive? pred(_: T) -> Bool): Nat? {
    }

    recursive method find_last_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
    }

    recursive method filter_pred(p: recursive? pred(_: T) -> Bool): ListRepr<T> {
    }

    recursive method filter_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): ListRepr<T> {
    }

    recursive method map<U>(p: recursive? pred(_: T) -> U): ListRepr<U> {
    }

    recursive method map_idx<U>(p: recursive? pred(_: T, _: Nat) -> U): ListRepr<U> {
    }
}

typedef ListRepr<T> = None | PartialVector<T> | ListTree<T>;
 

#endif
