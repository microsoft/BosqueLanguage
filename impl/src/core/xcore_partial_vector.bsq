//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

#if EXEC_LIBS
entity Mask provides Some, APIType {
    field bit0: Bool;
    field bit1: Bool;
    field bit2: Bool;
    field bit3: Bool;

    // struct {uint32_t mask (byte); uint32_t count;}
    __safe function s_min_set(m: Mask): Nat # mask_min_set
    __safe function s_max_set(m: Mask): Nat # mask_max_set
    __safe function s_count(m: Mask): Nat # mask_count
    __safe function s_all_true(m: Mask): Nat # mask_all_true
    __safe function s_some_true(m: Mask): Nat # mask_some_true
    __safe function s_and(m1: Mask, m2: Mask): Mask # mask_and
    __safe function s_or(m1: Mask, m2: Mask): Mask # mask_or

    method empty(): Bool {
        return !Mask::some_true(this);
    }

    method count(): Nat {
        return Mask::s_count(this);
    }

    method all_true(): Bool {
        return Mask::s_all_true(this);
    }

    method some_true(): Bool {
        return Mask::some_true(this);
    }

    method min(): Nat? {
        if(this.empty()) {
            return none;
        }
        else {
            return Mask::s_min_set(this);
        }
    }

    method max(): Nat? {
        if(this.empty()) {
            return none;
        }
        else {
            return Mask::s_max_set(this);
        }
    }

    function and(m1: Mask, m2: Mask): Mask {
        Mask::s_and(m1, m2);
    }

    function or(m1: Mask, m2: Mask): Mask  {
        Mask::s_or(m1, m2);
    }
}

__safe function s_pv_undef<T>(): T # special_function

entity PartialVector<T> provides Some, APIType when T grounded APIType {
    __safe function s_safe_get(pv: PartialVector<T>, i: Nat): T # pv_safe_get
    __safe function s_select(pv: PartialVector<T>, m: Mask): PartialVector<T> # pv_compact
    __safe function s_append(pv1: PartialVector<T>, pv2: PartialVector<T>): PartialVector<T> # pv_append
    __safe function s_slice_start(pv: PartialVector<T>, start: Nat, end: Nat): PartialVector<T> # pv_slice_start
    __safe function s_slice_end(pv: PartialVector<T>, start: Nat, end: Nat): PartialVector<T> # pv_slice_end

    field v0: T;
    field v1: T;
    field v2: T;
    field v3: T;
    field mask: Mask;

    invariant !$mask.empty();

    recursive? method applyPred(p: recursive? pred(_: T) -> Bool): Mask {
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(this.mask.bit0) {
            b0 = p[recursive?](this.v0);
        }

        if(this.mask.bit1) {
            b1 = p[recursive?](this.v1);
        }

        if(this.mask.bit2) {
            b2 = p[recursive?](this.v2);
        }

        if(this.mask.bit3) {
            b3 = p[recursive?](this.v3);
        }

        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method apply_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Mask {
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(this.mask.bit0) {
            b0 = p[recursive?](this.v0, idx);
        }

        if(this.mask.bit1) {
            b1 = p[recursive?](this.v1, idx + 1n);
        }

        if(this.mask.bit2) {
            b2 = p[recursive?](this.v2, idx + 2n);
        }

        if(this.mask.bit3) {
            b3 = p[recursive?](this.v3, idx + 3n);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method find_pred(p: recursive? pred(_: T) -> Bool): Mask {
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(this.mask.bit0) {
            b0 = p[recursive?](this.v0);
        }

        if(/\(!b0, this.mask.bit1)) {
            b1 = p[recursive?](this.v1);
        }

        if(/\(!b0, !b1, this.mask.bit2)) {
            b2 = p[recursive?](this.v2);
        }

        if(/\(!b0, !b1, !b2, this.mask.bit3)) {
            b3 = p[recursive?](this.v3);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method find_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Mask {
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(this.mask.bit0) {
            b0 = p[recursive?](this.v0, idx);
        }

        if(/\(!b0, this.mask.bit1)) {
            b1 = p[recursive?](this.v1, idx + 1n);
        }

        if(/\(!b0, !b1, this.mask.bit2)) {
            b2 = p[recursive?](this.v2, idx + 2n);
        }

        if(/\(!b0, !b1, !b2, this.mask.bit3)) {
            b3 = p[recursive?](this.v3, idx + 3n);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method s_find_last_pred(p: recursive? pred(_: T) -> Bool): Mask {
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(this.mask.bit3) {
            b3 = p[recursive?](this.v3);
        }

        if(/\(!b3, this.mask.bit2)) {
            b2 = p[recursive?](this.v2);
        }

        if(/\(!b3, !b2, this.mask.bit1)) {
            b1 = p[recursive?](this.v1);
        }

        if(/\(!b3, !b2, !b1, this.mask.bit0)) {
            b0 = p[recursive?](this.v0);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method s_find_last_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Mask {
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(this.mask.bit3) {
            b3 = p[recursive?](this.v3, idx + 3n);
        }

        if(/\(!b3, this.mask.bit2)) {
            b2 = p[recursive?](this.v2, idx + 2n);
        }

        if(/\(!b3, !b2, this.mask.bit1)) {
            b1 = p[recursive?](this.v1, idx + 1n);
        }

        if(/\(!b3, !b2, !b1, this.mask.bit0)) {
            b0 = p[recursive?](this.v0, idx);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? function s_map_fn<T, U>(pv: PartialVector<T>, f: recursive? fn(_: T) -> U): PartialVector<U> {
        var v0 = s_pv_undef<U>();
        var v1 = s_pv_undef<U>();
        var v2 = s_pv_undef<U>();
        var v3 = s_pv_undef<U>();

        if(this.mask.bit0) {
            v0 = f[recursive?](this.v0);
        }

        if(this.mask.bit1) {
            v1 = f[recursive?](this.v1);
        }

        if(this.mask.bit2) {
            v2 = f[recursive?](this.v2);
        }

        if(this.mask.bit3) {
            v3 = f[recursive?](this.v3);
        }
        
        return PartialVector<U>{v0, v1, v2, v3, pv.mask};
    }
    
    recursive? function s_map_fn_idx<T, U>(pv: PartialVector<T>, idx: Nat, p: recursive? fn(_: T, _: Nat) -> U): PartialVector<U> {
        var v0 = s_pv_undef<U>();
        var v1 = s_pv_undef<U>();
        var v2 = s_pv_undef<U>();
        var v3 = s_pv_undef<U>();

        if(this.mask.bit0) {
            v0 = f[recursive?](this.v0, idx);
        }

        if(this.mask.bit1) {
            v1 = f[recursive?](this.v1, idx + 1n);
        }

        if(this.mask.bit2) {
            v2 = f[recursive?](this.v2, idx + 2n);
        }

        if(this.mask.bit3) {
            v3 = f[recursive?](this.v3, idx + 3n);
        }
        
        return PartialVector<U>{v0, v1, v2, v3, pv.mask};
    }

    recursive? function s_reduce_fn<T, U>(pv: PartialVector<T>, init: U, p: recursive? fn(_: T) -> U): U # special_function_pv_reduce_fn
    recursive? function s_reduce_fn_idx<T, U>(pv: PartialVector<T>, init: U, idx: Nat, p: recursive? fn(_: T, _: Nat) -> U): U # special_function_pv_reduce_fn_idx

    recursive? function s_transduce_fn<T, U, E>(pv: PartialVector<T>, init: E, p: recursive? fn(_: T, _: E) -> U, E): PartialVector<U> # special_function_pv_transduce_fn
    recursive? function s_transduce_fn_idx<T, U, E>(pv: PartialVector<T>, init: E, idx: Nat, p: recursive? fn(_: T, _: E, _: Nat) -> U, E): PartialVector<U> # special_function_pv_transduce_fn_idx

    recursive? method sort2(cmp: recursive? pred(_: T, _: T) -> Bool): PartialVector<U> {
        assert(Mask::s_count(this.mask) <= 2n);

        if(Mask::s_count(this.mask) == 2n && cmp[recursive?](this.v1, this.v0)) {
            return PartialVector<T>{this.v1, this.v0, this.v2, this.v3, this.mask};
        }
    }
}
#endif
