//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

#if EXEC_LIBS
entity Mask provides Some, APIType {
    field bit0: Bool;
    field bit1: Bool;
    field bit2: Bool;
    field bit3: Bool;

    // struct {uint32_t mask (byte); uint32_t count;}

    __safe function s_init_k(k: Nat): Mask # mask_init_k
    __safe function s_min_set(m: Mask): Nat # mask_min_set
    __safe function s_max_set(m: Mask): Nat # mask_max_set
    __safe function s_count(m: Mask): Nat # mask_count
    __safe function s_all_true(m: Mask): Nat # mask_all_true
    __safe function s_some_true(m: Mask): Nat # mask_some_true
    __safe function s_and(m1: Mask, m2: Mask): Mask # mask_and
    __safe function s_or(m1: Mask, m2: Mask): Mask # mask_or

    method empty(): Bool {
        return !Mask::some_true(this);
    }

    method count(): Nat {
        return Mask::s_count(this);
    }

    method all_true(): Bool {
        return Mask::s_all_true(this);
    }

    method some_true(): Bool {
        return Mask::some_true(this);
    }

    method min(): Nat? {
        if(this.empty()) {
            return none;
        }
        else {
            return Mask::s_min_set(this);
        }
    }

    method max(): Nat? {
        if(this.empty()) {
            return none;
        }
        else {
            return Mask::s_max_set(this);
        }
    }

    function and(m1: Mask, m2: Mask): Mask {
        Mask::s_and(m1, m2);
    }

    function or(m1: Mask, m2: Mask): Mask  {
        Mask::s_or(m1, m2);
    }
}

__safe function s_pv_undef<T>(): T # special_function

entity PartialVector<T> provides Some, APIType when T grounded APIType {
    __safe function s_safe_get(pv: PartialVector<T>, i: Nat): T # pv_safe_get
    __safe function s_select(pv: PartialVector<T>, m: Mask): PartialVector<T> # pv_compact
    __safe function s_append(pv1: PartialVector<T>, pv2: PartialVector<T>): PartialVector<T> # pv_append
    __safe function s_slice_start(pv: PartialVector<T>, start: Nat, end: Nat): PartialVector<T> # pv_slice_start
    __safe function s_slice_end(pv: PartialVector<T>, start: Nat, end: Nat): PartialVector<T> # pv_slice_end

    field mask: Mask;
    field v0: T;
    field v1: T;
    field v2: T;
    field v3: T;

    invariant !$mask.empty();

    recursive? method applyPred(p: recursive? pred(_: T) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit0) {
            b0 = p[recursive?](this.v0);
        }

        if(m.bit1) {
            b1 = p[recursive?](this.v1);
        }

        if(m.bit2) {
            b2 = p[recursive?](this.v2);
        }

        if(m.bit3) {
            b3 = p[recursive?](this.v3);
        }

        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method apply_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit0) {
            b0 = p[recursive?](this.v0, idx);
        }

        if(m.bit1) {
            b1 = p[recursive?](this.v1, idx + 1n);
        }

        if(m.bit2) {
            b2 = p[recursive?](this.v2, idx + 2n);
        }

        if(m.bit3) {
            b3 = p[recursive?](this.v3, idx + 3n);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method find_pred(p: recursive? pred(_: T) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit0) {
            b0 = p[recursive?](this.v0);
        }

        if(/\(!b0, m.bit1)) {
            b1 = p[recursive?](this.v1);
        }

        if(/\(!b0, !b1, m.bit2)) {
            b2 = p[recursive?](this.v2);
        }

        if(/\(!b0, !b1, !b2, m.bit3)) {
            b3 = p[recursive?](this.v3);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method find_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit0) {
            b0 = p[recursive?](this.v0, idx);
        }

        if(/\(!b0, m.bit1)) {
            b1 = p[recursive?](this.v1, idx + 1n);
        }

        if(/\(!b0, !b1, m.bit2)) {
            b2 = p[recursive?](this.v2, idx + 2n);
        }

        if(/\(!b0, !b1, !b2, m.bit3)) {
            b3 = p[recursive?](this.v3, idx + 3n);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method s_find_last_pred(p: recursive? pred(_: T) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit3) {
            b3 = p[recursive?](this.v3);
        }

        if(/\(!b3, m.bit2)) {
            b2 = p[recursive?](this.v2);
        }

        if(/\(!b3, !b2, m.bit1)) {
            b1 = p[recursive?](this.v1);
        }

        if(/\(!b3, !b2, !b1, m.bit0)) {
            b0 = p[recursive?](this.v0);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method s_find_last_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit3) {
            b3 = p[recursive?](this.v3, idx + 3n);
        }

        if(/\(!b3, m.bit2)) {
            b2 = p[recursive?](this.v2, idx + 2n);
        }

        if(/\(!b3, !b2, m.bit1)) {
            b1 = p[recursive?](this.v1, idx + 1n);
        }

        if(/\(!b3, !b2, !b1, m.bit0)) {
            b0 = p[recursive?](this.v0, idx);
        }
        
        return Mask::s_cons(b0, b1, b2, b3);
    }

    recursive? method s_map_fn<T, U>(f: recursive? fn(_: T) -> U): PartialVector<U> {
        let m = this.mask;
        var v0 = s_pv_undef<U>();
        var v1 = s_pv_undef<U>();
        var v2 = s_pv_undef<U>();
        var v3 = s_pv_undef<U>();

        if(m.bit0) {
            v0 = f[recursive?](this.v0);
        }

        if(m.bit1) {
            v1 = f[recursive?](this.v1);
        }

        if(m.bit2) {
            v2 = f[recursive?](this.v2);
        }

        if(m.bit3) {
            v3 = f[recursive?](this.v3);
        }
        
        return PartialVector<U>{m, v0, v1, v2, v3};
    }
    
    recursive? method s_map_fn_idx<T, U>(idx: Nat, p: recursive? fn(_: T, _: Nat) -> U): PartialVector<U> {
        let m = this.mask;
        var v0 = s_pv_undef<U>();
        var v1 = s_pv_undef<U>();
        var v2 = s_pv_undef<U>();
        var v3 = s_pv_undef<U>();

        if(m.bit0) {
            v0 = f[recursive?](this.v0, idx);
        }

        if(m.bit1) {
            v1 = f[recursive?](this.v1, idx + 1n);
        }

        if(m.bit2) {
            v2 = f[recursive?](this.v2, idx + 2n);
        }

        if(m.bit3) {
            v3 = f[recursive?](this.v3, idx + 3n);
        }
        
        return PartialVector<U>{m, v0, v1, v2, v3};
    }

    function {when T unique Int | Nat} s_range(start: T, end: T, inc: T, zero: T): PartialVector<T> {
        let m = Mask::s_init_k(count);

        if(count <= 1n) {
            return PartialVector<Int>{m, start, zero, zero, zero};
        }
        else {
            let e1 = start + inc;
            if(count == 2n) {
                return PartialVector<Int>{m, start, e1, zero, zero};
            }
            else {
                let e2 = e1 + inc;
                if(count == 3n) {
                    return PartialVector<Int>{m, start, e1, e2, zero};
                }
                else {
                    let e3 = e2 + inc;
                    return PartialVector<Int>{m, start, e1, e2, e3};
                }
            }
        }
    }

    function s_fill(count: Nat, v: T): PartialVector<T> {
        let m = Mask::s_init_k(count);

        var v0 = s_pv_undef<T>();
        var v1 = s_pv_undef<T>();
        var v2 = s_pv_undef<T>();
        var v3 = s_pv_undef<T>();

        if(m.bit0) {
            v0 = v;
        }

        if(m.bit1) {
            v1 = v;
        }

        if(m.bit2) {
            v2 = v;
        }

        if(m.bit3) {
            v3 = v;
        }
        
        return PartialVector<U>{m, v0, v1, v2, v3};
    }

    method s_zip_index<T>(idx: Nat): PartialVector<[Nat, T]> {
        let m = this.mask;
        var v0 = s_pv_undef<[Nat, T]>();
        var v1 = s_pv_undef<[Nat, T]>();
        var v2 = s_pv_undef<[Nat, T]>();
        var v3 = s_pv_undef<[Nat, T]>();

        if(m.bit0) {
            v0 = [idx, this.v0];
        }

        if(m.bit1) {
            v1 = [idx + 1n, this.v1];
        }

        if(m.bit2) {
            v2 = [idx + 2n, this.v2];
        }

        if(m.bit3) {
            v3 = [idx + 3n, this.v3];
        }
        
        return PartialVector<U>{m, v0, v1, v2, v3};
    }

    method s_zip<U>(ov: PartialVector<U>): PartialVector<[V, U]> {
        let tm = this.mask;
        let om = ov.mask;

        var v0 = s_pv_undef<[V, U]>();
        var v1 = s_pv_undef<[V, U]>();
        var v2 = s_pv_undef<[V, U]>();
        var v3 = s_pv_undef<[V, U]>();

        if(/\(tm.bit0, om.bit0)) {
            v0 = [this.v0, ov.v0];
        }

        if(/\(tm.bit1, om.bit1)) {
            v1 = [this.v1, ov.v1];
        }

        if(/\(tm.bit2, om.bit2)) {
            v2 = [this.v2, ov.v2];
        }

        if(/\(tm.bit3, om.bit3)) {
            v3 =[this.v3, ov.v3];
        }
        
        return PartialVector<U>{Mask::and(tm, om), v0, v1, v2, v3};
    }

    method s_zip_map<U>(idx: i, getfn: fn(i: Nat) -> U): PartialVector<[V, U]> {
        let m = this.mask;
        var v0 = s_pv_undef<[V, U]>();
        var v1 = s_pv_undef<[V, U]>();
        var v2 = s_pv_undef<[V, U]>();
        var v3 = s_pv_undef<[V, U]>();

        if(m.bit0) {
            v0 = [this.v0, getfn(idx)];
        }

        if(m.bit1) {
            v1 = [this.v1, getfn(idx + 1n)];
        }

        if(m.bit2) {
            v2 = [this.v2, getfn(idx + 2n)];
        }

        if(m.bit3) {
            v3 =[this.v3, getfn(idx + 3n)];
        }
        
        return PartialVector<U>{m, v0, v1, v2, v3};
    }

    recursive? function s_reduce_fn<T, U>(pv: PartialVector<T>, init: U, p: recursive? fn(_: T) -> U): U # special_function_pv_reduce_fn
    recursive? function s_reduce_fn_idx<T, U>(pv: PartialVector<T>, init: U, idx: Nat, p: recursive? fn(_: T, _: Nat) -> U): U # special_function_pv_reduce_fn_idx

    recursive? function s_transduce_fn<T, U, E>(pv: PartialVector<T>, init: E, p: recursive? fn(_: T, _: E) -> U, E): PartialVector<U> # special_function_pv_transduce_fn
    recursive? function s_transduce_fn_idx<T, U, E>(pv: PartialVector<T>, init: E, idx: Nat, p: recursive? fn(_: T, _: E, _: Nat) -> U, E): PartialVector<U> # special_function_pv_transduce_fn_idx

    recursive? method sort2(cmp: recursive? pred(_: T, _: T) -> Bool): PartialVector<U> {
        assert(Mask::s_count(this.mask) <= 2n);

        if(Mask::s_count(this.mask) == 2n && cmp[recursive?](this.v1, this.v0)) {
            return PartialVector<T>{this.mask, this.v1, this.v0, this.v2, this.v3};
        }
    }
}
#endif
