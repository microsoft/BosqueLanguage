//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if EXEC_LIBS
internal entity Mask provides Some {
    field bit0: Bool;
    field bit1: Bool;
    field bit2: Bool;
    field bit3: Bool;

    function initk(k: Nat): Mask {
        return Mask{k >= 1, k >= 2, k >= 3, k >= 4};
    }

    __safe function s_min_set(m: Mask): Nat = mask_min_set;
    __safe function s_max_set(m: Mask): Nat = mask_max_set;
    __safe function s_count(m: Mask): Nat = mask_count;

    method empty(): Bool {
        return !\/(this.bit0, this.bit1, this.bit2, this.bit3);
    }

    method count(): Nat {
        return Mask::s_count(this);
    }

    method some_true(): Bool {
        return \/(this.bit0, this.bit1, this.bit2, this.bit3);
    }

    method min(): Nat? {
        if(this.empty()) {
            return none;
        }
        else {
            return Mask::s_min_set(this);
        }
    }

    method max(): Nat? {
        if(this.empty()) {
            return none;
        }
        else {
            return Mask::s_max_set(this);
        }
    }

    function and(m1: Mask, m2: Mask): Mask {
        return Mask{/\(m1.bit0, m2.bit0), /\(m1.bit1, m2.bit1), /\(m1.bit2, m2.bit2), /\(m1.bit3, m2.bit3)};
    }

    function or(m1: Mask, m2: Mask): Mask  {
        return Mask{\/(m1.bit0, m2.bit0), \/(m1.bit1, m2.bit1), \/(m1.bit2, m2.bit2), \/(m1.bit3, m2.bit3)};
    }
}

__safe internal function s_pv_undef<T>(): T = special_function;
internal function s_phi_assign() = special_function;

internal entity PartialVector<T> provides Some {
    __safe function s_safe_get(pv: PartialVector<T>, i: Nat): T = pv_safe_get;
    __safe function s_append(pv1: PartialVector<T>, count1: Nat, pv2: PartialVector<T>, count2: Nat): PartialVector<T> = pv_append;
    __safe function s_slice_start(pv: PartialVector<T>, start: Nat, end: Nat): PartialVector<T> = pv_slice_start;
    __safe function s_slice_end(pv: PartialVector<T>, start: Nat, end: Nat): PartialVector<T> = pv_slice_end;
    __safe function s_reverse(pv: PartialVector<T>, count: Nat): PartialVector<T> = pv_reverse;

    field mask: Mask;
    field v0: T;
    field v1: T;
    field v2: T;
    field v3: T;
    
    method select(m: Mask): PartialVector<T> {
        var v0 = s_pv_undef<U>();
        var v1 = s_pv_undef<U>();
        var v2 = s_pv_undef<U>();
        var v3 = s_pv_undef<U>();

        var i = 0;
        if(m.bit0) {
            v0 = this.v0;
            i = i + 1;
        }

        if(m.bit1) {
            s_phi_assign(v0, v1, v2, v3, i, this.v1);
            i = i + 1;
        }

        if(m.bit2) {
            s_phi_assign(v0, v1, v2, v3, i, this.v2);
            i = i + 1;
        }

        if(m.bit3) {
            s_phi_assign(v0, v1, v2, v3, i, this.v3);
            i = i + 1;
        }

        return PartialVector<T>{Mask::initk(i), v0, v1, v2, v3};
    }


    recursive? method apply_pred(p: recursive? pred(_: T) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit0) {
            b0 = p[recursive?](this.v0);
        }

        if(m.bit1) {
            b1 = p[recursive?](this.v1);
        }

        if(m.bit2) {
            b2 = p[recursive?](this.v2);
        }

        if(m.bit3) {
            b3 = p[recursive?](this.v3);
        }

        return Mask{b0, b1, b2, b3};
    }

    recursive? method apply_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit0) {
            b0 = p[recursive?](this.v0, idx);
        }

        if(m.bit1) {
            b1 = p[recursive?](this.v1, idx + 1n);
        }

        if(m.bit2) {
            b2 = p[recursive?](this.v2, idx + 2n);
        }

        if(m.bit3) {
            b3 = p[recursive?](this.v3, idx + 3n);
        }
        
        return Mask{b0, b1, b2, b3};
    }

    recursive? method find_pred(p: recursive? pred(_: T) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit0) {
            b0 = p[recursive?](this.v0);
        }

        if(/\(!b0, m.bit1)) {
            b1 = p[recursive?](this.v1);
        }

        if(/\(!b0, !b1, m.bit2)) {
            b2 = p[recursive?](this.v2);
        }

        if(/\(!b0, !b1, !b2, m.bit3)) {
            b3 = p[recursive?](this.v3);
        }
        
        return Mask{b0, b1, b2, b3};
    }

    recursive? method find_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit0) {
            b0 = p[recursive?](this.v0, idx);
        }

        if(/\(!b0, m.bit1)) {
            b1 = p[recursive?](this.v1, idx + 1n);
        }

        if(/\(!b0, !b1, m.bit2)) {
            b2 = p[recursive?](this.v2, idx + 2n);
        }

        if(/\(!b0, !b1, !b2, m.bit3)) {
            b3 = p[recursive?](this.v3, idx + 3n);
        }
        
        return Mask{b0, b1, b2, b3};
    }

    recursive? method s_find_last_pred(p: recursive? pred(_: T) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit3) {
            b3 = p[recursive?](this.v3);
        }

        if(/\(!b3, m.bit2)) {
            b2 = p[recursive?](this.v2);
        }

        if(/\(!b3, !b2, m.bit1)) {
            b1 = p[recursive?](this.v1);
        }

        if(/\(!b3, !b2, !b1, m.bit0)) {
            b0 = p[recursive?](this.v0);
        }
        
        return Mask{b0, b1, b2, b3};
    }

    recursive? method s_find_last_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Mask {
        let m = this.mask;
        var b0 = false;
        var b1 = false;
        var b2 = false;
        var b3 = false;

        if(m.bit3) {
            b3 = p[recursive?](this.v3, idx + 3n);
        }

        if(/\(!b3, m.bit2)) {
            b2 = p[recursive?](this.v2, idx + 2n);
        }

        if(/\(!b3, !b2, m.bit1)) {
            b1 = p[recursive?](this.v1, idx + 1n);
        }

        if(/\(!b3, !b2, !b1, m.bit0)) {
            b0 = p[recursive?](this.v0, idx);
        }
        
        return Mask{b0, b1, b2, b3};
    }

    recursive? method s_map_fn<T, U>(f: recursive? fn(_: T) -> U): PartialVector<U> {
        let m = this.mask;
        var v0 = s_pv_undef<U>();
        var v1 = s_pv_undef<U>();
        var v2 = s_pv_undef<U>();
        var v3 = s_pv_undef<U>();

        if(m.bit0) {
            v0 = f[recursive?](this.v0);
        }

        if(m.bit1) {
            v1 = f[recursive?](this.v1);
        }

        if(m.bit2) {
            v2 = f[recursive?](this.v2);
        }

        if(m.bit3) {
            v3 = f[recursive?](this.v3);
        }
        
        return PartialVector<U>{m, v0, v1, v2, v3};
    }
    
    recursive? method s_map_fn_idx<T, U>(idx: Nat, p: recursive? fn(_: T, _: Nat) -> U): PartialVector<U> {
        let m = this.mask;
        var v0 = s_pv_undef<U>();
        var v1 = s_pv_undef<U>();
        var v2 = s_pv_undef<U>();
        var v3 = s_pv_undef<U>();

        if(m.bit0) {
            v0 = f[recursive?](this.v0, idx);
        }

        if(m.bit1) {
            v1 = f[recursive?](this.v1, idx + 1n);
        }

        if(m.bit2) {
            v2 = f[recursive?](this.v2, idx + 2n);
        }

        if(m.bit3) {
            v3 = f[recursive?](this.v3, idx + 3n);
        }
        
        return PartialVector<U>{m, v0, v1, v2, v3};
    }

    function {when T unique Int | Nat} s_range(start: T, end: T, inc: T, zero: T): PartialVector<T> {
        let m = Mask::s_init_k(count);

        if(count <= 1n) {
            return PartialVector<T>{m, start, zero, zero, zero};
        }
        else {
            let e1 = start + inc;
            if(count == 2n) {
                return PartialVector<T>{m, start, e1, zero, zero};
            }
            else {
                let e2 = e1 + inc;
                if(count == 3n) {
                    return PartialVector<T>{m, start, e1, e2, zero};
                }
                else {
                    let e3 = e2 + inc;
                    return PartialVector<T>{m, start, e1, e2, e3};
                }
            }
        }
    }

    function s_fill(count: Nat, v: T): PartialVector<T> {
        let m = Mask::s_init_k(count);

        var v0 = s_pv_undef<T>();
        var v1 = s_pv_undef<T>();
        var v2 = s_pv_undef<T>();
        var v3 = s_pv_undef<T>();

        if(m.bit0) {
            v0 = v;
        }

        if(m.bit1) {
            v1 = v;
        }

        if(m.bit2) {
            v2 = v;
        }

        if(m.bit3) {
            v3 = v;
        }
        
        return PartialVector<T>{m, v0, v1, v2, v3};
    }

    method s_zip_index<T>(idx: Nat): PartialVector<[Nat, T]> {
        let m = this.mask;
        var v0 = s_pv_undef<[Nat, T]>();
        var v1 = s_pv_undef<[Nat, T]>();
        var v2 = s_pv_undef<[Nat, T]>();
        var v3 = s_pv_undef<[Nat, T]>();

        if(m.bit0) {
            v0 = [idx, this.v0];
        }

        if(m.bit1) {
            v1 = [idx + 1n, this.v1];
        }

        if(m.bit2) {
            v2 = [idx + 2n, this.v2];
        }

        if(m.bit3) {
            v3 = [idx + 3n, this.v3];
        }
        
        return PartialVector<[Nat, T]>{m, v0, v1, v2, v3};
    }

    method s_zip<U>(ov: PartialVector<U>): PartialVector<[T, U]> {
        let tm = this.mask;
        let om = ov.mask;

        var v0 = s_pv_undef<[T, U]>();
        var v1 = s_pv_undef<[T, U]>();
        var v2 = s_pv_undef<[T, U]>();
        var v3 = s_pv_undef<[T, U]>();

        if(/\(tm.bit0, om.bit0)) {
            v0 = [this.v0, ov.v0];
        }

        if(/\(tm.bit1, om.bit1)) {
            v1 = [this.v1, ov.v1];
        }

        if(/\(tm.bit2, om.bit2)) {
            v2 = [this.v2, ov.v2];
        }

        if(/\(tm.bit3, om.bit3)) {
            v3 = [this.v3, ov.v3];
        }
        
        return PartialVector<[T, U]>{Mask::and(tm, om), v0, v1, v2, v3};
    }

    method s_zip_map<U>(idx: i, getfn: fn(i: Nat) -> U): PartialVector<[T, U]> {
        let m = this.mask;
        var v0 = s_pv_undef<[T, U]>();
        var v1 = s_pv_undef<[T, U]>();
        var v2 = s_pv_undef<[T, U]>();
        var v3 = s_pv_undef<[T, U]>();

        if(m.bit0) {
            v0 = [this.v0, getfn(idx)];
        }

        if(m.bit1) {
            v1 = [this.v1, getfn(idx + 1n)];
        }

        if(m.bit2) {
            v2 = [this.v2, getfn(idx + 2n)];
        }

        if(m.bit3) {
            v3 = [this.v3, getfn(idx + 3n)];
        }
        
        return PartialVector<[T, U]>{m, v0, v1, v2, v3};
    }

    recursive? method s_min_arg<T, U unique Orderable>(f: recursive? fn(v: T) -> U): Nat, U {
        let m = this.mask;
        var minidx = 0n;
        var minval = f[recursive?](this.v0);

        if(m.bit1) {
            let v1 = f[recursive?](this.v1);
            if(v1 < minval) {
                minidx = 1n;
                minval = v1;
            }
        }

        if(m.bit2) {
            let v2 = f[recursive?](this.v2);
            if(v2 < minval) {
                minidx = 2n;
                minval = v2;
            }
        }

        if(m.bit3) {
            let v3 = f[recursive?](this.v3);
            if(v3 < minval) {
                minidx = 3n;
                minval = v3;
            }
        }
        
        return minidx, minval;
    }

    recursive? method s_max_arg<T, U unique Orderable>(f: recursive? fn(v: T) -> U): Nat, U {
        let m = this.mask;
        var maxidx = 0n;
        var maxval = f[recursive?](this.v0);

        if(m.bit1) {
            let v1 = f[recursive?](this.v1);
            if(v1 > maxval) {
                maxidx = 1n;
                maxval = v1;
            }
        }

        if(m.bit2) {
            let v2 = f[recursive?](this.v2);
            if(v2 > maxval) {
                maxidx = 2n;
                maxval = v2;
            }
        }

        if(m.bit3) {
            let v3 = f[recursive?](this.v3);
            if(v3 > maxval) {
                maxidx = 3n;
                maxval = v3;
            }
        }
        
        return maxidx, maxval;
    }

    method {when T unique Algebraic} s_sum(iv: T): T {
        let m = this.mask;
        var acc = iv;

        if(m.bit0) {
            acc = acc + this.v0;
        }

        if(m.bit1) {
            acc = acc + this.v1;
        }

        if(m.bit2) {
            acc = acc + this.v2;
        }

        if(m.bit3) {
            acc = acc + this.v3;
        }
        
        return acc;
    }

    method s_parallel_sum<T unique Algebraic>(iv: T): T {
        let m = this.mask;
        
        var v0= iv;
        if(m.bit0) {
            v0 = this.v0;
        }

        var v1 = iv;
        if(m.bit1) {
            v1 = this.v1;
        }

        var v2 = iv;
        if(m.bit2) {
            v2 = this.v2;
        }

        var v3 = iv;
        if(m.bit3) {
            v3 = this.v3;
        }
        
        return v0 + v1 + v2 + v3;
    }

    recursive? method s_partition(piv: T, cmp: recursive? pred(_: T, _: T) -> Bool): PartialVector<T>, PartialVector<T>, PartialVector<T> {
        let m = this.mask;

        var b0l = false;
        var b0g = false;
        var b0e = false;
        if(m.bit0) {
            b0l = cmp[recursive?](this.v0, piv);
            b0g = cmp[recursive?](piv, this.v0);
            b0e = /\(!b0l, b0g);
        }

        var b1l = false;
        var b1g = false;
        var b1e = false;
        if(m.bit1) {
            b1l = cmp[recursive?](this.v1, piv);
            b1g = cmp[recursive?](piv, this.v1);
            b1e = /\(!b1l, b1g);
        }

        var b2l = false;
        var b2g = false;
        var b2e = false;
        if(m.bit2) {
            b2l = cmp[recursive?](this.v2, piv);
            b2g = cmp[recursive?](piv, this.v2);
            b2e = /\(!b2l, b2g);
        }

        var b3l = false;
        var b3g = false;
        var b3e = false;
        if(m.bit3) {
            b3l = cmp[recursive?](this.v3, piv);
            b3g = cmp[recursive?](piv, this.v3);
            b3e = /\(!b3l, b3g);
        }

        let ml = Mask{b0l, b1l, b2l, b3l};
        let me = Mask{b0e, b1e, b2e, b3e};
        let mg = Mask}b0g, b1g, b2g, b3g};
        return this.select(ml), this.select(me), this.select(mg);
    }

    recursive? method s_sort(cmp: recursive? pred(_: T, _: T) -> Bool): PartialVector<T> {
        let count = this.mask.count();

        if(count == 1n) {
            return this;
        }
        else {
            let minxidx, minval, maxidx, maxval = this.s_min_max_for_sort[recursive?](cmp);
            if(/\(minidx == 0, maxidx == count) {
                return this;
            }
            else {
                let v = s_pv_undef<T>();
                if(count == 2n) {
                    return PartialVector<T>{this.mask, minval, maxval, v, v};
                }
                elif(count == 3n) {
                    let mval = this.s_mid3(minidx, maxidx);
                    return PartialVector<T>{this.mask, minval, mval, maxval, v};
                }
                else {
                    let imid1, vmid1, imid2, vmid2 = this.s_mid4(minxidx, maxidx);
                    if(cmp[recursive?](vmid1, vmid2)) {
                        return PartialVector<T>{this.mask, minval, vmid1, vmid2, maxval};
                    }
                    elif(cmp[recursive?](vmid2, vmid1)) {
                        return PartialVector<T>{this.mask, minval, vmid2, vmid1, maxval};
                    }
                    else {
                        if(imid1 < imid2) {
                            return PartialVector<T>{this.mask, minval, vmid1, vmid2, maxval};
                        }
                        else {
                            return PartialVector<T>{this.mask, minval, vmid2, vmid1, maxval};
                        }
                    }
                }
            }
        }
    }

    recursive? method s_min_max_for_sort(cmp: recursive? pred(_: T, _: T) -> Bool): Nat, T, Nat, T {
        let m = this.mask;

        var minidx = 0n;
        var minval = this.v0;
        var maxidx = 0n;
        var maxval = this.v0;

        if(m.bit1) {
            let v1 = this.v1;
            if(cmp[recursive?](v1, minval)) {
                minidx = 1n;
                minval = v1;
            }
            if(!cmp[recursive?](maxval, v1)) {
                maxidx = 1n;
                maxval = v1;
            }
        }

        if(m.bit2) {
            let v2 = this.v2;
            if(cmp[recursive?](v2, minval)) {
                minidx = 2n;
                minval = v2;
            }
            if(!cmp[recursive?](maxval, v2)) {
                maxidx = 2n;
                maxval = v2;
            }
        }

        if(m.bit3) {
            let v3 = this.v3;
            if(cmp[recursive?](v3, minval)) {
                minidx = 3n;
                minval = v3;
            }
            if(!cmp[recursive?](maxval, v3)) {
                maxidx = 3n;
                maxval = v3;
            }
        }
        
        return minidx, minval, maxidx, maxval;
    }

    method s_mid3(minxidx: Nat, maxidx: Nat): T {
        if(/\(minidx != 0n, maxidx != 0n)) {
            return this.v0;
        }
        elif(/\(minidx != 1n, maxidx != 1n)) {
            return this.v1;
        }
        else {
            return this.v2;
        }
    }

    method s_mid4(minxidx: Nat, maxidx: Nat): Nat, T, Nat, T {
        var imid1: Nat? = none;
        var vmid1 = s_pv_undef<T>();
        var imid2: Nat? = none;
        var vmid2 = s_pv_undef<T>();

        if(/\(minidx != 0n, maxidx != 0n)) {
            imid1 = 0n;
            vmid1 = this.v0;
        }

        if(/\(minidx != 1n, maxidx != 1n)) {
            if(imid1 === none) {
                imid1 = 1n;
                vmid1 = this.v1;
            }
            else {
                imid2 = 1n;
                vmid2 = this.v1;
            }
        }

        if(/\(minidx != 2n, maxidx != 2n)) {
            if(imid1 === none) {
                imid1 = 2n;
                vmid1 = this.v2;
            }
            else {
                imid2 = 2n;
                vmid2 = this.v2;
            }
        }
        
        if(/\(minidx != 3n, maxidx != 3n)) {
            imid2 = 3n;
            vmid2 = this.v3;
        }

        return ListOps::s_safeAs<Nat?, Nat>(imid1), vmid1, ListOps::s_safeAs<Nat?, Nat>(imid2), vmid2;
    }

    method s_reverse(): PartialVector<T> {
        return PartialVector<T>::s_reverse(this, Mask::s_count(this.mask));
    }

    recursive? method s_reduce_fn<U>(init: U, op: recursive? fn(_: T, _: U) -> U): U {
        let m = this.mask;
        var uu = init;

        if(m.bit0) {
            uu = op[recursive?](this.v0, uu);
        }

        if(m.bit1) {
            uu = op[recursive?](this.v1, uu);
        }

        if(m.bit2) {
            uu = op[recursive?](this.v2, uu);
        }

        if(m.bit3) {
            uu = op[recursive?](this.v3, uu);
        }
        
        return uu;
    }

    recursive? method s_reduce_fn_idx<U>(init: U, idx: Nat, op: recursive? fn(_: T, _: U, _: Nat) -> U): U {
        let m = this.mask;
        var uu = init;

        if(m.bit0) {
            uu = op[recursive?](this.v0, uu, idx);
        }

        if(m.bit1) {
            uu = op[recursive?](this.v1, uu, idx + 1n);
        }

        if(m.bit2) {
            uu = op[recursive?](this.v2, uu, idx + 2n);
        }

        if(m.bit3) {
            uu = op[recursive?](this.v3, uu, idx + 3n);
        }
        
        return uu;
    }

    recursive? method s_transduce_fn<U, E>(init: E, op: recursive? fn(_: T, _: E) -> U, E): PartialVector<U>, E {
        let m = this.mask;

        var v0 = s_pv_undef<U>();
        var v1 = s_pv_undef<U>();
        var v2 = s_pv_undef<U>();
        var v3 = s_pv_undef<U>();

        var ee = init;

        if(m.bit0) {
            v0, ee = op[recursive?](this.v0, ee);
        }

        if(m.bit1) {
            v1, ee = op[recursive?](this.v1, ee);
        }

        if(m.bit2) {
            v2, ee = op[recursive?](this.v2, ee);
        }

        if(m.bit3) {
            v3, ee = op[recursive?](this.v3, ee);
        }
        
        return PartialVector<U>{m, v0, v1, v2, v3}, ee;
    }

    recursive? method s_transduce_fn_idx<U, E>(init: E, idx: Nat, op: recursive? fn(_: T, _: E, _: Nat) -> U, E): PartialVector<U>, E {
        let m = this.mask;

        var v0 = s_pv_undef<U>();
        var v1 = s_pv_undef<U>();
        var v2 = s_pv_undef<U>();
        var v3 = s_pv_undef<U>();

        var ee = init;

        if(m.bit0) {
            v0, ee = op[recursive?](this.v0, ee, idx);
        }

        if(m.bit1) {
            v1, ee = op[recursive?](this.v1, ee, idx + 1n);
        }

        if(m.bit2) {
            v2, ee = op[recursive?](this.v2, ee, idx + 2n);
        }

        if(m.bit3) {
            v3, ee = op[recursive?](this.v3, ee, idx + 3n);
        }
        
        return PartialVector<U>{m, v0, v1, v2, v3}, ee;
    }
}
#endif
