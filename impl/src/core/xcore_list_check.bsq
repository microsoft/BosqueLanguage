//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if CHECK_LIBS
internal typedef ListVector<T> = Vector1<T> | Vector2<T> | Vector3<T> | Vector4<T>;

internal typedef ListRepr<T> = None | Vector1<T> | Vector2<T> | Vector3<T> | Vector4<T> | SeqList<T>;

internal entity ListOps provides Some {
    internal function s_into<T>(l: ListRepr<T>): List<T> = special_inject;
    internal function s_value<T>(l: List<T>): ListRepr<T> = special_extract;

    internal function s_vector_to_seqlist<T>(l: ListVector<T>): SeqList<T> {

        xxxx; //TODO here!!!!!!!!!!!!

        if(ll.is<Vector1<T>>()) {
            return 1n;
        }
        elif(ll.is<Vector2<T>>()) {
            return 2n;
        }
        elif(ll.is<Vector3<T>>()) {
            return 3n;
        }
        elif(ll.is<Vector4<T>>()) {
            return 4n;
        }
    }

    internal function s_seqlist_to_vector_or_none<T>(l: SeqList<T>, len: Nat): ListVector<T> | None {
        if(len == 0n) {
            return none;
        }
        elif(len == 1n) {
            return Vector1<T>{SeqListOps::s_list_get<T>(l, 0)};
        }
        elif(len == 2n) {
            return Vector2<T>{SeqListOps::s_list_get<T>(l, 0), SeqListOps::s_list_get<T>(l, 1)};
        }
        elif(len == 3n) {
            return Vector3<T>{SeqListOps::s_list_get<T>(l, 0), SeqListOps::s_list_get<T>(l, 1), SeqListOps::s_list_get<T>(l, 2)};
        }
        else {
            return Vector4<T>{SeqListOps::s_list_get<T>(l, 0), SeqListOps::s_list_get<T>(l, 1), SeqListOps::s_list_get<T>(l, 2), SeqListOps::s_list_get<T>(l, 3)};
        }
    }

    internal function s_list_index_int(start: Int, end: Int, len: Int): List<Int> {
        if(len == 0i) {
            return ListOps::s_into<Int>(none);
        }
        elif(len == 1i) {
            return ListOps::s_into<Int>(Vector1<Int>{start});
        }
        elif(len == 2i) {
            return ListOps::s_into<Int>(Vector2<Int>{start, start + 1i});
        }
        elif(len == 3i) {
            return ListOps::s_into<Int>(Vector3<Int>{start, start + 1i, start + 2i});
        }
        elif(len == 4i) {
            return ListOps::s_into<Int>(Vector4<Int>{start, start + 1i, start + 2i, start + 3i});
        }
        else {
            return ListOps::s_into<Int>(SeqListOps::s_list_index_int(start, end, len));
        }
    }

    internal function s_list_index_nat(start: Nat, end: Nat, len: Nat): List<Nat> {
        if(len == 0n) {
            return ListOps::s_into<Nat>(none);
        }
        elif(len == 1n) {
            return ListOps::s_into<Nat>(Vector1<Nat>{start});
        }
        elif(len == 2n) {
            return ListOps::s_into<Nat>(Vector2<Nat>{start, start + 1n});
        }
        elif(len == 3n) {
            return ListOps::s_into<Nat>(Vector3<Nat>{start, start + 1n, start + 2n});
        }
        elif(len == 4n) {
            return ListOps::s_into<Nat>(Vector4<Nat>{start, start + 1n, start + 2n, start + 3n});
        }
        else {
            return ListOps::s_into<Nat>(SeqListOps::s_list_index_nat(start, end, len));
        }
    }

    internal function s_list_empty<T>(l: List<T>): Bool {
        return ListOps::s_value<T>(l) === none;
    }

    internal function s_list_size<T>(l: List<T>): Nat {
        let ll = ListOps::s_value<T>(l);

        if(ll === none) {
            return 0n;
        }
        elif(ll.is<Vector1<T>>()) {
            return 1n;
        }
        elif(ll.is<Vector2<T>>()) {
            return 2n;
        }
        elif(ll.is<Vector3<T>>()) {
            return 3n;
        }
        elif(ll.is<Vector4<T>>()) {
            return 4n;
        }
        else {
            return SeqListOps::s_list_size<T>(l);
        }
    }

    internal function s_list_fill<T>(count: Nat, v: T): List<T> {
        if(len == 0n) {
            return ListOps::s_into<T>(none);
        }
        elif(len == 1n) {
            return ListOps::s_into<T>(Vector1<T>{v});
        }
        elif(len == 2n) {
            return ListOps::s_into<T>(Vector2<T>{v, v});
        }
        elif(len == 3n) {
            return ListOps::s_into<T>(Vector3<T>{v, v, v});
        }
        elif(len == 4n) {
            return ListOps::s_into<T>(Vector4<T>{v, v, v, v});
        }
        else {
            return ListOps::s_into<T>(SeqListOps::s_list_fill<T>(count, v));
        }
    }

    internal function s_list_append<T>(ll: List<T>, rr: List<T>): List<T> {

    }

    /*
    __safe internal function s_list_get<T>(l: List<T>, idx: Nat): T = s_list_get; 
    __safe internal function s_list_back<T>(l: List<T>): T = s_list_get_back; 
    __safe internal function s_list_front<T>(l: List<T>): T = s_list_get_front; 

    __safe internal function s_list_slice_front<T>(l: List<T>, idx: Nat): List<T> = s_list_slice_front; 
    __safe internal function s_list_slice_end<T>(l: List<T>, idx: Nat): List<T> = s_list_slice_end;
    __safe internal function s_list_slice<T>(l: List<T>, start: Nat, length: Nat): List<T> = s_list_slice; 

    __safe internal function s_list_set<T>(l: List<T>, idx: Nat, v: T): List<T> = s_list_set; 
    __safe internal function s_list_push_back<T>(l: List<T>, v: T): List<T> = s_list_push_back; 
    __safe internal function s_list_push_front<T>(l: List<T>, v: T): List<T> = s_list_push_front; 
    __safe internal function s_list_insert<T>(l: List<T>, idx: Nat, v: T): List<T> = s_list_insert;

    __safe internal function s_list_remove<T>(l: List<T>, idx: Nat): List<T> = s_list_remove; 
    __safe internal function s_list_pop_back<T>(l: List<T>): List<T> = s_list_pop_back; 
    __safe internal function s_list_pop_front<T>(l: List<T>): List<T> = s_list_pop_front; 

    __conditional_safe internal recursive? function s_list_map_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<Bool> = s_list_map_pred;
    __conditional_safe internal recursive? function s_list_map_pred_idx<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): List<Bool> = s_list_map_pred_idx;
    __conditional_safe internal recursive? function s_list_map_fn<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> = s_list_map_fn;
    __conditional_safe internal recursive? function s_list_map_fn_idx<T, U>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> U): List<U> = s_list_map_fn_idx;
    __conditional_safe internal recursive? function s_list_map_fn_sync<T, U, V>(l1: List<T>, l2: List<U>, f: recursive? fn(_: T, _: U) -> V): List<V> = s_list_map_sync;

    __safe internal function s_list_has<T>(l: List<T>, v: T): Bool = s_list_has; 
    __safe internal function s_list_indexof<T>(l: List<T>, v: T): Int = s_list_indexof; 
    __safe internal function s_list_last_indexof<T>(l: List<T>, v: T): Int = s_list_last_indexof; 

    __safe internal function s_list_has_true(l: List<Bool>): Bool = s_list_has_true; 
    __safe internal function s_list_has_false(l: List<Bool>): Bool = s_list_has_false;

    __safe internal function s_list_all_true(l: List<Bool>): Bool = s_list_all_true; 
    __safe internal function s_list_all_false(l: List<Bool>): Bool = s_list_all_false; 

    __safe internal function s_list_single_true(l: List<Bool>): Bool = s_list_single_true; 
    __safe internal function s_list_single_indexof_true(l: List<Bool>): Int = s_list_single_indexof_true; 

    __safe internal function s_list_indexof_true(l: List<T>): Int = s_list_indexof_true; 
    __safe internal function s_list_last_indexof_true(l: List<T>): Int = s_list_last_indexof_true;

    __safe internal function s_list_mask_select<T>(l: List<T>, mask: List<Bool>): List<T> = s_list_mask_select;
    __safe internal function s_list_cast<T, U>(l: List<T>): List<U> = s_list_cast;
    __safe internal function s_list_mask_select_cast<T, U>(l: List<T>, mask: List<Bool>): List<U> = s_list_mask_select_cast;

    __conditional_safe internal recursive? function s_list_is_sorted<T>(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): Bool = s_list_is_sorted;
    __conditional_safe internal recursive? function s_list_is_unique<T>(l: List<T>, eq: recursive? pred(_: T, _: T) -> Bool): List<T> = s_list_is_unique;

    __conditional_safe internal recursive? function s_list_reduce<T, U>(l: List<T>, init: U, f: recursive? fn(_: U, _: T) -> U): U = s_list_reduce;
    __conditional_safe internal recursive? function s_list_reduce_idx<T, U>(l: List<T>, init: U, f: recursive? fn(_: U, _: T, _: Nat) -> U): U = s_list_reduce_idx;

    __conditional_safe internal recursive? function s_list_transduce<T, E, U>(l: List<T>, env: E, op: recursive? fn(_: E, _: T) -> (|E, U|)): (|E, List<U>|) = s_list_transduce;
    __conditional_safe internal recursive? function s_list_transduce_idx<T, E, U>(l: List<T>, env: E, op: recursive? fn(_: E, _: T, _: Nat) -> (|E, U|)): (|E, List<U>|) = s_list_transduce_idx;
*/
}
#endif
