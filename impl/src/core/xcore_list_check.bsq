//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if CHECK_LIBS
internal entity ListOps provides Some {
    internal function s_blockingfailure<T>(): T = s_blockingfailure; 

    internal function s_list_index_int(start: Int, end: Int, len: Int): List<Int> = s_list_range_int;
    internal function s_list_index_nat(start: Nat, end: Nat, len: Nat): List<Nat> = s_list_range_nat;

    __safe internal function s_list_empty<T>(l: List<T>): Bool = s_list_empty; 
    __safe internal function s_list_size<T>(l: List<T>): Nat = s_list_size; 

    __safe internal function s_list_append<T>(l: List<T>, r: List<T>): List<T> = s_list_append;

    __safe internal function s_list_slice_front<T>(l: List<T>, idx: Nat): List<T> = s_list_slice_front; 
    __safe internal function s_list_slice_end<T>(l: List<T>, idx: Nat): List<T> = s_list_slice_end;
    __safe internal function s_list_slice<T>(l: List<T>, start: Nat, length: Nat): List<T> = s_list_slice; 

    __safe internal function s_list_get<T>(l: List<T>, idx: Nat): T = s_list_get; 
    __safe internal function s_list_get_back<T>(l: List<T>): T = s_list_get_back; 
    __safe internal function s_list_get_front<T>(l: List<T>): T = s_list_get_front; 

    __safe internal function s_list_set<T>(l: List<T>, idx: Nat, v: T): List<T> = s_list_set; 
    __safe internal function s_list_push_back<T>(l: List<T>, v: T): List<T> = s_list_push_back; 
    __safe internal function s_list_push_front<T>(l: List<T>, v: T): List<T> = s_list_push_front; 

    __safe internal function s_list_remove<T>(l: List<T>, idx: Nat): List<T> = s_list_remove; 
    __safe internal function s_list_pop_back<T>(l: List<T>): List<T> = s_list_pop_back; 
    __safe internal function s_list_pop_front<T>(l: List<T>): List<T> = s_list_pop_front; 

    __conditional_safe internal recursive? function s_list_map_pred<T>(l: List<T>, p: recursive? pred(_: T) -> Bool): List<Bool> = s_list_map_pred;
    __conditional_safe internal recursive? function s_list_map_pred_idx<T>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool): List<Bool> = s_list_map_pred_idx;
    __conditional_safe internal recursive? function s_list_map_fn<T, U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> = s_list_map_fn;
    __conditional_safe internal recursive? function s_list_map_fn_idx<T, U>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> U): List<U> = s_list_map_fn_idx;

    __safe internal function s_list_has<T>(l: List<T>, v: T): Bool = s_list_has; 
    __safe internal function s_list_indexof<T>(l: List<T>, v: T): Int = s_list_indexof; 
    __safe internal function s_list_last_indexof<T>(l: List<T>, v: T): Int = s_list_last_indexof; 

    __safe internal function s_list_has_true(l: List<Bool>): Bool = s_list_has_true; 
    __safe internal function s_list_has_false(l: List<Bool>): Bool = s_list_has_false; 
    __safe internal function s_list_single_true(l: List<Bool>): Bool = s_list_single_true; 
    __safe internal function s_list_single_indexof_true(l: List<Bool>): Int = s_list_single_indexof_true; 

    __safe internal function s_list_indexof_true(l: List<T>): Int = s_list_indexof_true; 
    __safe internal function s_list_last_indexof_true(l: List<T>): Int = s_list_last_indexof_true;

    __conditional_safe internal recursive? function s_list_reduce<T, U>(l: List<T>, init: U, f: recursive? fn(_: U, _: T) -> U): U = s_list_reduce;

    //TODO: minarg, maxarg, and such based on reduce
}
#endif
