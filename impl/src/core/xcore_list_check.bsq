//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

#if CHECK_LIBS
entity ListOps provides Some {
    __assume_safe function s_safeAs<T, U>(v: T): U # list_safeas

    function s_asRecList<T>(l: ListRepr<T>): RecList<T> {
        return ListOps::s_safeAs<ListRepr<T>, RecList<T>>(l);
    }

    function s_empty<T>(l: ListRepr<T>): Nat {
        return l === none;
    }

    function s_size<T>(l: ListRepr<T>): Nat {
        if(l === none) {
            return 0n;
        }
        elif(l.is<Vector1<T>>()) {
            return 1n;
        }
        elif(l.is<Vector2<T>>()) {
            return 2n;
        }
        elif(l.is<Vector3<T>>()) {
            return 3n;
        }
        else {
            return l.count;
        }
    }

    function s_safe_get<T>(l: ListRepr<T>, i: Nat): T {
        if(l.is<Vector1<T>>()) {
            return l.v0;
        }
        elif(l.is<Vector2<T>>()) {
            if(i == 0) {
                return l.v0;
            }
            else {
                return l.v1;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(i == 0) {
                return l.v0;
            }
            elif(i == 1) {
                return l.v1;
            }
            else {
                return l.v2;
            }
        }
        else {
            return ListOps::s_asRecList<T>(l).safe_get(i);
        }
    }

    recursive? function s_has_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        elif(l.is<Vector1<T>>()) {
            return p[recursive?](l.v0);
        }
        elif(l.is<Vector2<T>>()) {
            return \/(p[recursive?](l.v0), p[recursive?](l.v1));
        }
        elif(l.is<Vector3<T>>()) {
            return \/(p[recursive?](l.v0), p[recursive?](l.v1), p[recursive?](l.v2));
        }
        else {
            return l.has_pred[recursive?](p);
        }
    }

    recursive? function s_has_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        elif(l.is<Vector1<T>>()) {
            return p[recursive?](l.v0, 0n);
        }
        elif(l.is<Vector2<T>>()) {
            return \/(p[recursive?](l.v0, 0n), p[recursive?](l.v1, 1n));
        }
        elif(l.is<Vector3<T>>()) {
            return \/(p[recursive?](l.v0, 0n), p[recursive?](l.v1, 1n), p[recursive?](l.v2, 2n));
        }
        else {
            return l.has_pred_idx[recursive?](p);
        }
    }

    recursive? function s_find_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            if(p[recursive?](l.v0)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            if(p[recursive?](l.v0)) {
                return 0n;
            }
            elif(p[recursive?](l.v1)) {
                return 1n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(p[recursive?](l.v0)) {
                return 0n;
            }
            elif(p[recursive?](l.v1)) {
                return 1n;
            }
            elif(p[recursive?](l.v2)) {
                return 2n;
            }
            else {
                return none;
            }
        }
        else {
            return l.find_pred[recursive?](p);
        }
    }

    recursive? function s_find_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            if(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            if(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            elif(p[recursive?](l.v1, 1n)) {
                return 1n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            elif(p[recursive?](l.v1, 1n)) {
                return 1n;
            }
            elif(p[recursive?](l.v2, 2n)) {
                return 2n;
            }
            else {
                return none;
            }
        }
        else {
            return l.find_pred_idx[recursive?](p);
        }
    }

    recursive? function s_find_last_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            if(p[recursive?](l.v0)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            if(p[recursive?](l.v1)) {
                return 1n;
            }
            elif(p[recursive?](l.v0)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(p[recursive?](l.v2)) {
                return 2n;
            }
            elif(p[recursive?](l.v1)) {
                return 1n;
            }
            elif(p[recursive?](l.v0)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        else {
            return l.find_last_pred[recursive?](p);
        }
    }

    recursive? function s_find_last_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            if(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            if(p[recursive?](l.v1, 1n)) {
                return 1n;
            }
            elif(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(p[recursive?](l.v2, 2n)) {
                return 2n;
            }
            elif(p[recursive?](l.v1, 1n)) {
                return 1n;
            }
            elif(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        else {
            return l.find_last_pred_idx[recursive?](p);
        }
    }

    recursive? function s_filter_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0);

            if(p0) {
                return l;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0);
            let v1 = l.v1;
            let p1 = p[recursive?](v1);

            if(/\(p0, p1)) {
                return l;
            }
            elif(p0) {
                return Vector1<T>{v0};
            }
            elif(p1) {
                return Vector1<T>{v1};
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0);
            let v1 = l.v1;
            let p1 = p[recursive?](v1);
            let v2 = l.v2;
            let p2 = p[recursive?](v2);

            if(/\(p0, p1, p2)) {
                return l;
            }
            elif(/\(p0, p1)) {
                return Vector2<T>{v0, v1};
            }
            elif(/\(p0, p2)) {
                return Vector2<T>{v0, v2};
            }
            elif(/\(p1, p2)) {
                return Vector2<T>{v1, v2};
            }
            elif(p0) {
                return Vector1<T>{v0};
            }
            elif(p1) {
                return Vector1<T>{v1};
            }
            elif(p2) {
                return Vector1<T>{v2};
            }
            else {
                return none;
            }
        }
        else {
            return l.filter_pred[recursive?](p);
        }
    }

    recursive? function s_filter_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0, 0n);

            if(p0) {
                return l;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0, 0n);
            let v1 = l.v1;
            let p1 = p[recursive?](v1, 1n);

            if(/\(p0, p1)) {
                return l;
            }
            elif(p0) {
                return Vector1<T>{v0};
            }
            elif(p1) {
                return Vector1<T>{v1};
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0, 0n);
            let v1 = l.v1;
            let p1 = p[recursive?](v1, 1n);
            let v2 = l.v2;
            let p2 = p[recursive?](v2, 2n);

            if(/\(p0, p1, p2)) {
                return l;
            }
            elif(/\(p0, p1)) {
                return Vector2<T>{v0, v1};
            }
            elif(/\(p0, p2)) {
                return Vector2<T>{v0, v2};
            }
            elif(/\(p1, p2)) {
                return Vector2<T>{v1, v2};
            }
            elif(p0) {
                return Vector1<T>{v0};
            }
            elif(p1) {
                return Vector1<T>{v1};
            }
            elif(p2) {
                return Vector1<T>{v2};
            }
            else {
                return none;
            }
        }
        else {
            return l.filter_pred_idx[recursive?](p);
        }
    }

    recursive? function s_map<T, U>(l: ListRepr<T>, p: recursive? pred(_: T) -> U): ListRepr<U> {
    }

    recursive? function s_map_idx<T, U>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> U): ListRepr<U> {
    }
}

entity RecList<T> provides Some {
    field count: Nat;
    field ll RecListEntry<T>;

    method safe_get<T>(i: Nat): T {
        return this.ll.safe_get[recursive](ll, i);
    }

    recursive? method has_pred(p: recursive? pred(_: T) -> Bool): Bool {
        return this.ll.has_pred[recursive](p);
    }

    recursive? method has_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return this.ll.has_pred_idx[recursive](0n, p);
    }

    recursive? method find_pred(p: recursive? pred(_: T) -> Bool): Nat? {
        return this.ll.find_pred[recursive](0n, p);
    }

    recursive? method find_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        return this.ll.find_pred_idx[recursive](0n, p);
    }

    recursive? method find_last_pred(p: recursive? pred(_: T) -> Bool): Nat? {
        return this.ll.find_last_pred[recursive](0n, p);
    }

    recursive? method find_last_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        return this.ll.find_last_pred_idx[recursive](0n, p);
    }

    recursive? method filter_pred(p: recursive? pred(_: T) -> Bool): ListRepr<T> {
        let lle, lls = this.ll.filter_pred[recursive](p);
        return RecList<T>{lle, lls};
    }

    recursive? method filter_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): ListRepr<T> {
        let lle, lls = this.ll.filter_pred_idx[recursive](0n, p);
        return RecList<T>{lle, lls};
    }

    recursive? method map<U>(p: recursive? pred(_: T) -> U): RecList<U> {
    }

    recursive? method map_idx<U>(p: recursive? pred(_: T, _: Nat) -> U): RecList<U> {
    }
}

entity RecListEntry<T> provides Some {
    field head: T;
    field tail RecListEntry<T>?;

    recursive method safe_get(i: Nat): T {
        if(i == 0) {
            return this.head;
        }
        else {
            return ListOps::s_safeAs<RecListEntry<T>>(this.tail).safe_get[recursive](i - 1);
        }
    }

    recursive method has_pred(p: recursive? pred(_: T) -> Bool): Bool {
        if(p[recursive?](this.head)) {
            return true;
        }
        else {
            let tl = this.tail;
            if(tl === none) {
                return false;
            }
            else {
                return tl.has_pred[recursive](p);
            }
        }
    }

    recursive method has_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(p[recursive?](this.head, idx)) {
            return true;
        }
        else {
            let tl = this.tail;
            if(tl === none) {
                return false;
            }
            else {
                return tl.has_pred_idx[recursive](idx + 1n, p);
            }
        }
    }

    recursive method find_pred(idx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(p[recursive?](this.head)) {
            return idx;
        }
        else {
            let tl = this.tail;
            if(tl === none) {
                return none;
            }
            else {
                return tl.find_pred[recursive](idx + 1n, p);
            }
        }
    }

    recursive method find_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(p[recursive?](this.head, idx)) {
            return idx;
        }
        else {
            let tl = this.tail;
            if(tl === none) {
                return none;
            }
            else {
                return tl.find_pred_idx[recursive](idx + 1n, p);
            }
        }
    }

    recursive method find_last_pred(idx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let tl = this.tail;

        if(tl === none) {
            if(p[recursive?](this.head)) {
                return idx;
            }
            else {
                return none;
            }
        }
        else {
            let tres = tl.find_last_pred_idx[recursive](idx + 1n, p);

            if(tres !== none) {
                return tres;
            }
            else {
                if(p[recursive?](this.head);) {
                    return idx;
                }
                else {
                    return none;
                }
            }
        }
    }

    recursive method find_last_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let tl = this.tail;

        if(tl === none) {
            if(p[recursive?](this.head, idx)) {
                return idx;
            }
            else {
                return none;
            }
        }
        else {
            let tres = tl.find_last_pred_idx[recursive](idx + 1n, p);

            if(tres !== none) {
                return tres;
            }
            else {
                if(p[recursive?](this.head, idx)) {
                    return idx;
                }
                else {
                    return none;
                }
            }
        }
    }

    recursive method filter_pred(p: recursive? pred(_: T) -> Bool): RecListEntry<T>?, Nat {
        let tl = this.tail;
        let hh = this.head;

        let ph = p[recursive?](hh);
        if(tl === none) {
            if(ph) {
                RecListEntry<T>{hh, none}, 1n;
            }
            else {
                return none, 0n;
            }
        }
        else {
            let ntl, nts = tl.filter_pred[recursive](p);
            if(ph) {
                return RecListEntry<T>{hh, ntl}, nts + 1n;
            }
            else {
                return ntl, nts;
            }
        }
    }

    recursive method filter_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): RecListEntry<T>?, Nat {
        let tl = this.tail;
        let hh = this.head;

        let ph = p[recursive?](hh, idx);
        if(tl === none) {
            if(ph) {
                RecListEntry<T>{hh, none}, 1n;
            }
            else {
                return none, 0n;
            }
        }
        else {
            let ntl, nts = tl.filter_pred_idx[recursive](p, idx + 1n);
            if(ph) {
                return RecListEntry<T>{hh, ntl}, nts + 1n;
            }
            else {
                return ntl, nts;
            }
        }
    }

    recursive method map<U>(p: recursive? pred(_: T) -> U): RecListEntry<U> {
    }

    recursive method map_idx<U>(p: recursive? pred(_: T, _: Nat) -> U): RecListEntry<U> {
    }
}

typedef ListRepr<T> = None | Vector1<T> | Vector2<T> | Vector3<T> | RecList<T>;

#endif
