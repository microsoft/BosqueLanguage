//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

#if CHECK_LIBS
entity ListOps provides Some {
    __assume_safe function s_safeAs<T, U>(v: T): U # list_safeas

    function s_empty<T>(l: ListRepr<T>): Bool {
        return l === none;
    }

    function s_size<T>(l: ListRepr<T>): Nat {
        if(l === none) {
            return 0n;
        }
        elif(l.is<Vector1<T>>()) {
            return 1n;
        }
        elif(l.is<Vector2<T>>()) {
            return 2n;
        }
        elif(l.is<Vector3<T>>()) {
            return 3n;
        }
        else {
            return l.count;
        }
    }

    function s_range<T unique Int | Nat>(start: T, end: T, inc: T, zero: T): ListRepr<T> {
        if(start == end) {
            return none;
        }
        else {
            let count = end - start;
            if(count == 1n) {
                return Vector1<T>{start};
            }
            elif(count == 2n) {
                return Vector2<T>{start, start + inc};
            }
            elif(count == 3n) {
                return Vector3<T>{start, start + inc, start + inc + inc};
            }
            else {
                return RecList<T>::range(start, end, inc);
            }
        }
    }

    function s_fill<T>(count: Nat, v: T): ListRepr<T> {
        if(count == 0n) {
            return none;
        }
        elif(count == 1n) {
            return Vector1<T>{v};
        }
        elif(count == 2n) {
            return Vector2<T>{v, v};
        }
        elif(count == 3n) {
            return Vector3<T>{v, v, v};
        }
        else {
            return RecList<T>::fill(count, v);
        }
    }

    function s_zip_index<T>(l: ListRepr<T>): ListRepr<[Nat, T]> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return Vector1<T>{[0, l.v0]};
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>{[0, l.v0], [1, l.v1]};
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>{[0, l.v0], [1, l.v1], [2, l.v2]};
        }
        else {
            return l.zip_index();
        }
    }

    function s_zip<T, U>(l1: ListRepr<T>, l2: ListRepr<U>): ListRepr<[T, U]> {
        if(\/(l1 === none, l2 === none)) {
            return none;
        }
        elif(/\(l1.is<Vector1<T>>(), l2.is<Vector1<U>>())) {
            return Vector1<T>{[l1.v0, l2.v0]};
        }
        elif(/\(l1.is<Vector2<T>>(), l2.is<Vector2<U>>())) {
            return Vector2<T>{[l1.v0, l2.v0], [l1.v1, l2.v1]};
        }
        elif(/\(l1.is<Vector3<T>>(), l2.is<Vector3<U>>())) {
            return Vector3<T>{[l1.v0, l2.v0], [l1.v1, l2.v1], [l1.v2, l2.v2]};
        }
        else {
            let ll1 = ListOps::s_safeAs<ListRepr<T>, RecList<T>>(l1);
            let ll2 = ListOps::s_safeAs<ListRepr<U>, RecList<U>>(l2);

            return ll1.zip<U>(ll2);
        }
    }

    function s_append<T>(l: ListRepr<T>, r: ListRepr<T>): ListRepr<T> {
        if(/\(l === none, r === none)) {
            return none;
        }
        elif(l === none) {
            return r;
        }
        elif(r === none) {
            return l;
        }
        elif(/\(l.is<Vector1<T>>(), r.is<Vector1<T>>())) {
            return Vector2<T>{l.v0, r.v0};
        }
        elif(/\(l.is<Vector1<T>>(), r.is<Vector2<T>>())) {
            return Vector3<T>{l.v0, r.v0, r.v1};
        }
        elif(/\(l.is<Vector1<T>>(), r.is<Vector3<T>>())) {
            return RecList<T>{4n, RecListEntry<T>::s_append(RecListEntry<T>::s_vector1_to_list(l), RecListEntry<T>::s_vector3_to_list(r))};
        }
        elif(/\(l.is<Vector2<T>>(), r.is<Vector1<T>>())) {
            return Vector3<T>{l.v0, l.v1, r.v0};
        }
        elif(/\(l.is<Vector2<T>>(), r.is<Vector2<T>>())) {
            return RecList<T>{4n, RecListEntry<T>::s_append(RecListEntry<T>::s_vector2_to_list(l), RecListEntry<T>::s_vector2_to_list(r))};
        }
        elif(/\(l.is<Vector2<T>>(), r.is<Vector3<T>>())) {
            return RecList<T>{5n, RecListEntry<T>::s_append(RecListEntry<T>::s_vector2_to_list(l), RecListEntry<T>::s_vector3_to_list(r))};
        }
        elif(/\(l.is<Vector3<T>>(), r.is<Vector1<T>>())) {
            return RecList<T>{4n, RecListEntry<T>::s_append(RecListEntry<T>::s_vector3_to_list(l), RecListEntry<T>::s_vector1_to_list(r))};
        }
        elif(/\(l.is<Vector3<T>>(), r.is<Vector2<T>>())) {
            return RecList<T>{5n, RecListEntry<T>::s_append(RecListEntry<T>::s_vector3_to_list(l), RecListEntry<T>::s_vector2_to_list(r))};
        }
        elif(/\(l.is<Vector3<T>>(), r.is<Vector3<T>>())) {
            return RecList<T>{6n, RecListEntry<T>::s_append(RecListEntry<T>::s_vector3_to_list(l), RecListEntry<T>::s_vector3_to_list(r))};
        }
        else {
            if(/\(l.is<Vector1<T>>(), r.is<RecList<T>>())) {
                return RecList<T>{r.count + 1n, RecListEntry<T>::s_append(RecListEntry<T>::s_vector1_to_list(l), r.ll)};
            }
            elif(/\(l.is<Vector2<T>>(), r.is<RecList<T>>())) {
                return RecList<T>{r.count + 2n, RecListEntry<T>::s_append(RecListEntry<T>::s_vector2_to_list(l), r.ll)};
            }
            elif(/\(l.is<Vector3<T>>(), r.is<RecList<T>>())) {
                return RecList<T>{r.count + 3n, RecListEntry<T>::s_append(RecListEntry<T>::s_vector3_to_list(l), r.ll)};
            }
            elif(/\(l.is<RecList<T>>(), r.is<Vector1<T>>())) {
                return RecList<T>{l.count + 1n, RecListEntry<T>::s_append(l.ll, RecListEntry<T>::s_vector1_to_list(r))};
            }
            elif(/\(l.is<RecList<T>>(), r.is<Vector2<T>>())) {
                return RecList<T>{l.count + 2n, RecListEntry<T>::s_append(l.ll, RecListEntry<T>::s_vector1_to_list(r))};
            }
            elif(/\(l.is<RecList<T>>(), r.is<Vector3<T>>())) {
                return RecList<T>{l.count + 3n, RecListEntry<T>::s_append(l.ll, RecListEntry<T>::s_vector1_to_list(r))};
            }
            else {
                return RecList<T>::append(ListOps::s_safeAs<ListRepr<T>, RecList<T>>(l), ListOps::s_safeAs<ListRepr<T>, RecList<T>>(r));
            }
        }
    }

    function s_slice_start<T>(l: ListRepr<T>, start: Nat): ListRepr<T> {
        if(start == 0) {
            return l;
        }

        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return none;
        }
        elif(l.is<Vector2<T>>()) {
            if(start == 2) {
                return none;
            }
            else {
                return Vector1<T>{l.v1};
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(start == 3) {
                return none;
            }
            elif(start == 2) {
                return Vector1<T>{l.v2};
            }
            else {
                return Vector2<T>{l.v1, l.v2};
            }
        }
        else {
            if(start == l.count()) {
                return none;
            }
            else {
                return l.slice_start[recursive](start);
            }
        }
    }

    function s_slice_end<T>(l: ListRepr<T>, end: Nat): ListRepr<T> {
        if(end == 0) {
            return none;
        }

        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return l;
        }
        elif(l.is<Vector2<T>>()) {
            if(end == 2) {
                return l;
            }
            else {
                return Vector1<T>{l.v0};
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(end == 3) {
                return l;
            }
            elif(end == 2) {
                return Vector2<T>{l.v0, l.v1};
            }
            else {
                return Vector1<T>{l.v0};
            }
        }
        else {
            if(end == l.count()) {
                return l;
            }
            else {
                return l.slice_end[recursive](end);
            }
        }
    }

    function s_safe_get<T>(l: ListRepr<T>, i: Nat): T {
        if(l.is<Vector1<T>>()) {
            return l.v0;
        }
        elif(l.is<Vector2<T>>()) {
            if(i == 0) {
                return l.v0;
            }
            else {
                return l.v1;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(i == 0) {
                return l.v0;
            }
            elif(i == 1) {
                return l.v1;
            }
            else {
                return l.v2;
            }
        }
        else {
            return ListOps::s_safeAs<ListRepr<T>, RecList<T>>(l).safe_get(i);
        }
    }

    recursive? function s_has_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        elif(l.is<Vector1<T>>()) {
            return p[recursive?](l.v0);
        }
        elif(l.is<Vector2<T>>()) {
            return \/(p[recursive?](l.v0), p[recursive?](l.v1));
        }
        elif(l.is<Vector3<T>>()) {
            return \/(p[recursive?](l.v0), p[recursive?](l.v1), p[recursive?](l.v2));
        }
        else {
            return l.has_pred[recursive?](p);
        }
    }

    recursive? function s_has_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(l === none) {
            return false;
        }
        elif(l.is<Vector1<T>>()) {
            return p[recursive?](l.v0, 0n);
        }
        elif(l.is<Vector2<T>>()) {
            return \/(p[recursive?](l.v0, 0n), p[recursive?](l.v1, 1n));
        }
        elif(l.is<Vector3<T>>()) {
            return \/(p[recursive?](l.v0, 0n), p[recursive?](l.v1, 1n), p[recursive?](l.v2, 2n));
        }
        else {
            return l.has_pred_idx[recursive?](p);
        }
    }

    recursive? function s_find_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            if(p[recursive?](l.v0)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            if(p[recursive?](l.v0)) {
                return 0n;
            }
            elif(p[recursive?](l.v1)) {
                return 1n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(p[recursive?](l.v0)) {
                return 0n;
            }
            elif(p[recursive?](l.v1)) {
                return 1n;
            }
            elif(p[recursive?](l.v2)) {
                return 2n;
            }
            else {
                return none;
            }
        }
        else {
            return l.find_pred[recursive?](p);
        }
    }

    recursive? function s_find_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            if(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            if(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            elif(p[recursive?](l.v1, 1n)) {
                return 1n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            elif(p[recursive?](l.v1, 1n)) {
                return 1n;
            }
            elif(p[recursive?](l.v2, 2n)) {
                return 2n;
            }
            else {
                return none;
            }
        }
        else {
            return l.find_pred_idx[recursive?](p);
        }
    }

    recursive? function s_find_last_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            if(p[recursive?](l.v0)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            if(p[recursive?](l.v1)) {
                return 1n;
            }
            elif(p[recursive?](l.v0)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(p[recursive?](l.v2)) {
                return 2n;
            }
            elif(p[recursive?](l.v1)) {
                return 1n;
            }
            elif(p[recursive?](l.v0)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        else {
            return l.find_last_pred[recursive?](p);
        }
    }

    recursive? function s_find_last_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            if(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            if(p[recursive?](l.v1, 1n)) {
                return 1n;
            }
            elif(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            if(p[recursive?](l.v2, 2n)) {
                return 2n;
            }
            elif(p[recursive?](l.v1, 1n)) {
                return 1n;
            }
            elif(p[recursive?](l.v0, 0n)) {
                return 0n;
            }
            else {
                return none;
            }
        }
        else {
            return l.find_last_pred_idx[recursive?](p);
        }
    }

    recursive? function s_filter_pred<T>(l: ListRepr<T>, p: recursive? pred(_: T) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0);

            if(p0) {
                return l;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0);
            let v1 = l.v1;
            let p1 = p[recursive?](v1);

            if(/\(p0, p1)) {
                return l;
            }
            elif(p0) {
                return Vector1<T>{v0};
            }
            elif(p1) {
                return Vector1<T>{v1};
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0);
            let v1 = l.v1;
            let p1 = p[recursive?](v1);
            let v2 = l.v2;
            let p2 = p[recursive?](v2);

            if(/\(p0, p1, p2)) {
                return l;
            }
            elif(/\(p0, p1)) {
                return Vector2<T>{v0, v1};
            }
            elif(/\(p0, p2)) {
                return Vector2<T>{v0, v2};
            }
            elif(/\(p1, p2)) {
                return Vector2<T>{v1, v2};
            }
            elif(p0) {
                return Vector1<T>{v0};
            }
            elif(p1) {
                return Vector1<T>{v1};
            }
            elif(p2) {
                return Vector1<T>{v2};
            }
            else {
                return none;
            }
        }
        else {
            return l.filter_pred[recursive?](p);
        }
    }

    recursive? function s_filter_pred_idx<T>(l: ListRepr<T>, p: recursive? pred(_: T, _: Nat) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0, 0n);

            if(p0) {
                return l;
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector2<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0, 0n);
            let v1 = l.v1;
            let p1 = p[recursive?](v1, 1n);

            if(/\(p0, p1)) {
                return l;
            }
            elif(p0) {
                return Vector1<T>{v0};
            }
            elif(p1) {
                return Vector1<T>{v1};
            }
            else {
                return none;
            }
        }
        elif(l.is<Vector3<T>>()) {
            let v0 = l.v0;
            let p0 = p[recursive?](v0, 0n);
            let v1 = l.v1;
            let p1 = p[recursive?](v1, 1n);
            let v2 = l.v2;
            let p2 = p[recursive?](v2, 2n);

            if(/\(p0, p1, p2)) {
                return l;
            }
            elif(/\(p0, p1)) {
                return Vector2<T>{v0, v1};
            }
            elif(/\(p0, p2)) {
                return Vector2<T>{v0, v2};
            }
            elif(/\(p1, p2)) {
                return Vector2<T>{v1, v2};
            }
            elif(p0) {
                return Vector1<T>{v0};
            }
            elif(p1) {
                return Vector1<T>{v1};
            }
            elif(p2) {
                return Vector1<T>{v2};
            }
            else {
                return none;
            }
        }
        else {
            return l.filter_pred_idx[recursive?](p);
        }
    }

    recursive? function s_map<T, U>(l: ListRepr<T>, f: recursive? fn(_: T) -> U): ListRepr<U> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return Vector1<U>{f[recursive?](l.v0)};
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<U>{f[recursive?](l.v0), f[recursive?](l.v1)};
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<U>{f[recursive?](l.v0), f[recursive?](l.v1), f[recursive?](l.v2)};
        }
        else {
            return l.map[recursive?](f);
        }
    }

    recursive? function s_map_idx<T, U>(l: ListRepr<T>, f: recursive? fn(_: T, _: Nat) -> U): ListRepr<U> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return Vector1<U>{f[recursive?](l.v0, 0n)};
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<U>{f[recursive?](l.v0, 0n), f[recursive?](l.v1, 1n)};
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<U>{f[recursive?](l.v0, 0n), f[recursive?](l.v1, 1n), f[recursive?](l.v2, 2n)};
        }
        else {
            return l.map_idx[recursive?](f);
        }
    }

    recursive? function s_min_arg<T, U unique Orderable>(l: ListRepr<T>, f: recursive? fn(v: T) -> U): Nat {
        if(l.is<Vector1<T>>()) {
            return 0n;
        }
        elif(l.is<Vector2<T>>()) {
            if(f[recursive?](l.v1) < f[recursive?](l.v0)) {
                return 1n;
            }
            else {
                return 0n;
            }
        }
        elif(l.is<Vector3<T>>()) {
            let lt21 = f[recursive?](l.v2) < f[recursive?](l.v1);
            let lt20 = f[recursive?](l.v2) < f[recursive?](l.v0);
            let lt10 = f[recursive?](l.v1) < f[recursive?](l.v0);
            if(/\(lt21, lt20)) {
                return 2n;
            }
            elif(lt10) {
                return 1n;
            }
            else {
                return 0n
            }
        }
        else {
            return ListOps::s_safeAs<ListRepr<T>, RecList<T>>(l).min_arg[recursive?](f);
        }
    }

    recursive? function s_max_arg<T, U unique Orderable>(l: ListRepr<T>, f: recursive? fn(v: T) -> U): Nat {
        if(l.is<Vector1<T>>()) {
            return 0n;
        }
        elif(l.is<Vector2<T>>()) {
            if(f[recursive?](l.v1) > f[recursive?](l.v0)) {
                return 1n;
            }
            else {
                return 0n;
            }
        }
        elif(l.is<Vector3<T>>()) {
            let gt21 = f[recursive?](l.v2) > f[recursive?](l.v1);
            let gt20 = f[recursive?](l.v2) > f[recursive?](l.v0);
            let gt10 = f[recursive?](l.v1) > f[recursive?](l.v0);
            if(/\(gt21, gt20)) {
                return 2n;
            }
            elif(gt10) {
                return 1n;
            }
            else {
                return 0n
            }
        }
        else {
            return ListOps::s_safeAs<ListRepr<T>, RecList<T>>(l).max_arg[recursive?](f);
        }
    }

    function s_sum<T unique Algebraic>(l: ListRepr<T>): T {
        if(l === none) {
            return T::zero;
        }
        elif(l.is<Vector1<T>>()) {
            return l.v0;
        }
        elif(l.is<Vector2<T>>()) {
            return l.v0 + l.v1;
        }
        elif(l.is<Vector3<T>>()) {
            return l.v0 + l.v1 + l.v2;
        }
        else {
            return l.sum();
        }
    }

    recursive? function s_sort<T>(l: ListRepr<T>, cmp: recursive? pred(_: T, _: T) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return l;
        }
        elif(l.is<Vector2<T>>()) {
            if(!cmp[recursive?](l.v1, l.v0)) {
                return l;
            }
            else {
                return List<T>@{at1, at0};
            }
        }
        elif(l.is<Vector3<T>>()) {
            let l10 = cmp[recursive?](l.v1, l.v0);
            let l20 = cmp[recursive?](l.v2, l.v0);
            let l21 = cmp[recursive?](l.v2, l.v1);

            if(/\(l20, l21)) {
                if(l10) {
                    return Vector3<T>{l.v2, l.v1, l.v0};
                }
                else {
                    return Vector3<T>{l.v2, l.v0, l.v1};
                }
            }
            elif(/\(l10, !l21)) {
                if(l20) {
                    return Vector3<T>{l.v1, l.v2, l.v0};
                }
                else {
                    return Vector3<T>{l.v1, l.v0, l.v2};
                }
            }
            else {
                if(l21) {
                    return Vector3<T>{l.v0, l.v2, l.v1};
                }
                else {
                    return Vector3<T>{l.v0, l.v1, l.v2};
                }
            }
        }
        else {
            return l.sort[recursive?](eq);
        }
    }

    recursive? function s_unique_from_sorted<T>(l: ListRepr<T>, eq: recursive? pred(_: T, _: T) -> Bool): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return l;
        }
        elif(l.is<Vector2<T>>()) {
            if(eq[recursive?](l.v0, l.v1)) {
                return Vector1<T>{l.v0};
            }
            else {
                return l;
            }
        }
        elif(l.is<Vector3<T>>()) {
            let eq01 = eq[recursive?](l.v0, l.v1);
            let eq02 = eq[recursive?](l.v0, l.v2);
            let eq12 = eq[recursive?](l.v1, l.v2);
            

            if(/\(eq01, eq02)) {
                return Vector1<T>{l.v0};
            }
            elif(eq01) {
                return Vector2<T>{l.v0, l.v2};
            }
            elif(eq02) {
                return Vector2<T>{l.v0, l.v1};
            }
            elif(eq12) {
                return Vector2<T>{l.v0, l.v1};
            }
            else {
                return l;
            }
        }
        else {
            return l.unique_from_sorted[recursive?](eq);
        }
    }
    
    function s_reverse(l: ListRepr<T>): ListRepr<T> {
        if(l === none) {
            return none;
        }
        elif(l.is<Vector1<T>>()) {
            return l;
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>{l.v1, l.v0};
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>{l.v2, l.v1, l.v0};
        }
        else {
            return l.reverse();
        }
    }

    recursive? function s_reduce<T, U>(init: U, op: recursive? fn(_: T, _: U) -> U): U {
        if(l === none) {
            return init;
        }
        elif(l.is<Vector1<T>>()) {
            return op[recursive?](l.v0, init);
        }
        elif(l.is<Vector2<T>>()) {
            return op[recursive?](l.v1, op[recursive?](l.v0, init));
        }
        elif(l.is<Vector3<T>>()) {
            return op[recursive?](l.v2, op[recursive?](l.v1, op[recursive?](l.v0, init)));
        }
        else {
            return l.reduce<U>[recursive?](init, op);
        }
    }

    recursive? function s_reduce_idx<T, U>(init: U, op: recursive? fn(_: T, _: U, _: Nat) -> U): U {
        if(l === none) {
            return init;
        }
        elif(l.is<Vector1<T>>()) {
            return op[recursive?](l.v0, init, 0n);
        }
        elif(l.is<Vector2<T>>()) {
            return op[recursive?](l.v1, op[recursive?](l.v0, init, 0n), 1n);
        }
        elif(l.is<Vector3<T>>()) {
            return op[recursive?](l.v2, op[recursive?](l.v1, op[recursive?](l.v0, init, 0n), 1n), 2n);
        }
        else {
            return l.reduce_idx<U>[recursive?](init, op);
        }
    }

    recursive? function s_transduce<T, E, U>(env: E, op: recursive? fn(_: T, _: E) -> U, E): ListRepr<U>, E {
        if(l === none) {
            return none, env;
        }
        elif(l.is<Vector1<T>>()) {
            let v0, e0 = op[recursive?](l.v0, init);
            return Vector1<U>{v0}, e0;
        }
        elif(l.is<Vector2<T>>()) {
            let v0, e0 = op[recursive?](l.v0, init);
            let v1, e1 = op[recursive?](l.v1, e0);
            return Vector2<U>{v0, v1}, e1;
        }
        elif(l.is<Vector3<T>>()) {
            let v0, e0 = op[recursive?](l.v0, init);
            let v1, e1 = op[recursive?](l.v1, e0);
            let v2, e2 = op[recursive?](l.v2, e1);
            return Vector2<U>{v0, v1, v2}, e2;
        }
        else {
            let nl, nenv = l.transduce<E, U>[recursive?](env, op);
            return nl, nenv;
        }
    }

    recursive? function s_transduce_idx<T, E, U>(env: E, op: recursive? fn(_: T, _: E, _: Nat) -> U, E): ListRepr<U>, E {
        if(l === none) {
            return none, env;
        }
        elif(l.is<Vector1<T>>()) {
            let v0, e0 = op[recursive?](l.v0, init, 0n);
            return Vector1<U>{v0}, e0;
        }
        elif(l.is<Vector2<T>>()) {
            let v0, e0 = op[recursive?](l.v0, init, 0n);
            let v1, e1 = op[recursive?](l.v1, e0, 1n);
            return Vector2<U>{v0, v1}, e1;
        }
        elif(l.is<Vector3<T>>()) {
            let v0, e0 = op[recursive?](l.v0, init, 0n);
            let v1, e1 = op[recursive?](l.v1, e0, 1n);
            let v2, e2 = op[recursive?](l.v2, e1, 2n);
            return Vector2<U>{v0, v1, v2}, e2;
        }
        else {
            let nl, nenv = l.transduce_idx<E, U>[recursive?](env, op);
            return nl, nenv;
        }
    }
}

entity RecList<T> provides Some {
    field count: Nat;
    field ll: RecListEntry<T>;

    function {when T unique Int | Nat} range(start: T, end: T, inc: T): RecList<T> {
        let ll = RecListEntry<T>::range[recursive](start, end, inc);
        return RecList<T>{end - start, ListOps::s_safeAs<RecListEntry<T>?, RecListEntry<T>>(ll)};
    }

    function fill(count: Nat, v: T): RecList<T> {
        let ll = RecListEntry<T>::fill[recursive](count);
        return RecList<T>{count, ListOps::s_safeAs<RecListEntry<T>?, RecListEntry<T>>(ll)};
    }

    method zip_index(): RecList<[Nat, T]> {
        let ll = this.ll.zip_index[recursive](0n);
        return RecList<[Nat, T]>{this.count, ll};
    }

    method zip<U>(ol: RecList<U>): RecList<[T, U]> {
        let ll = this.zip<U>[recursive](ol.ll);
        return RecList<[T, U]>{this.count, ll};
    }

    function append(l: RecList<T>, r: RecList<T>): RecListEntry<T> { 
        return RecList<T>{l.count + r.count, RecListEntry<T>::s_append(l.ll, r.ll)};
    }

    method slice_start(start: Nat): ListRepr<T> {
        let ncount = this.count - start;
        let lle = RecListEntry<T>::s_slice_start(this.ll, start);

        if(lle === none) {
            return none;
        }
        elif(ncount == 1) {
            return RecListEntry<T>::s_list_to_vector1(lle);
        }
        elif(ncount == 2) {
            return RecListEntry<T>::s_list_to_vector2(lle);
        }
        elif(ncount == 3) {
            return RecListEntry<T>::s_list_to_vector3(lle);
        }
        else {
            return RecList<T>{ncount, lle};
        }
    }

    method slice_end(end: Nat): ListRepr<T> {
        let ncount = this.count - end;
        let lle = RecListEntry<T>::s_slice_end(this.ll, end);

        if(lle === none) {
            return none;
        }
        elif(ncount == 1) {
            return RecListEntry<T>::s_list_to_vector1(lle);
        }
        elif(ncount == 2) {
            return RecListEntry<T>::s_list_to_vector2(lle);
        }
        elif(ncount == 3) {
            return RecListEntry<T>::s_list_to_vector3(lle);
        }
        else {
            return RecList<T>{ncount, lle};
        }
    }

    method safe_get<T>(i: Nat): T {
        return this.ll.safe_get[recursive](ll, i);
    }

    recursive? method has_pred(p: recursive? pred(_: T) -> Bool): Bool {
        return this.ll.has_pred[recursive](p);
    }

    recursive? method has_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return this.ll.has_pred_idx[recursive](0n, p);
    }

    recursive? method find_pred(p: recursive? pred(_: T) -> Bool): Nat? {
        return this.ll.find_pred[recursive](0n, p);
    }

    recursive? method find_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        return this.ll.find_pred_idx[recursive](0n, p);
    }

    recursive? method find_last_pred(p: recursive? pred(_: T) -> Bool): Nat? {
        return this.ll.find_last_pred[recursive](0n, p);
    }

    recursive? method find_last_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        return this.ll.find_last_pred_idx[recursive](0n, p);
    }

    recursive? method filter_pred(p: recursive? pred(_: T) -> Bool): ListRepr<T> {
        let lle, lls = this.ll.filter_pred[recursive](p);
        if(lle === none) {
            return none;
        }
        elif(lls <= 3) {
            if(lls == 1) {
                return RecListEntry<T>::s_list_to_vector1(lle);
            }
            elif(lls == 2) {
                return RecListEntry<T>::s_list_to_vector2(lle);
            }
            else {
                return RecListEntry<T>::s_list_to_vector3(lle);
            }
        }
        else {
            return RecList<T>{lle, lls};
        }
    }

    recursive? method filter_pred_idx(p: recursive? pred(_: T, _: Nat) -> Bool): ListRepr<T> {
        let lle, lls = this.ll.filter_pred_idx[recursive](0n, p);
        if(lle === none) {
            return none;
        }
        elif(lls <= 3) {
            if(lls == 1) {
                return RecListEntry<T>::s_list_to_vector1(lle);
            }
            elif(lls == 2) {
                return RecListEntry<T>::s_list_to_vector2(lle);
            }
            else {
                return RecListEntry<T>::s_list_to_vector3(lle);
            }
        }
        else {
            return RecList<T>{lle, lls};
        }
    }

    recursive? method map<U>(f: recursive? fn(_: T) -> U): RecList<U> {
        let llm = this.ll.map<U>[recursive](f);
        return RecList<T>{llm, this.count};
    }

    recursive? method map_idx<U>(f: recursive? fn(_: T, _: Nat) -> U): RecList<U> {
        let llm = this.ll.map<U>[recursive](0n, f);
        return RecList<T>{llm, this.count};
    }

    recursive? method min_arg<U unique Orderable>(idx: Nat, f: recursive? fn(v: T) -> U): Nat {
        let midx, _ = this.ll.min_arg<U>[recursive](0, f);
        return minidx;
    }

    recursive? method max_arg<U unique Orderable>(idx: Nat, f: recursive? fn(v: T) -> U): Nat, U {
        let midx, _ = this.ll.max_arg<U>[recursive?](0, f);
        return minidx;
    }

    method {when T unique Algebraic} sum(): T {
        return this.ll.sum[recursive](f);
    }

    recursive method sort(cmp: recursive? pred(_: T, _: T) -> Bool): ListRepr<T> {
        return RecList<T>{this.ll.sort[recursive](cmp), this.count};
    }

    recursive method unique_from_sorted(prev: T, eq: recursive? pred(_: T, _: T) -> Bool): RecListEntry<T>?, Nat {
        let tl = this.ll.tail;
        let hh = this.ll.head;

        let nll, ns = ListOps::s_safeAs<RecListEntry<T>?, RecListEntry<T>>(tl).unique_from_sorted[recursive](hh, eq);
        if(ns <= 3) {
            if(ns == 1) {
                return RecListEntry<T>::s_list_to_vector1(nll);
            }
            elif(ns == 2) {
                return RecListEntry<T>::s_list_to_vector2(nll);
            }
            else {
                return RecListEntry<T>::s_list_to_vector3(nll);
            }
        }
        else {
            return RecList<T>{nll, ns};
        }
    }
    
    method reverse(): RecList<T> {
        return RecList<T>{this.ll.reverse[recursive](), this.count};
    }

    recursive? method reduce<U>(init: U, op: recursive? fn(_: T, _: U) -> U): U {
        return this.ll.reduce<U>[recursive](init, op);
    }

    recursive? function reduce_idx<U>(init: U, op: recursive? fn(_: T, _: U, _: Nat) -> U): U {
        return this.ll.reduce_idx<U>[recursive](init, 0n, op);
    }

    recursive? function transduce<E, U>(env: E, op: recursive? fn(_: T, _: E) -> U, E): RecList<U>, E {
        let nll, ee = this.ll.transduce<E, U>[recursive](env, op);
        return RecList<U>{nll, this.count}, ee;
    }

    recursive? function s_transduce_idx<E, U>(env: E, op: recursive? fn(_: T, _: E, _: Nat) -> U, E): RecList<U>, E {
        let nll, ee = this.ll.transduce_idx<E, U>[recursive](env, 0n, op);
        return RecList<U>{nll, this.count}, ee;
    }
}

entity RecListEntry<T> provides Some {
    field head: T;
    field tail RecListEntry<T>?;

    function s_vector1_to_list(l: Vector1<T>): RecListEntry<T> {
        return RecListEntry<T>{l.v0, none};
    }

    function s_vector2_to_list(l: Vector2<T>): RecListEntry<T> {
        return RecListEntry<T>{l.v0, RecListEntry<T>{l.v1, none}};
    }

    function s_vector3_to_list(l: Vector3<T>): RecListEntry<T> {
        return RecListEntry<T>{l.v0, RecListEntry<T>{l.v1,  RecListEntry<T>{l.v2, none}}};
    }

    function s_list_to_vector1(l: RecListEntry<T>): Vector1<T> {
        return Vector1<T>{l.head};
    }

    function s_list_to_vector2(l: RecListEntry<T>): Vector2<T> {
        let ee2 = lls.tail;
        return Vector2<T>{l.head, ListOps::s_safeAs<RecListEntry<T>?, RecListEntry<T>>(ee2).head};
    }

    function s_list_to_vector3(l: RecListEntry<T>): Vector3<T> {
        let ee2 = lls.tail;
        let ee3 = ListOps::s_safeAs<RecListEntry<T>?, RecListEntry<T>>(ee2).tail
        return RecListEntry<T>{l.head, ListOps::s_safeAs<RecListEntry<T>?, RecListEntry<T>>(ee2).head, ListOps::s_safeAs<RecListEntry<T>?, RecListEntry<T>>(ee3).head};
    }

    recursive {when T unique Int | Nat} function range(start: T, end: T, inc: T): RecListEntry<T>? {
        if(start == end) {
            return none;
        }
        else {
            let ntl = RecListEntry<T>::range[recursive](start + inc, end, inc);
            return RecListEntry<T>{start, ntl};
        }
    }

    recursive function fill(count: Nat, v: T): RecListEntry<T>? {
        if(start == end) {
            return none;
        }
        else {
            let ntl = RecListEntry<T>::fill[recursive](count - 1n, v);
            return RecListEntry<T>{v, ntl};
        }
    }

    recursive method zip_index(idx: Nat): RecListEntry<[Nat, T]> {
        let tl = this.tail;
        let hh = this.head;

        let nh = [idx, hh];
        if(tl === none) {
            RecListEntry<[Nat, T]>{nh, none};
        }
        else {
            let ntl = tl.zip_index[recursive](idx + 1n);
            return RecListEntry<[Nat, T]>{nh, ntl};
        }
    }

    recursive method zip<U>(ol: RecListEntry<U>): RecListEntry<[T, U]> {
        let tt = this.tail;
        let th = this.head;

        let ot = ol.tail;
        let oh = ol.head;

        let nh = [th, oh];
        if(\/(tt === none, ot === none)) {
            RecListEntry<[T, U]>{nh, none};
        }
        else {
            let ntl = tt.zip<U>[recursive](ot);
            return RecListEntry<[T, U]>{nh, ntl};
        }
    }

    recursive function s_append(l: RecListEntry<T>?, r: RecListEntry<T>): RecListEntry<T> {
        if(l == none) {
            return r;
        }
        else {
            return RecListEntry<T>{l.head, RecListEntry<T>::s_append(l.tail, r)};
        }
    }

    recursive function s_slice_start(l: RecListEntry<T>?, idx: Nat): RecListEntry<T>? {
        if(l == none) {
            return none;
        }
        elif(idx == 0) {
            return l;
        }
        else {
            return RecListEntry<T>::s_slice_start(l.tail, idx - 1);
        }
    }

    recursive function s_slice_end(l: RecListEntry<T>?, idx: Nat): RecListEntry<T>? {
        if(l == none) {
            return none;
        }
        elif(idx == 0) {
            return none;
        }
        else {
            return RecListEntry<T>{l.head, RecListEntry<T>::s_slice_end(l.tail, idx - 1)};
        }
    }

    recursive method safe_get(i: Nat): T {
        if(i == 0) {
            return this.head;
        }
        else {
            return ListOps::s_safeAs<RecListEntry<T>?, RecListEntry<T>>(this.tail).safe_get[recursive](i - 1);
        }
    }

    recursive method has_pred(p: recursive? pred(_: T) -> Bool): Bool {
        if(p[recursive?](this.head)) {
            return true;
        }
        else {
            let tl = this.tail;
            if(tl === none) {
                return false;
            }
            else {
                return tl.has_pred[recursive](p);
            }
        }
    }

    recursive method has_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(p[recursive?](this.head, idx)) {
            return true;
        }
        else {
            let tl = this.tail;
            if(tl === none) {
                return false;
            }
            else {
                return tl.has_pred_idx[recursive](idx + 1n, p);
            }
        }
    }

    recursive method find_pred(idx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        if(p[recursive?](this.head)) {
            return idx;
        }
        else {
            let tl = this.tail;
            if(tl === none) {
                return none;
            }
            else {
                return tl.find_pred[recursive](idx + 1n, p);
            }
        }
    }

    recursive method find_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        if(p[recursive?](this.head, idx)) {
            return idx;
        }
        else {
            let tl = this.tail;
            if(tl === none) {
                return none;
            }
            else {
                return tl.find_pred_idx[recursive](idx + 1n, p);
            }
        }
    }

    recursive method find_last_pred(idx: Nat, p: recursive? pred(_: T) -> Bool): Nat? {
        let tl = this.tail;

        if(tl === none) {
            if(p[recursive?](this.head)) {
                return idx;
            }
            else {
                return none;
            }
        }
        else {
            let tres = tl.find_last_pred_idx[recursive](idx + 1n, p);

            if(tres !== none) {
                return tres;
            }
            else {
                if(p[recursive?](this.head);) {
                    return idx;
                }
                else {
                    return none;
                }
            }
        }
    }

    recursive method find_last_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): Nat? {
        let tl = this.tail;

        if(tl === none) {
            if(p[recursive?](this.head, idx)) {
                return idx;
            }
            else {
                return none;
            }
        }
        else {
            let tres = tl.find_last_pred_idx[recursive](idx + 1n, p);

            if(tres !== none) {
                return tres;
            }
            else {
                if(p[recursive?](this.head, idx)) {
                    return idx;
                }
                else {
                    return none;
                }
            }
        }
    }

    recursive method filter_pred(p: recursive? pred(_: T) -> Bool): RecListEntry<T>?, Nat {
        let tl = this.tail;
        let hh = this.head;

        let ph = p[recursive?](hh);
        if(tl === none) {
            if(ph) {
                return RecListEntry<T>{hh, none}, 1n;
            }
            else {
                return none, 0n;
            }
        }
        else {
            let ntl, nts = tl.filter_pred[recursive](p);
            if(ph) {
                return RecListEntry<T>{hh, ntl}, nts + 1n;
            }
            else {
                return ntl, nts;
            }
        }
    }

    recursive method filter_pred_idx(idx: Nat, p: recursive? pred(_: T, _: Nat) -> Bool): RecListEntry<T>?, Nat {
        let tl = this.tail;
        let hh = this.head;

        let ph = p[recursive?](hh, idx);
        if(tl === none) {
            if(ph) {
                return RecListEntry<T>{hh, none}, 1n;
            }
            else {
                return none, 0n;
            }
        }
        else {
            let ntl, nts = tl.filter_pred_idx[recursive](idx + 1n, p);
            if(ph) {
                return RecListEntry<T>{hh, ntl}, nts + 1n;
            }
            else {
                return ntl, nts;
            }
        }
    }

    recursive method map<U>(f: recursive? fn(_: T) -> U): RecListEntry<U> {
        let tl = this.tail;
        let hh = this.head;

        let nh = f[recursive?](hh);
        if(tl === none) {
            return RecListEntry<U>{nh, none};
        }
        else {
            let ntl = tl.map<U>[recursive](f);
            return RecListEntry<U>{nh, ntl};
        }
    }

    recursive method map_idx<U>(idx: Nat, f: recursive? fn(_: T, _: Nat) -> U): RecListEntry<U> {
        let tl = this.tail;
        let hh = this.head;

        let nh = f[recursive?](hh, idx);
        if(tl === none) {
            return RecListEntry<U>{nh, none};
        }
        else {
            let ntl = tl.map<U>[recursive](idx + 1n, f);
            return RecListEntry<U>{nh, ntl};
        }
    }

    recursive method min_arg<U unique Orderable>(idx: Nat, f: recursive? fn(v: T) -> U): Nat, U {
        let tl = this.tail;
        let hh = this.head;
        let hu = f[recursive?](hh);

        if(tl === none) {
            return idx, hu;
        }
        else {
            let ntl, ntu = tl.min_arg<U>[recursive](idx + 1n, f);
            if(ntu < hu) {
                return ntl, ntu;
            }
            else {
                return idx, hu;
            }
        }
    }

    recursive method max_arg<U unique Orderable>(idx: Nat, f: recursive? fn(v: T) -> U): Nat, U {
        let tl = this.tail;
        let hh = this.head;
        let hu = f[recursive?](hh);

        if(tl === none) {
            return idx, hu;
        }
        else {
            let ntl, ntu = tl.min_arg<U>[recursive](idx + 1n, f);
            if(ntu > hu) {
                return ntl, ntu;
            }
            else {
                return idx, hu;
            }
        }
    }

    recursive method {when T unique Algebraic} sum(): T {
        let tl = this.tail;
        let hh = this.head;

        if(tl === none) {
            return hh;
        }
        else {
            return hh + tl.sum();
        }
    }

    recursive method sort(cmp: recursive? pred(_: T, _: T) -> Bool): RecListEntry<T> {
        let tl = this.tail;
        let hh = this.head;

        if(tl === none) {
            return this;
        }
        else {
            let ntl = tl.sort[recursive](cmp);
            return ntl.sort_insert[recursive](hh, cmp);
        }
    }

    recursive method sort_insert(v: T, cmp: recursive? pred(_: T, _: T) -> Bool): RecListEntry<T> {
        let tl = this.tail;
        let hh = this.head;

        if(!cmp[recursive?](hh, v)) {
            return RecListEntry<T>{v, this};
        }
        else {
            if(tl === none) {
                return RecListEntry<T>{hh, RecListEntry<T>{v, none}};
            }
            else {
                let ntl = tl.sort_insert[recursive](v, cmp);
                return RecListEntry<T>{hh, ntl};
            }
        }
    }

    recursive method unique_from_sorted(prev: T, eq: recursive? pred(_: T, _: T) -> Bool): RecListEntry<T>?, Nat {
        let tl = this.tail;
        let hh = this.head;

        if(eq[recursive?](prev, hh)) {
            if(tl === none) {
                return none, 0n;
            }
            else {
                return tl.unique_from_sorted[recursive](prev, eq);
            }
        }
        else {
            if(tl === none) {
                return RecListEntry<T>{hh, none}, 1n;
            }
            else {
                let tll, n = tl.unique_from_sorted[recursive](hh, eq);
                return RecListEntry<T>{hh, tll}, n + 1n;
            }
        }
    }
    
    recursive method reverse(rl: RecListEntry<T>?): RecListEntry<T> {
        let tl = this.tail;
        let hh = this.head;

        if(tl === none) {
            return RecListEntry<T>{hh, rl};
        }
        else {
            return tl.reverse[recursive](RecListEntry<T>{hh, rl});
        }
    }

    recursive method reduce<U>(uu: U, op: recursive? fn(_: T, _: U) -> U): U {
        let tl = this.tail;
        let hh = this.head;

        let nu = op[recursive?](hh, uu);
        if(tl === none) {
            return nu;
        }
        else {
            return tl.reduce[recursive](nu, op);
        }
    }

    recursive function reduce_idx<U>(init: U, idx, Nat, op: recursive? fn(_: T, _: U, _: Nat) -> U): U {
        let tl = this.tail;
        let hh = this.head;

        let nu = op[recursive?](hh, uu, idx);
        if(tl === none) {
            return nu;
        }
        else {
            return tl.reduce_idx[recursive](nu, idx + 1n, op);
        }
    }

    recursive function transduce<E, U>(env: E, op: recursive? fn(_: T, _: E) -> U, E): RecListEntry<U>, E {
        let tl = this.tail;
        let hh = this.head;

        let nu, nenv = op[recursive?](hh, env);
        if(tl === none) {
            return RecListEntry<U>{nu, none}, nenv;
        }
        else {
            let tll, tlenv = tl.transduce[recursive](nenv, op);
            return RecListEntry<U>{nu, tll}, tlenv;
        }
    }

    recursive function s_transduce_idx<E, U>(env: E, idx: Nat op: recursive? fn(_: T, _: E, _: Nat) -> U, E): RecListEntry<U>, E {
        let tl = this.tail;
        let hh = this.head;

        let nu, nenv = op[recursive?](hh, env, idx);
        if(tl === none) {
            return RecListEntry<U>{nu, none}, nenv;
        }
        else {
            let tll, tlenv = tl.transduce_idx[recursive](nenv, idx + 1n, op);
            return RecListEntry<U>{nu, tll}, tlenv;
        }
    }
}

typedef ListRepr<T> = None | Vector1<T> | Vector2<T> | Vector3<T> | RecList<T>;

#endif
