//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace Core;

#if CHECK_LIBS
internal entity Vector1<T> provides Some {
    field v0: T;

    internal function s_list_get(l: Vector1<T>, i: Nat): T {
        return l.v0;
    }

    internal function s_list_back(l: Vector1<T>): T {
        return l.v0;
    }

    internal function s_list_front(l: Vector1<T>): T {
        return l.v0;
    }

    internal function s_list_set(l: Vector1<T>, i: Nat, v: T): Vector1<T> {
        return Vector1<T>{v};
    }

    internal function s_list_insert(l: Vector1<T>, idx: Nat, v: T): Vector2<T> {
        if(idx == 0n) {
            return Vector2<T>{v, l.v0};    
        }
        else {
            return Vector2<T>{l.v0, v};    
        }
    }

    internal function s_list_push_back(l: Vector1<T>, v: T): Vector2<T> {
        return Vector2<T>{l.v0, v};
    }

    internal function s_list_push_front(l: Vector1<T>, v: T): Vector2<T> {
        return Vector2<T>{v, l.v0};
    }

    internal recursive? function s_list_has_pred(l: Vector1<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return p[recursive?](l.v0);
    }

    internal recursive? function s_list_has_pred_idx(l: Vector1<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return p[recursive?](l.v0, 0n);
    }

    internal recursive? function s_list_find_pred(l: Vector1<T>, p: recursive? pred(_: T) -> Bool): Int {
        if(p[recursive?](l.v0)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_idx(l: Vector1<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(p[recursive?](l.v0, 0n)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_last(l: Vector1<T>, p: recursive? pred(_: T) -> Bool): Int  {
        if(p[recursive?](l.v0)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_last_idx(l: Vector1<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(p[recursive?](l.v0, 0n)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_single_index_of(l: Vector1<T>, p: recursive? pred(_: T) -> Bool): Int {
        if(p[recursive?](l.v0)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal function {when T grounded KeyType} s_list_has(l: Vector1<T>, v: T): Bool {
        return l.v0 === v;
    }

    internal function {when T grounded KeyType} s_list_indexof(l: Vector1<T>, v: T): Int {
        if(l.v0 === v) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal function {when T grounded KeyType} s_list_last_indexof(l: Vector1<T>, v: T): Int {
        if(l.v0 === v) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_filter_pred(l: Vector1<T>, p: recursive? pred(_: T) -> Bool): Vector1<T> | None {
        if(p[recursive?](l.v0)) {
            return this;
        }
        else {
            return none;
        }
    }

    internal recursive? function s_list_filter_pred_idx(l: Vector1<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Vector1<T> | None {
        if(p[recursive?](l.v0, 0n)) {
            return this;
        }
        else {
            return none;
        }
    }

    internal recursive? function s_list_map_fn<U>(l: Vector1<T>, f: recursive? fn(_: T) -> U): Vector1<U> {
        return Vector1<U>{f[recursive?](l.v0)};
    }

    internal recursive? function s_list_map_fn_idx<U>(l: Vector1<T>, f: recursive? fn(_: T, _: Nat) -> U): Vector1<U> {
        return Vector1<U>{f[recursive?](l.v0, 0n)};
    }
    
    internal recursive? function s_list_map_fn_sync<U, V>(l1: Vector1<T>, l2: Vector1<U>, f: recursive? fn(_: T, _: U) -> V): Vector1<V>{
        return Vector1<V>{f[recursive?](l1.v0, l2.v0)};
    }

    internal recursive? function s_list_filter_map_fn<U>(l: Vector1<T>, p: recursive? pred(_: T) -> Bool, f: recursive? fn(_: T) -> U): Vector1<U> | None {
        if(p[recursive?](l.v0)) {
            return Vector1<U>(f[recursive?](l.v0));
        }
        else {
            return none;
        }
    }
}

internal entity Vector2<T> provides Some {
    field v0: T;
    field v1: T;

    internal function s_list_get(l: Vector2<T>, i: Nat): T {
        if(i == 0n) {
            return l.v0;
        }
        else {
            return l.v1;
        }
    }

    internal function s_list_back(l: Vector2<T>): T {
        return l.v1;
    }

    internal function s_list_front(l: Vector2<T>): T {
        return l.v0;
    }

    internal function s_list_set(l: Vector2<T>, i: Nat, v: T): Vector2<T> {
        if(i == 0n) {
            return Vector2<T>{v, l.v1};
        }
        else {
            return Vector2<T>{l.v0, v};
        }
    }

    internal function s_list_remove(l: Vector2<T>, i: Nat): Vector1<T> {
        if(i == 0n) {
            return Vector1<T>{l.v1};
        }
        else {
            return Vector1<T>{l.v0};
        }
    }

    internal function s_list_insert(l: Vector2<T>, idx: Nat, v: T): Vector3<T> {
        if(idx == 0n) {
            return Vector3<T>{v, l.v0, l.v1};    
        }
        elif(idx == 1n) {
            return Vector3<T>{l.v0, v, l.v1};
        }
        else {
            return Vector3<T>{l.v0, l.v1, v};    
        }
    }

    internal function s_list_pop_back(l: Vector2<T>): Vector1<T> {
        return Vector1<T>{l.v0};
    }

    internal function s_list_pop_front(l: Vector2<T>): Vector1<T> {
        return Vector1<T>{l.v1};
    }

    internal function s_list_push_back(l: Vector2<T>, v: T): Vector3<T> {
        return Vector3<T>{l.v0, l.v1, v};
    }

    internal function s_list_push_front(l: Vector2<T>, v: T): Vector3<T> {
        return Vector3<T>{v, l.v0, l.v1};
    }

    internal recursive? function s_list_has_pred(l: Vector2<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return \/(p[recursive?](l.v0), p[recursive?](l.v1));
    }

    internal recursive? function s_list_has_pred_idx(l: Vector2<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return \/(p[recursive?](l.v0, 0n), p[recursive?](l.v1, 1n));
    }

    internal recursive? function s_list_find_pred(l: Vector2<T>, p: recursive? pred(_: T) -> Bool): Int {
        if(p[recursive?](l.v0)) {
            return 0i;
        }
        elif(p[recursive?](l.v1)) {
            return 1i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_idx(l: Vector2<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(p[recursive?](l.v0, 0n)) {
            return 0i;
        }
        elif(p[recursive?](l.v1, 1n)) {
            return 1i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_last(l: Vector2<T>, p: recursive? pred(_: T) -> Bool): Int  {
        if(p[recursive?](l.v1)) {
            return 1i;
        }
        elif(p[recursive?](l.v0)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_last_idx(l: Vector2<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(p[recursive?](l.v1, 1n)) {
            return 1i;
        }
        elif(p[recursive?](l.v0, 0n)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_single_index_of(l: Vector2<T>, p: recursive? pred(_: T) -> Bool): Int {
        let p0 = p[recursive?](l.v0);
        let p1 = p[recursive?](l.v1);

        if(p0) {
            if(p1) {
                return -1i;
            }
            else {
                return 0i;
            }
        }
        elif(p1) {
            if(p0) {
                return -1i;
            }
            else {
                return 1i;
            }
        }
        else {
            return -1i;
        }
    }

    internal function {when T grounded KeyType} s_list_has(l: Vector2<T>, v: T): Bool {
        return \/(l.v0 === v, l.v1 === v);
    }

    internal function {when T grounded KeyType} s_list_indexof(l: Vector2<T>, v: T): Int {
        if(l.v0 === v) {
            return 0i;
        }
        elif(l.v1 === v) {
            return 1i;
        }
        else {
            return -1i;
        }
    }

    internal function {when T grounded KeyType} s_list_last_indexof(l: Vector2<T>, v: T): Int {
        if(l.v1 === v) {
            return 1i;
        }
        elif(l.v0 === v) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal function s_mask_filter_mixed(l: Vector2<T>, p0: Bool, p1: Bool): Vector1<T> {
        if(p0) {
            return Vector1<T>{l.v0};
        }
        else {
            return Vector1<T>{l.v1};
        }
    }

    internal recursive? function s_list_filter_pred(l: Vector2<T>, p: recursive? pred(_: T) -> Bool): Vector2<T> | Vector1<T> | None {
        let p0 = p[recursive?](l.v0);
        let p1 = p[recursive?](l.v1);

        if(/\(p0, p1)) {
            return this;
        }
        elif(!\/(p0, p1)) {
            return none;
        }
        else {
            return Vector2<T>::s_mask_filter_mixed(l, p0, p1);
        }
    }

    internal recursive? function s_list_filter_pred_idx(l: Vector2<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Vector2<T> | Vector1<T> | None {
        let p0 = p[recursive?](l.v0, 0n);
        let p1 = p[recursive?](l.v1, 1n);

        if(/\(p0, p1)) {
            return this;
        }
        elif(!\/(p0, p1)) {
            return none;
        }
        else {
            return Vector2<T>::s_mask_filter_mixed(l, p0, p1);
        }
    }

    internal recursive? function s_list_map_fn<U>(l: Vector2<T>, f: recursive? fn(_: T) -> U): Vector2<U> {
        return Vector2<U>{f[recursive?](l.v0), f[recursive?](l.v1)};
    }
    
    internal recursive? function s_list_map_fn_idx<U>(l: Vector2<T>, f: recursive? fn(_: T, _: Nat) -> U): Vector2<U> {
        return Vector2<U>{f[recursive?](l.v0, 0n), f[recursive?](l.v1, 1n)};
    }
    
    internal recursive? function s_list_map_fn_sync<U, V>(l1: Vector2<T>, l2: Vector2<U>, f: recursive? fn(_: T, _: U) -> V): Vector2<V>{
        return Vector2<V>{f[recursive?](l1.v0, l2.v0), f[recursive?](l1.v1, l2.v1)};
    }

    internal recursive? function s_mask_filter_map_mixed<U>(l: Vector2<T>, p0: Bool, p1: Bool, f: recursive? fn(_: T) -> U): Vector1<U> {
        if(p0) {
            return Vector1<U>{f[recursive?](l.v0)};
        }
        else {
            return Vector1<U>{f[recursive?](l.v1)};
        }
    }

    internal recursive? function s_list_filter_map_fn<U>(l: Vector2<T>, p: recursive? pred(_: T) -> Bool, f: recursive? fn(_: T) -> U): Vector2<U> | Vector1<U> | None {
        let p0 = p[recursive?](l.v0);
        let p1 = p[recursive?](l.v1);

        if(/\(p0, p1)) {
            return Vector2<U>{f[recursive?](l.v0), f[recursive?](l.v1)};
        }
        elif(!\/(p0, p1)) {
            return none;
        }
        else {
            return Vector2<T>::s_mask_filter_map_mixed<U>[recursive?](l, p0, p1, f);
        }
    }
}

internal entity Vector3<T> provides Some {
    field v0: T;
    field v1: T;
    field v2: T;

    internal function s_list_get(l: Vector3<T>, i: Nat): T {
        if(i == 0n) {
            return l.v0;
        }
        elif(i == 1n) {
            return l.v1;
        }
        else {
            return l.v2;
        }
    }

    internal function s_list_back(l: Vector3<T>): T {
        return l.v2;
    }

    internal function s_list_front(l: Vector3<T>): T {
        return l.v0;
    }

    internal function s_list_set(l: Vector3<T>, i: Nat, v: T): Vector3<T> {
        if(i == 0n) {
            return Vector3<T>{v, l.v1, l.v2};
        }
        elif(i == 1n) {
            return Vector3<T>{l.v0, v, l.v2};
        }
        else {
            return Vector3<T>{l.v0, l.v1, v};
        }
    }

    internal function s_list_remove(l: Vector3<T>, i: Nat): Vector2<T> {
        if(i == 0n) {
            return Vector2<T>{l.v1, l.v2};
        }
        elif(i == 1n) {
            return Vector2<T>{l.v0, l.v2};
        }
        else {
            return Vector2<T>{l.v0, l.v1};
        }
    }

    internal function s_list_insert(l: Vector3<T>, idx: Nat, v: T): Vector4<T> {
        if(idx == 0n) {
            return Vector4<T>{v, l.v0, l.v1, l.v2};    
        }
        elif(idx == 1n) {
            return Vector4<T>{l.v0, v, l.v1, l.v2};
        }
        elif(idx == 2n) {
            return Vector4<T>{l.v0, l.v1, v, l.v2};
        }
        else {
            return Vector4<T>{l.v0, l.v1, l.v2, v}; 
        }
    }

    internal function s_list_pop_back(l: Vector3<T>): Vector2<T> {
        return Vector2<T>{l.v0, l.v1};
    }

    internal function s_list_pop_front(l: Vector3<T>): Vector2<T> {
        return Vector2<T>{l.v1, l.v2};
    }

    internal function s_list_push_back(l: Vector3<T>, v: T): Vector4<T> {
        return Vector4<T>{l.v0, l.v1, l.v2, v};
    }

    internal function s_list_push_front(l: Vector3<T>, v: T): Vector4<T> {
        return Vector4<T>{v, l.v0, l.v1, l.v2};
    }

    internal recursive? function s_list_has_pred(l: Vector3<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return \/(p[recursive?](l.v0), p[recursive?](l.v1), p[recursive?](l.v2));
    }

    internal recursive? function s_list_has_pred_idx(l: Vector3<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return \/(p[recursive?](l.v0, 0n), p[recursive?](l.v1, 1n), p[recursive?](l.v2, 2n));
    }

    internal recursive? function s_list_find_pred(l: Vector3<T>, p: recursive? pred(_: T) -> Bool): Int {
        if(p[recursive?](l.v0)) {
            return 0i;
        }
        elif(p[recursive?](l.v1)) {
            return 1i;
        }
        elif(p[recursive?](l.v2)) {
            return 2i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_idx(l: Vector3<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(p[recursive?](l.v0, 0n)) {
            return 0i;
        }
        elif(p[recursive?](l.v1, 1n)) {
            return 1i;
        }
        elif(p[recursive?](l.v2, 2n)) {
            return 2i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_last(l: Vector3<T>, p: recursive? pred(_: T) -> Bool): Int  {
        if(p[recursive?](l.v2)) {
            return 2i;
        }
        elif(p[recursive?](l.v1)) {
            return 1i;
        }
        elif(p[recursive?](l.v0)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_last_idx(l: Vector3<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(p[recursive?](l.v2, 2n)) {
            return 2i;
        }
        elif(p[recursive?](l.v1, 1n)) {
            return 1i;
        }
        elif(p[recursive?](l.v0, 0n)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_single_index_of(l: Vector3<T>, p: recursive? pred(_: T) -> Bool): Int {
        let p0 = p[recursive?](l.v0);
        let p1 = p[recursive?](l.v1);
        let p2 = p[recursive?](l.v2);

        if(p0) {
            if(\/(p1, p2)) {
                return -1i;
            }
            else {
                return 0i;
            }
        }
        elif(p1) {
            if(\/(p0, p2)) {
                return -1i;
            }
            else {
                return 1i;
            }
        }
        elif(p2) {
            if(\/(p0, p1)) {
                return -1i;
            }
            else {
                return 2i;
            }
        }
        else {
            return -1i;
        }
    }

    internal function {when T grounded KeyType} s_list_has(l: Vector3<T>, v: T): Bool {
        return \/(l.v0 === v, l.v1 === v, l.v2 === v);
    }

    internal function {when T grounded KeyType} s_list_indexof(l: Vector3<T>, v: T): Int {
        if(l.v0 === v) {
            return 0i;
        }
        elif(l.v1 === v) {
            return 1i;
        }
        elif(l.v2 === v) {
            return 2i;
        }
        else {
            return -1i;
        }
    }

    internal function {when T grounded KeyType} s_list_last_indexof(l: Vector3<T>, v: T): Int {
        if(l.v2 === v) {
            return 2i;
        }
        elif(l.v1 === v) {
            return 1i;
        }
        elif(l.v0 === v) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal function s_mask_filter_mixed(l: Vector3<T>, p0: Bool, p1: Bool, p2: Bool): Vector2<T> | Vector1<T> {
        if(/\(p0, p1)) {
            return Vector2<T>{l.v0, l.v1};
        }
        elif(/\(p0, p2)) {
            return Vector2<T>{l.v0, l.v2};
        }
        elif(/\(p1, p2)) {
            return Vector2<T>{l.v1, l.v2};
        }
        elif(p0) {
            return Vector1<T>{l.v0};
        }
        elif(p1) {
            return Vector1<T>{l.v1};
        }
        else {
            return Vector1<T>{l.v2};
        }
    }

    internal recursive? function s_list_filter_pred(l: Vector3<T>, p: recursive? pred(_: T) -> Bool): Vector3<T> | Vector2<T> | Vector1<T> | None {
        let p0 = p[recursive?](l.v0);
        let p1 = p[recursive?](l.v1);
        let p2 = p[recursive?](l.v2);

        if(/\(p0, p1, p2)) {
            return this;
        }
        elif(!\/(p0, p1, p2)) {
            return none;
        }
        else {
            return Vector3<T>::s_mask_filter_mixed(l, p0, p1, p2);
        }
    }

    internal recursive? function s_list_filter_pred_idx(l: Vector3<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Vector3<T> | Vector2<T> | Vector1<T> | None {
        let p0 = p[recursive?](l.v0, 0n);
        let p1 = p[recursive?](l.v1, 1n);
        let p2 = p[recursive?](l.v2, 2n);

        if(/\(p0, p1, p2)) {
            return this;
        }
        elif(!\/(p0, p1, p2)) {
            return none;
        }
        else {
            return Vector3<T>::s_mask_filter_mixed(l, p0, p1, p2);
        }
    }

    internal recursive? function s_list_map_fn<U>(l: Vector3<T>, f: recursive? fn(_: T) -> U): Vector3<U> {
        return Vector3<U>{f[recursive?](l.v0), f[recursive?](l.v1), f[recursive?](l.v2)};
    }
    
    internal recursive? function s_list_map_fn_idx<U>(l: Vector3<T>, f: recursive? fn(_: T, _: Nat) -> U): Vector3<U> {
        return Vector3<U>{f[recursive?](l.v0, 0n), f[recursive?](l.v1, 1n), f[recursive?](l.v2, 2n)};
    }
    
    internal recursive? function s_list_map_fn_sync<U, V>(l1: Vector3<T>, l2: Vector3<U>, f: recursive? fn(_: T, _: U) -> V): Vector3<V>{
        return Vector3<V>{f[recursive?](l1.v0, l2.v0), f[recursive?](l1.v1, l2.v1), f[recursive?](l1.v2, l2.v2)};
    }

    internal recursive? function s_mask_filter_map_mixed<U>(l: Vector3<T>, p0: Bool, p1: Bool, p2: Bool, f: recursive? fn(_: T) -> U): Vector2<U> | Vector1<U> {
        if(/\(p0, p1)) {
            return Vector2<U>{f[recursive?](l.v0), f[recursive?](l.v1)};
        }
        elif(/\(p0, p2)) {
            return Vector2<U>{f[recursive?](l.v0), f[recursive?](l.v2)};
        }
        elif(/\(p1, p2)) {
            return Vector2<U>{f[recursive?](l.v1), f[recursive?](l.v2)};
        }
        elif(p0) {
            return Vector1<U>{f[recursive?](l.v0)};
        }
        elif(p1) {
            return Vector1<U>{f[recursive?](l.v1)};
        }
        else {
            return Vector1<U>{f[recursive?](l.v2)};
        }
    }

    internal recursive? function s_list_filter_map_fn<U>(l: Vector3<T>, p: recursive? pred(_: T) -> Bool, f: recursive? fn(_: T) -> U): Vector3<U> | Vector2<U> | Vector1<U> | None {
        let p0 = p[recursive?](l.v0);
        let p1 = p[recursive?](l.v1);
        let p2 = p[recursive?](l.v2);

        if(/\(p0, p1, p2)) {
            return Vector3<U>{f[recursive?](l.v0), f[recursive?](l.v1), f[recursive?](l.v2)};
        }
        elif(!\/(p0, p1, p2)) {
            return none;
        }
        else {
            return Vector3<T>::s_mask_filter_map_mixed<U>[recursive?](l, p0, p1, p2, f);
        }
    }
}

internal entity Vector4<T> provides Some {
    field v0: T;
    field v1: T;
    field v2: T;
    field v3: T;

    internal function s_list_get(l: Vector4<T>, i: Nat): T {
        if(i == 0n) {
            return l.v0;
        }
        elif(i == 1n) {
            return l.v1;
        }
        elif(i == 2n) {
            return l.v2;
        }
        else {
            return l.v3;
        }
    }

    internal function s_list_back(l: Vector4<T>): T {
        return l.v3;
    }

    internal function s_list_front(l: Vector4<T>): T {
        return l.v0;
    }

    internal function s_list_set(l: Vector4<T>, i: Nat, v: T): Vector4<T> {
        if(i == 0n) {
            return Vector4<T>{v, l.v1, l.v2, l.v3};
        }
        elif(i == 1n) {
            return Vector4<T>{l.v0, v, l.v2, l.v3};
        }
        elif(i == 2n) {
            return Vector4<T>{l.v0, l.v1, v, l.v3};
        }
        else {
            return Vector4<T>{l.v0, l.v1, l.v2, v};
        }
    }

    internal function s_list_remove(l: Vector4<T>, i: Nat): Vector3<T> {
        if(i == 0n) {
            return Vector3<T>{l.v1, l.v2, l.v3};
        }
        elif(i == 1n) {
            return Vector3<T>{l.v0, l.v2, l.v3};
        }
        elif(i == 2n) {
            return Vector3<T>{l.v0, l.v2, l.v3};
        }
        else {
            return Vector3<T>{l.v0, l.v1, l.v2};
        }
    }

    internal function s_list_pop_back(l: Vector4<T>): Vector3<T> {
        return Vector3<T>{l.v0, l.v1, l.v2};
    }

    internal function s_list_pop_front(l: Vector4<T>): Vector3<T> {
        return Vector3<T>{l.v1, l.v2, l.v3};
    }

    internal recursive? function s_list_has_pred(l: Vector4<T>, p: recursive? pred(_: T) -> Bool): Bool {
        return \/(p[recursive?](l.v0), p[recursive?](l.v1), p[recursive?](l.v2), p[recursive?](l.v3));
    }

    internal recursive? function s_list_has_pred_idx(l: Vector4<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        return \/(p[recursive?](l.v0, 0n), p[recursive?](l.v1, 1n), p[recursive?](l.v2, 2n), p[recursive?](l.v3, 3n));
    }

    internal recursive? function s_list_find_pred(l: Vector4<T>, p: recursive? pred(_: T) -> Bool): Int {
        if(p[recursive?](l.v0)) {
            return 0i;
        }
        elif(p[recursive?](l.v1)) {
            return 1i;
        }
        elif(p[recursive?](l.v2)) {
            return 2i;
        }
        elif(p[recursive?](l.v3)) {
            return 3i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_idx(l: Vector4<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(p[recursive?](l.v0, 0n)) {
            return 0i;
        }
        elif(p[recursive?](l.v1, 1n)) {
            return 1i;
        }
        elif(p[recursive?](l.v2, 2n)) {
            return 2i;
        }
        elif(p[recursive?](l.v3, 3n)) {
            return 3i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_last(l: Vector4<T>, p: recursive? pred(_: T) -> Bool): Int  {
        if(p[recursive?](l.v3)) {
            return 3i;
        }
        elif(p[recursive?](l.v2)) {
            return 2i;
        }
        elif(p[recursive?](l.v1)) {
            return 1i;
        }
        elif(p[recursive?](l.v0)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_find_pred_last_idx(l: Vector4<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(p[recursive?](l.v3, 3n)) {
            return 3i;
        }
        elif(p[recursive?](l.v2, 2n)) {
            return 2i;
        }
        elif(p[recursive?](l.v1, 1n)) {
            return 1i;
        }
        elif(p[recursive?](l.v0, 0n)) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal recursive? function s_list_single_index_of(l: Vector4<T>, p: recursive? pred(_: T) -> Bool): Int {
        let p0 = p[recursive?](l.v0);
        let p1 = p[recursive?](l.v1);
        let p2 = p[recursive?](l.v2);
        let p3 = p[recursive?](l.v3);

        if(p0) {
            if(\/(p1, p2, p3)) {
                return -1i;
            }
            else {
                return 0i;
            }
        }
        elif(p1) {
            if(\/(p0, p2, p3)) {
                return -1i;
            }
            else {
                return 1i;
            }
        }
        elif(p2) {
            if(\/(p0, p1, p3)) {
                return -1i;
            }
            else {
                return 2i;
            }
        }
        elif(p3) {
            if(\/(p0, p1, p2)) {
                return -1i;
            }
            else {
                return 3i;
            }
        }
        else {
            return -1i;
        }
    }

    internal function {when T grounded KeyType} s_list_has(l: Vector4<T>, v: T): Bool {
        return \/(l.v0 === v, l.v1 === v, l.v2 === v, l.v3 === v);
    }

    internal function {when T grounded KeyType} s_list_indexof(l: Vector4<T>, v: T): Int {
        if(l.v0 === v) {
            return 0i;
        }
        elif(l.v1 === v) {
            return 1i;
        }
        elif(l.v2 === v) {
            return 2i;
        }
        elif(l.v3 === v) {
            return 3i;
        }
        else {
            return -1i;
        }
    }

    internal function {when T grounded KeyType} s_list_last_indexof(l: Vector4<T>, v: T): Int {
        if(l.v3 === v) {
            return 3i;
        }
        elif(l.v2 === v) {
            return 2i;
        }
        elif(l.v1 === v) {
            return 1i;
        }
        elif(l.v0 === v) {
            return 0i;
        }
        else {
            return -1i;
        }
    }

    internal function s_mask_filter_mixed(l: Vector4<T>, p0: Bool, p1: Bool, p2: Bool, p3: Bool): Vector3<T>, Vector2<T> | Vector1<T> {
        if(/\(p1, p2, p3)) {
            return Vector3<T>{l.v1, l.v2, l.v3};
        }
        elif(/\(p0, p2, p3)) {
            return Vector3<T>{l.v0, l.v2, l.v3};
        }
        elif(/\(p0, p1, p3)) {
            return Vector3<T>{l.v0, l.v1, l.v3};
        }
        elif(/\(p0, p1, p2)) {
            return Vector3<T>{l.v0, l.v1, l.v2};
        }
        elif(/\(p0, p1)) {
            return Vector2<T>{l.v0, l.v1};
        }
        elif(/\(p0, p2)) {
            return Vector2<T>{l.v0, l.v2};
        }
        elif(/\(p0, p3)) {
            return Vector2<T>{l.v0, l.v3};
        }
        elif(/\(p1, p2)) {
            return Vector2<T>{l.v1, l.v2};
        }
        elif(/\(p1, p3)) {
            return Vector2<T>{l.v1, l.v3};
        }
        elif(/\(p2, p3)) {
            return Vector2<T>{l.v2, l.v3};
        }
        elif(p0) {
            return Vector1<T>{l.v0};
        }
        elif(p1) {
            return Vector1<T>{l.v1};
        }
        elif(p2) {
            return Vector1<T>{l.v2};
        }
        else {
            return Vector1<T>{l.v3};
        }
    }

    internal recursive? function s_list_filter_pred(l: Vector4<T>, p: recursive? pred(_: T) -> Bool): Vector4<T> | Vector3<T> | Vector2<T> | Vector1<T> | None {
        let p0 = p[recursive?](l.v0);
        let p1 = p[recursive?](l.v1);
        let p2 = p[recursive?](l.v2);
        let p3 = p[recursive?](l.v3);

        if(/\(p0, p1, p2, p3)) {
            return this;
        }
        elif(!\/(p0, p1, p2, p3)) {
            return none;
        }
        else {
            return Vector4<T>::s_mask_filter_mixed(l, p0, p1, p2, p3);
        }
    }

    internal recursive? function s_list_filter_pred_idx(l: Vector4<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Vector4<T> | Vector3<T> | Vector2<T> | Vector1<T> | None {
        let p0 = p[recursive?](l.v0, 0n);
        let p1 = p[recursive?](l.v1, 1n);
        let p2 = p[recursive?](l.v2, 2n);
        let p2 = p[recursive?](l.v3, 3n);

        if(/\(p0, p1, p2, p3)) {
            return this;
        }
        elif(!\/(p0, p1, p2, p3)) {
            return none;
        }
        else {
            return Vector4<T>::s_mask_filter_mixed(l, p0, p1, p2, p3);
        }
    }

    internal recursive? function s_list_map_fn<U>(l: Vector4<T>, f: recursive? fn(_: T) -> U): Vector4<U> {
        return Vector3<U>{f[recursive?](l.v0), f[recursive?](l.v1), f[recursive?](l.v2), f[recursive?](l.v3)};
    }
    
    internal recursive? function s_list_map_fn_idx<U>(l: Vector4<T>, f: recursive? fn(_: T, _: Nat) -> U): Vector4<U> {
        return Vector3<U>{f[recursive?](l.v0, 0n), f[recursive?](l.v1, 1n), f[recursive?](l.v2, 2n), f[recursive?](l.v3, 3n)};
    }
    
    internal recursive? function s_list_map_fn_sync<U, V>(l1: Vector4<T>, l2: Vector4<U>, f: recursive? fn(_: T, _: U) -> V): Vector4<V>{
        return Vector3<V>{f[recursive?](l1.v0, l2.v0), f[recursive?](l1.v1, l2.v1), f[recursive?](l1.v2, l2.v2), f[recursive?](l1.v3, l2.v3)};
    }

    internal recursive? function s_mask_filter_map_mixed<U>(l: Vector4<T>, p0: Bool, p1: Bool, p2: Bool, p3: Bool, f: recursive? fn(_: T) -> U): Vector3<U> | Vector2<U> | Vector1<U> {
        if(/\(p1, p2, p3)) {
            return Vector3<U>{f[recursive?](l.v1), f[recursive?](l.v2), f[recursive?](l.v3)};
        }
        elif(/\(p0, p2, p3)) {
            return Vector3<U>{f[recursive?](l.v0), f[recursive?](l.v2), f[recursive?](l.v3)};
        }
        elif(/\(p0, p1, p3)) {
            return Vector3<U>{f[recursive?](l.v0), f[recursive?](l.v1), f[recursive?](l.v3)};
        }
        elif(/\(p0, p1, p2)) {
            return Vector3<U>{f[recursive?](l.v0), f[recursive?](l.v1), f[recursive?](l.v2)};
        }
        elif(/\(p0, p1)) {
            return Vector2<U>{f[recursive?](l.v0), f[recursive?](l.v1)};
        }
        elif(/\(p0, p2)) {
            return Vector2<U>{f[recursive?](l.v0), f[recursive?](l.v2)};
        }
        elif(/\(p0, p3)) {
            return Vector2<U>{f[recursive?](l.v0), f[recursive?](l.v3)};
        }
        elif(/\(p1, p2)) {
            return Vector2<U>{f[recursive?](l.v1), f[recursive?](l.v2)};
        }
        elif(/\(p1, p3)) {
            return Vector2<U>{f[recursive?](l.v1), f[recursive?](l.v3)};
        }
        elif(/\(p2, p3)) {
            return Vector2<U>{f[recursive?](l.v2), f[recursive?](l.v3)};
        }
        elif(p0) {
            return Vector1<U>{f[recursive?](l.v0)};
        }
        elif(p1) {
            return Vector1<U>{f[recursive?](l.v1)};
        }
        elif(p2) {
            return Vector1<U>{f[recursive?](l.v2)};
        }
        else {
            return Vector1<U>{f[recursive?](l.v3)};
        }
    }

    internal recursive? function s_list_filter_map_fn<U>(l: Vector4<T>, p: recursive? pred(_: T) -> Bool, f: recursive? fn(_: T) -> U): Vector4<U> | Vector3<U> | Vector2<U> | Vector1<U> | None {
        let p0 = p[recursive?](l.v0);
        let p1 = p[recursive?](l.v1);
        let p2 = p[recursive?](l.v2);
        let p3 = p[recursive?](l.v3);

        if(/\(p0, p1, p2, p3)) {
            return Vector4<U>{f[recursive?](l.v0), f[recursive?](l.v1), f[recursive?](l.v2), f[recursive?](l.v2)};
        }
        elif(!\/(p0, p1, p2, p3)) {
            return none;
        }
        else {
            return Vector4<T>::s_mask_filter_map_mixed<U>[recursive?][recursive?](l, p0, p1, p2, p3, f);
        }
    }
}

internal entity VectorOps provides Some {
    internal function s_list_get<T>(l: ListVector<T>, i: Nat): T {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_get(l, i);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_get(l, i);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_get(l, i);
        }
        else {
            return Vector4<T>::s_list_get(l, i);
        }
    }

    internal function s_list_back<T>(l: ListVector<T>): T {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_back(l);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_back(l);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_back(l);
        }
        else {
            return Vector4<T>::s_list_back(l);
        }
    }

    internal function s_list_front<T>(l: ListVector<T>): T {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_front(l);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_front(l);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_front(l);
        }
        else {
            return Vector4<T>::s_list_front(l);
        }
    }

    internal function s_list_set<T>(l: ListVector<T>, i: Nat, v: T): ListVector<T> {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_set(l, i, v);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_set(l, i, v);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_set(l, i, v);
        }
        else {
            return Vector4<T>::s_list_set(l, i, v);
        }
    }

    internal function s_list_remove<T>(l: ListVector<T>, i: Nat): Vector1<T> | Vector2<T> | Vector3<T> | None {
        if(l.is<Vector1<T>>()) {
            return none;
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_remove(l, i);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_remove(l, i);
        }
        else {
            return Vector4<T>::s_list_remove(l, i);
        }
    }

    internal function s_list_insert<T>(l: Vector1<T> | Vector2<T> | Vector3<T>, idx: Nat, v: T): ListVector<T> {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_set(l, i, v);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_set(l, i, v);
        }
        else {
            return Vector3<T>::s_list_set(l, i, v);
        }
    }

    internal function s_list_pop_back<T>(l: ListVector<T>): Vector1<T> | Vector2<T> | Vector3<T> | None {
        if(l.is<Vector1<T>>()) {
            return none;
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_pop_back(l);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_pop_back(l);
        }
        else {
            return Vector4<T>::s_list_pop_back(l);
        }
    }

    internal function s_list_pop_front<T>(l: ListVector<T>): Vector1<T> | Vector2<T> | Vector3<T> | None {
        if(l.is<Vector1<T>>()) {
            return none;
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_pop_front(l);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_pop_front(l);
        }
        else {
            return Vector4<T>::s_list_pop_front(l);
        }
    }

    internal function s_list_push_back<T>(l: Vector1<T> | Vector2<T> | Vector3<T>, v: T): ListVector<T> {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_push_back(l, v);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_push_back(l, v);
        }
        else {
            return Vector3<T>::s_list_push_back(l, v);
        }
    }

    internal function s_list_push_front<T>(l: Vector1<T> | Vector2<T> | Vector3<T>, v: T): ListVector<T> {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_push_front(l, v);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_push_front(l, v);
        }
        else {
            return Vector3<T>::s_list_push_front(l, v);
        }
    }

    internal recursive? function s_list_has_pred<T>(l: ListVector<T>, p: recursive? pred(_: T) -> Bool): Bool {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_has_pred[recursive?](l, p);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_has_pred[recursive?](l, p);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_has_pred[recursive?](l, p);
        }
        else {
            return Vector4<T>::s_list_has_pred[recursive?](l, p);
        }
    }

    internal recursive? function s_list_has_pred_idx<T>(l: ListVector<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Bool {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_has_pred_idx[recursive?](l, p);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_has_pred_idx[recursive?](l, p);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_has_pred_idx[recursive?](l, p);
        }
        else {
            return Vector4<T>::s_list_has_pred_idx[recursive?](l, p);
        }
    }

    internal recursive? function s_list_find_pred<T>(l: ListVector<T>, p: recursive? pred(_: T) -> Bool): Int {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_find_pred[recursive?](l, p);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_find_pred[recursive?](l, p);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_find_pred[recursive?](l, p);
        }
        else {
            return Vector4<T>::s_list_find_pred[recursive?](l, p);
        }
    }

    internal recursive? function s_list_find_pred_idx<T>(l: ListVector<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_find_pred_idx[recursive?](l, p);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_find_pred_idx[recursive?](l, p);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_find_pred_idx[recursive?](l, p);
        }
        else {
            return Vector4<T>::s_list_find_pred_idx[recursive?](l, p);
        }
    }

    internal recursive? function s_list_find_pred_last<T>(l: ListVector<T>, p: recursive? pred(_: T) -> Bool): Int {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_find_pred_last[recursive?](l, p);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_find_pred_last[recursive?](l, p);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_find_pred_last[recursive?](l, p);
        }
        else {
            return Vector4<T>::s_list_find_pred_last[recursive?](l, p);
        }
    }

    internal recursive? function s_list_find_pred_last_idx<T>(l: ListVector<T>, p: recursive? pred(_: T, _: Nat) -> Bool): Int {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_find_pred_last_idx[recursive?](l, p);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_find_pred_last_idx[recursive?](l, p);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_find_pred_last_idx[recursive?](l, p);
        }
        else {
            return Vector4<T>::s_list_find_pred_last_idx[recursive?](l, p);
        }
    }

    internal recursive? function s_list_single_index_of<T>(l: ListVector<T>, p: recursive? pred(_: T) -> Bool): Int {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_single_index_of[recursive?](l, p);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_single_index_of[recursive?](l, p);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_single_index_of[recursive?](l, p);
        }
        else {
            return Vector4<T>::s_list_single_index_of[recursive?](l, p);
        }
    }

    internal function {when T grounded KeyType} s_list_has<T>(l: ListVector<T>, v: T): Bool {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_has(l, v);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_has(l, v);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_has(l, v);
        }
        else {
            return Vector4<T>::s_list_has(l, v);
        }
    }

    internal function {when T grounded KeyType} s_list_indexof<T>(l: ListVector<T>, v: T): Int {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_indexof(l, v);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_indexof(l, v);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_indexof(l, v);
        }
        else {
            return Vector4<T>::s_list_indexof(l, v);
        }
    }

    internal function {when T grounded KeyType} s_list_last_indexof<T>(l: ListVector<T>, v: T): Int {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_last_indexof(l, v);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_last_indexof(l, v);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_last_indexof(l, v);
        }
        else {
            return Vector4<T>::s_list_last_indexof(l, v);
        }
    }

    internal recursive? function s_list_filter_pred<T>(l: ListVector<T>, p: recursive? pred(_: T) -> Bool): ListVector<T> | None {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_filter_pred[recursive?](l, p);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_filter_pred[recursive?](l, p);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_filter_pred[recursive?](l, p);
        }
        else {
            return Vector4<T>::s_list_filter_pred[recursive?](l, p);
        }
    }

    internal recursive? function s_list_filter_pred_idx<T>(l: ListVector<T>, p: recursive? pred(_: T, _: Nat) -> Bool): ListVector<T> | None {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_filter_pred_idx[recursive?](l, p);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_filter_pred_idx[recursive?](l, p);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_filter_pred_idx[recursive?](l, p);
        }
        else {
            return Vector4<T>::s_list_filter_pred_idx[recursive?](l, p);
        }
    }

    internal recursive? function s_list_map_fn<T, U>(l: ListVector<T>, f: recursive? fn(_: T) -> U): ListVector<U> {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_map_fn<U>[recursive?](l, f);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_map_fn<U>[recursive?](l, f);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_map_fn<U>[recursive?](l, f);
        }
        else {
            return Vector4<T>::s_list_map_fn<U>[recursive?](l, f);
        }
    }

    internal recursive? function s_list_map_fn_idx<T, U>(l: ListVector<T>, f: recursive? fn(_: T, _: Nat) -> U): ListVector<U> {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_map_fn_idx<U>[recursive?](l, f);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_map_fn_idx<U>[recursive?](l, f);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_map_fn_idx<U>[recursive?](l, f);
        }
        else {
            return Vector4<T>::s_list_map_fn_idx<U>[recursive?](l, f);
        }
    }

    internal recursive? function s_list_map_fn_sync<T, U, V>(l1: ListVector<T>, l2: ListVector<U>, f: recursive? fn(_: T, _: U) -> V): ListVector<V> {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_map_fn_sync<U, V>[recursive?](l, f);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_map_fn_sync<U, V>[recursive?](l, f);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_map_fn_sync<U, V>[recursive?](l, f);
        }
        else {
            return Vector4<T>::s_list_map_fn_sync<U, V>[recursive?](l, f);
        }
    }

    internal recursive? function s_list_filter_map_fn<T, U>(l: Vector4<T>, p: recursive? pred(_: T) -> Bool, f: recursive? fn(_: T) -> U): Vector4<U> | Vector3<U> | Vector2<U> | Vector1<U> | None {
        if(l.is<Vector1<T>>()) {
            return Vector1<T>::s_list_filter_map_fn<U>[recursive?](l, p, f);
        }
        elif(l.is<Vector2<T>>()) {
            return Vector2<T>::s_list_filter_map_fn<U>[recursive?](l, p, f);
        }
        elif(l.is<Vector3<T>>()) {
            return Vector3<T>::s_list_filter_map_fn<U>[recursive?](l, p, f);
        }
        else {
            return Vector4<T>::s_list_filter_map_fn<U>[recursive?](l, p, f);
        }
    }
}
#endif

