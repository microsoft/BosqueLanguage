//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

struct entity Vector<T, K=Int> provides Object, Expandoable<T>, PODType when T PODType, APIType when T APIType {
    private static s_unsafe_get(l: Vector<T, K>, i: Int): T # vector_unsafe_get

    method size(): Int {
        return literal(K);
    }

    method empty(): Bool {
        return literal(K) == 0;
    }

    method front(): T 
        requires release literal(K) != 0;
    {
        return List<T>::s_unsafe_get(this, 0);
    }

    method back(): T 
        requires release literal(K) != 0;
    {
        return List<T>::s_unsafe_get(this, literal(K) - 1);
    }

    method get(i: Int): T 
        requires release 0 <= i && i < literal(K);
    {
        return List<T>::s_unsafe_get(this, i);
    }

    //
    //TODO: fill in here!!!
    //
}

entity List<T> provides Object, Expandoable<T>, PODType when T PODType, APIType when T APIType {
    pragma KnownSafe
    private static s_size(l: List<T>): Int # list_size

    pragma AssumeSafe
    private static s_unsafe_get(l: List<T>, i: Int): T # list_unsafe_get

    pragma KnownSafe
    private static s_unsafe_push(l: List<T>, v: T): List<T> # list_unsafe_push

    pragma AssumeSafe
    private static s_unsafe_set(l: List<T>, idx: Int, v: T): List<T> # list_unsafe_set
    
    private recursive static s_concat(l: List<List<T>>, lsize: Int, lp: List<T>, idx: Int): List<T> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let ll = List<List<T>>::s_unsafe_get(l, idx);
            let cc = List<T>::s_append[recursive](ll, List<T>::s_size(ll), lp, 0);
            return List<T>::s_concat[recursive](l, lsize, cc, idx + 1);
        }
    }

    private recursive static s_fill(k: Int, val: T, lp: List<T>): List<T> {
        if(k == 0) {
            return lp;
        }
        else {
            return List<T>::s_fill[recursive](k - 1, val, List<T>::s_unsafe_push(lp, val));
        }
    }

    private recursive static {when T KeyType} s_toset(l: List<T>, lsize: Int, idx: Int, r: Set<T>): Set<T> {
        if(idx == lsize) {
            return r;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_toset[recursive](l, lsize, idx + 1, Set<T>::s_add(r, val));
        }
    }

    private recursive static s_all(l: List<T>, lsize: Int, idx: Int, p: recursive? fn(_: T) -> Bool): Bool {
        if(idx == lsize) {
            return true;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(!p[recursive?](val)) {
                return false;
            }
            else {
                return List<T>::s_all[recursive](l, lsize, idx + 1, p);
            }
        }
    }

    private recursive static s_none(l: List<T>, lsize: Int, idx: Int, p: recursive? fn(_: T) -> Bool): Bool {
        if(idx == lsize) {
            return true;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return false;
            }
            else {
                return List<T>::s_none[recursive](l, lsize, idx + 1, p);
            }
        }
    }

    private recursive static s_any(l: List<T>, lsize: Int, idx: Int, p: recursive? fn(_: T) -> Bool): Bool {
        if(idx == lsize) {
            return false;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return true;
            }
            else {
                return List<T>::s_any[recursive](l, lsize, idx + 1, p);
            }
        }
    }

    private recursive static s_indexof(l: List<T>, idx: Int, end: Int, p: recursive? fn(_: T) -> Bool): Int {
        if(idx == end) {
            return idx;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return idx;
            }
            else {
                return List<T>::s_indexof[recursive](l, idx + 1, end, p);
            }
        }
    }

    private recursive static s_indexoflast(l: List<T>, start: Int, idx: Int, p: recursive? fn(_: T) -> Bool): Int {
        if(idx == start) {
            return idx;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return idx;
            }
            else {
                return List<T>::s_indexoflast[recursive](l, start, idx - 1, p);
            }
        }
    }

    private recursive static s_indexofnot(l: List<T>, idx: Int, end: Int, p: recursive? fn(_: T) -> Bool): Int {
        if(idx == end) {
            return idx;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(!p[recursive?](val)) {
                return idx;
            }
            else {
                return List<T>::s_indexofnot[recursive](l, idx + 1, end, p);
            }
        }
    }

    private recursive static s_indexoflastnot(l: List<T>, start: Int, idx: Int, p: recursive? fn(_: T) -> Bool): Int {
        if(idx == start) {
            return idx;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(!p[recursive?](val)) {
                return idx;
            }
            else {
                return List<T>::s_indexoflastnot[recursive](l, start, idx - 1, p);
            }
        }
    }

    private recursive static s_count(l: List<T>, lsize: Int, idx: Int, acc: Int, p: recursive? fn(_: T) -> Bool): Int {
        if(idx == lsize) {
            return acc;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            let nacc = p[recursive?](val) ? acc + 1 : acc;
            
            return List<T>::s_count[recursive](l, lsize, idx + 1, nacc, p);
        }
    }

    private recursive static s_countnot(l: List<T>, lsize: Int, idx: Int, acc: Int, p: recursive? fn(_: T) -> Bool): Int {
        if(idx == lsize) {
            return acc;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            let nacc = !p[recursive?](val) ? acc + 1 : acc;
            
            return List<T>::s_countnot[recursive](l, lsize, idx + 1, nacc, p);
        }
    }

    private recursive static {when T KeyType} s_indexof_keytype(l: List<T>, idx: Int, end: Int, cv: T): Int {
        if(idx == end) {
            return idx;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(KeyType::equal(cv, val)) {
                return idx;
            }
            else {
                return List<T>::s_indexof_keytype[recursive](l, idx + 1, end, cv);
            }
        }
    }

    private recursive static {when T KeyType} s_indexoflast_keytype(l: List<T>, start: Int, idx: Int, cv: T): Int {
        if(idx == start) {
            return idx;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(KeyType::equal(cv, val)) {
                return idx;
            }
            else {
                return List<T>::s_indexoflast_keytype[recursive](l, start, idx - 1, cv);
            }
        }
    }

    private recursive static {when T KeyType} s_count_keytype(l: List<T>, lsize: Int, idx: Int, acc: Int, cv: T): Int {
        if(idx == lsize) {
            return acc;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            let nacc = (KeyType::equal(cv, val)) ? acc + 1 : acc;
            
            return List<T>::s_count_keytype[recursive](l, lsize, idx + 1, nacc, cv);
        }
    }

    private recursive static {when T KeyType} s_min(l: List<T>, lsize: Int, idx: Int, acc: T): T {
        if(idx == lsize) {
            return acc;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_min[recursive](l, lsize, idx + 1, KeyType::less(acc, val) ? acc : val);
        }
    }

    private recursive static {when T KeyType} s_max(l: List<T>, lsize: Int, idx: Int, acc: T): T {
        if(idx == lsize) {
            return acc;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_max[recursive](l, lsize, idx + 1, KeyType::less(val, acc) ? acc : val);
        }
    }

    private recursive static {when T Int || T BigInt} s_sum(l: List<T>, lsize: Int, idx: Int, acc: T): T {
        if(idx == lsize) {
            return acc;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_sum[recursive](l, lsize, idx + 1, acc + val);
        }
    }


    private recursive static s_filter(l: List<T>, lsize: Int, lp: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return List<T>::s_filter[recursive](l, lsize, List<T>::s_unsafe_push(lp, val), idx + 1, p);
            }
            else {
                return List<T>::s_filter[recursive](l, lsize, lp, idx + 1, p);
            }
        }
    }

    private recursive static s_filternot(l: List<T>, lsize: Int, lp: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(!p[recursive?](val)) {
                return List<T>::s_filternot[recursive](l, lsize, List<T>::s_unsafe_push(lp, val), idx + 1, p);
            }
            else {
                return List<T>::s_filternot[recursive](l, lsize, lp, idx + 1, p);
            }
        }
    }

    private recursive static s_oftype<U>(l: List<T>, lsize: Int, lp: List<U>, idx: Int): List<U> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(val.is<U>()) {
                return List<T>::s_oftype<U>[recursive](l, lsize, List<U>::s_unsafe_push(lp, val.as<U>()), idx + 1);
            }
            else {
                return List<T>::s_oftype<U>[recursive](l, lsize, lp, idx + 1);
            }
        }
    }

    private recursive static s_cast<U>(l: List<T>, lsize: Int, lp: List<U>, idx: Int): List<U> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_cast<U>[recursive](l, lsize, List<U>::s_unsafe_push(lp, val.as<U>()), idx + 1);
        }
    }

    private recursive static s_takek(l: List<T>, lp: List<T>, idx: Int, k: Int): List<T> {
        if(k == 0) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_takek[recursive](l, List<T>::s_unsafe_push(lp, val), idx + 1, k - 1);
        }
    }

    private recursive static s_slice(l: List<T>, start: Int, end: Int): List<T> {
        return List<T>::s_takek[recursive](l, List<T>@{}, start, end - start);
    }

    private recursive static s_takewhile(l: List<T>, lsize: Int, lp: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(!p[recursive?](val)) {
                return lp;
            }
            else {
                return List<T>::s_takewhile[recursive](l, lsize, List<T>::s_unsafe_push(lp, val), idx + 1, p);
            }
        }
    }

    private recursive static s_discardwhile(l: List<T>, lsize: Int, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == lsize) {
            return List<T>@{};
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return List<T>::s_discardwhile[recursive](l, lsize, idx + 1, p);
            }
            else {
                return List<T>::s_takek[recursive](l, List<T>@{}, idx, List<T>::s_size(l) - idx);
            }
        }
    }

    private recursive static s_takeuntil(l: List<T>, lsize: Int, lp: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return lp;
            }
            else {
                return List<T>::s_takeuntil[recursive](l, lsize, List<T>::s_unsafe_push(lp, val), idx + 1, p);
            }
        }
    }

    private recursive static s_discarduntil(l: List<T>, lsize: Int, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == lsize) {
            return List<T>@{};
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(!p[recursive?](val)) {
                return List<T>::s_discarduntil[recursive](l, lsize, idx + 1, p);
            }
            else {
                return List<T>::s_takek[recursive](l, List<T>@{}, idx, List<T>::s_size(l) - idx);
            }
        }
    }

    private recursive static {when T KeyType} s_unique(l: List<T>, lsize: Int, lp: List<T>, idx: Int): List<T> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            let has = List<T>::s_indexof_keytype[recursive](lp, 0, List<T>::s_size(lp), val) != List<T>::s_size(lp);
            if(has) {
                return List<T>::s_unique[recursive](l, lsize, lp, idx + 1);
            }
            else {
                return List<T>::s_unique[recursive](l, lsize, List<T>::s_unsafe_push(lp, val), idx + 1);
            }
        }
    }

    private recursive static s_reverse(l: List<T>, lsize: Int, lp: List<T>, idx: Int): List<T> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_reverse[recursive](l, lsize, List<T>::s_unsafe_set(lp, (lsize - 1) - idx, val), idx + 1);
        }
    }

    private recursive static s_map<U>(l: List<T>, lsize: Int, lp: List<U>, idx: Int, f: recursive? fn(_: T) -> U): List<U> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_map<U>[recursive](l, lsize, List<T>::s_unsafe_push(lp, f[recursive?](val)), idx + 1, f);
        }
    }

    private recursive static s_mapIndex<U>(l: List<T>, lsize: Int, lp: List<U>, idx: Int, f: recursive? fn(_: T, _: Int) -> U): List<U> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_mapIndex<U>[recursive](l, lsize, List<U>::s_unsafe_push(lp, f[recursive?](val, idx)), idx + 1, f);
        }
    }

    private recursive static {when T KeyType} s_projectWMap<U>(l: List<T>, lsize: Int, lp: List<U>, idx: Int, m: Map<T, U>): List<U> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_projectWMap<U>[recursive](l, lsize, List<U>::s_unsafe_push(lp, m.get(val)), idx + 1, m);
        }
    }

    private recursive static {when T KeyType} s_tryProjectWMap<U>(l: List<T>, lsize: Int, lp: List<U?>, idx: Int, m: Map<T, U>): List<U?> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(!m.has(val)) {
                return List<T>::s_tryProjectWMap<U>[recursive](l, lsize, List<U?>::s_unsafe_push(lp, none), idx + 1, m);
            }
            else {
                return List<T>::s_tryProjectWMap<U>[recursive](l, lsize, List<U?>::s_unsafe_push(lp, m.get(val)), idx + 1, m);
            }
        }
    }

    private recursive static {when T KeyType} s_defaultProjectWMap<U>(l: List<T>, lsize: Int, lp: List<U>, idx: Int, m: Map<T, U>, d: U): List<U> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            if(!m.has(val)) {
                return List<T>::s_defaultProjectWMap<U>[recursive](l, lsize, List<U>::s_unsafe_push(lp, d), idx + 1, m, d);
            }
            else {
                return List<T>::s_defaultProjectWMap<U>[recursive](l, lsize, List<U>::s_unsafe_push(lp, m.get(val)), idx + 1, m, d);
            }
        }
    }

    private recursive static s_zipIndex(l: List<T>, lsize: Int, lp: List<#[Int, T]>, idx: Int): List<#[Int, T]> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_zipIndex[recursive](l, lsize, List<#[Int, T]>::s_unsafe_push(lp, #[idx, val]), idx + 1);
        }
    }

    private recursive static s_joinSingle<U>(v: T, ol: List<U>, olsize: Int, lp: List<#[T, U]>, idx: Int, p: recursive? fn(_: T, _: U) -> Bool): List<#[T, U]> {
        if(idx == olsize) {
            return lp;
        }
        else {
            let val = List<U>::s_unsafe_get(ol, idx);
            if(p[recursive?](v, val)) {
                return List<T>::s_joinSingle<U>[recursive](v, ol, olsize, List<#[T, U]>::s_unsafe_push(lp, #[v, val]), idx + 1, p);
            }
            else {
                return List<T>::s_joinSingle<U>[recursive](v, ol, olsize, lp, idx + 1, p);
            }
        }
    }

    private recursive static s_join<U>(l: List<T>, lsize: Int, ol: List<U>, olsize: Int, lp: List<#[T, U]>, idx: Int, p: recursive? fn(_: T, _: U) -> Bool): List<#[T, U]> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            let jl = List<T>::s_joinSingle<U>[recursive](val, ol, olsize, lp, 0, p);

            return List<T>::s_join<U>[recursive](l, lsize, ol, olsize, jl, idx + 1, p);
        }
    }

    private recursive static s_joinGroupSingle<U>(v: T, ol: List<U>, olsize: Int, lp: List<U>, idx: Int, p: recursive? fn(_: T, _: U) -> Bool): List<U> {
        if(idx == olsize) {
            return lp;
        }
        else {
            let val = List<U>::s_unsafe_get(ol, idx);
            if(p[recursive?](v, val)) {
                return List<T>::s_joinGroupSingle<U>[recursive](v, ol, olsize, List<T>::s_unsafe_push(lp, val), idx + 1, p);
            }
            else {
                return List<T>::s_joinGroupSingle<U>[recursive](v, ol, olsize, lp, idx + 1, p);
            }
        }
    }

    private recursive static s_joinGroup<U>(l: List<T>, lsize: Int, ol: List<U>, olsize: Int, lp: List<#[T, List<U>]>, idx: Int, p: recursive? fn(_: T, _: U) -> Bool): List<#[T, List<U>]> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            let jl = List<T>::s_joinGroupSingle<U>[recursive](val, ol, olsize, List<U>@{}, 0, p);

            return List<T>::s_joinGroup<U>[recursive](l, lsize, ol, olsize, List<#[T, List<U>]>::s_unsafe_push(lp, #[val, jl]), idx + 1, p);
        }
    }

    private recursive static s_append(l: List<T>, lsize: Int, lp: List<T>, idx: Int): List<T> {
        if(idx == lsize) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_append[recursive](l, lsize, List<T>::s_unsafe_push(lp, val), idx + 1);
        }
    }

    private recursive static s_partitionSingle<K where KeyType>(kk: K, ol: List<T>, olsize: Int, lp: List<T>, idx: Int, pf: recursive? fn(_: T) -> K): List<T> {
        if(idx == List<T>::s_size(ol)) {
            return lp;
        }
        else {
            let val = List<T>::s_unsafe_get(ol, idx);
            let key = pf[recursive?](val);
            if(KeyType::equal(kk, key)) {
                return List<T>::s_partitionSingle<K>[recursive](kk, ol, olsize, List<T>::s_unsafe_push(lp, val), idx + 1, pf);
            }
            else {
                return List<T>::s_partitionSingle<K>[recursive](kk, ol, olsize, lp, idx + 1, pf);
            }
        }
    }

    private recursive static s_partition<K where KeyType>(l: List<T>, lsize: Int, mp: Map<K, List<T>>, idx: Int, pf: recursive? fn(_: T) -> K): Map<K, List<T>> {
        if(idx == lsize) {
            return mp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            let key = pf[recursive?](val);
            if(Map<K, List<T>>::s_has_key(mp, key)) {
                return List<T>::s_partition<K>[recursive](l, lsize, mp, idx + 1, pf);
            }
            else {
                let pfg = List<T>::s_partitionSingle<K>[recursive](key, l, lsize, List<T>@{}, idx, pf);
                return List<T>::s_partition<K>[recursive](l, lsize, Map<K, List<T>>::s_add(mp, key, pfg), idx + 1, pf);
            }
        }
    }

    private recursive static s_sortsplit(l: List<T>, lsize: Int, e: T, ll: List<T>, le: List<T>, lu: List<T>, idx: Int, sf: recursive? fn(_: T, _: T) -> Bool): List<T>, List<T>, List<T> {
        if(idx == lsize) {
            return ll, le, lu;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            
            let lt = sf[recursive?](val, e);
            let gt = sf[recursive?](e, val);
            if(!lt && !gt) {
                return List<T>::s_sortsplit[recursive](l, lsize, e, ll, List<T>::s_unsafe_push(le, val), lu, idx + 1, sf);
            }
            else {
                if(lt) {
                    return List<T>::s_sortsplit[recursive](l, lsize, e, List<T>::s_unsafe_push(ll, val), le, lu, idx + 1, sf);
                }
                else {
                    return List<T>::s_sortsplit[recursive](l, lsize, e, ll, le, List<T>::s_unsafe_push(lu, val), idx + 1, sf);
                }
            }
        }
    }

    private recursive static s_sort(l: List<T>, lsize: Int, sf: recursive? fn(_: T, _: T) -> Bool): List<T> {
        if(lsize <= 1) {
            return l;
        }
        else {
            let e = List<T>::s_unsafe_get(l, 0);

            let ll, le, lu = List<T>::s_sortsplit[recursive](l, lsize, e, List<T>@{}, List<T>@{}, List<T>@{}, 0, sf);
            let lls = List<T>::s_sort[recursive](ll, List<T>::s_size(ll), sf);
            let llu = List<T>::s_sort[recursive](lu, List<T>::s_size(lu), sf);

            return lls.append(le).append(llu);
        }
    }

    private recursive static s_toIndexMap(l: List<T>, lsize: Int, mp: Map<Int, T>, idx: Int): Map<Int, T> {
        if(idx == lsize) {
            return mp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            return List<T>::s_toIndexMap[recursive](l, lsize, Map<Int, T>::s_add(mp, idx, val), idx + 1);
        }
    }

    private recursive static s_transformIndexMap<V>(l: List<T>, lsize: Int, mp: Map<Int, V>, idx: Int, vf: recursive? fn(_: T) -> V): Map<Int, V> {
        if(idx == lsize) {
            return mp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            let v = vf[recursive?](val);

            return List<T>::s_transformIndexMap<V>[recursive](l, lsize, Map<Int, V>::s_add(mp, idx, v), idx + 1, vf);
        }
    }

    private recursive static s_transformMap<K where KeyType, V>(l: List<T>, lsize: Int, mp: Map<K, V>, idx: Int, kf: recursive? fn(_: T) -> K, vf: recursive? fn(_: T) -> V): Map<K, V> {
        if(idx == lsize) {
            return mp;
        }
        else {
            let val = List<T>::s_unsafe_get(l, idx);
            let k = kf[recursive?](val);
            let v = vf[recursive?](val);

            check !Map<K, V>::s_has_key(mp, k);
            return List<T>::s_transformMap<K, V>[recursive](l, lsize, Map<K, V>::s_add(mp, k, v), idx + 1, kf, vf);
        }
    }

    pragma KnownSafe
    private static s_rangeInBounds(l: List<T>, start: Int?, end: Int?): Bool {
        let s, e = start ?| 0, end ?| List<T>::s_size(l);
        return 0 <= s && s <= e && e <= List<T>::s_size(l); 
    }

    static concat(...ll: List<List<T>>): List<T> {
        return List<T>::s_concat[recursive](ll, List<List<T>>::s_size(ll), List<T>@{}, 0);
    }

    static fill(k: Int, val: T): List<T>
        requires release k >= 0;
    {
        return List<T>::s_fill[recursive](k, val, List<T>@{});
    }

    method size(): Int {
        return List<T>::s_size(this);
    }

    method empty(): Bool {
        return List<T>::s_size(this) == 0;
    }

    method front(): T 
        requires release List<T>::s_size(this) != 0;
    {
        return List<T>::s_unsafe_get(this, 0);
    }

    method tryFront(): T? {
        return List<T>::s_size(this) != 0 ? List<T>::s_unsafe_get(this, 0) : none;
    }

    method defaultFront(default: T): T {
        return List<T>::s_size(this) != 0 ? List<T>::s_unsafe_get(this, 0) : default;
    }

    method back(): T 
        requires release List<T>::s_size(this) != 0;
    {
        return List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1);
    }

    method tryBack(): T? {
        return List<T>::s_size(this) != 0 ? List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1) : none;
    }

    method defaultBack(default: T): T {
        return List<T>::s_size(this) != 0 ? List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1) : default;
    }

    method get(i: Int): T 
        requires release 0 <= i && i < List<T>::s_size(this);
    {
        return List<T>::s_unsafe_get(this, i);
    }

    method tryGet(i: Int): T? {
        return 0 <= i && i < List<T>::s_size(this) ? List<T>::s_unsafe_get(this, i) : none;
    }

    method defaultGet(i: Int, default: T): T {
        return 0 <= i && i < List<T>::s_size(this) ? List<T>::s_unsafe_get(this, i) : default;
    }

    method {when T KeyType} toSet(): Set<T> {
        return List<T>::s_toset[recursive](this, List<T>::s_size(this), 0, Set<T>@{});
    }

    recursive? method single(p: recursive? fn(_: T) -> Bool): T 
        requires release List<T>::s_size(this) != 0;
    {
        let idx = List<T>::s_indexof[recursive](this, 0, List<T>::s_size(this), p);
        let lastidx = List<T>::s_indexoflast[recursive](this, -1, List<T>::s_size(this) - 1, p);

        check lastidx == idx;
        return List<T>::s_unsafe_get(this, idx);
    }

    recursive? method trySingle(p: recursive? fn(_: T) -> Bool): T? {
        let idx = List<T>::s_indexof[recursive](this, 0, List<T>::s_size(this), p);
        let lastidx = List<T>::s_indexoflast[recursive](this, -1, List<T>::s_size(this) - 1, p);

        return idx == lastidx ? List<T>::s_unsafe_get(this, idx) : none;
    }

    method uniform(i: Int, start?: Int, end?: Int): T
        requires release List<T>::s_size(this) != 0;
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        abort;
    }

    recursive? method allOf(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::s_size(this) == 0 || List<T>::s_all[recursive](this, List<T>::s_size(this), 0, p);
    }

    recursive? method noneOf(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::s_size(this) == 0 || List<T>::s_none[recursive](this, List<T>::s_size(this), 0, p);
    }

    recursive? method anyOf(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::s_size(this) != 0 && List<T>::s_any[recursive](this, List<T>::s_size(this), 0, p);
    }

    recursive? method countIf(p: recursive? fn(_: T) -> Bool): Int {
        return List<T>::s_count[recursive](this, List<T>::s_size(this), 0, 0, p);
    }

    recursive? method countIfNot(p: recursive? fn(_: T) -> Bool): Int {
        return List<T>::s_countnot[recursive](this, List<T>::s_size(this), 0, 0, p);
    }

    method {when T KeyType} contains(v: T): Bool {
        return List<T>::s_indexof_keytype[recursive](this, 0, List<T>::s_size(this), v) != List<T>::s_size(this);
    }

    method {when T KeyType} count(v: T): Int {
        return List<T>::s_count_keytype[recursive](this, List<T>::s_size(this), 0, 0, v);
    }

    method {when T KeyType} min(): T 
        requires release List<T>::s_size(this) != 0;
    {
        return List<T>::s_min[recursive](this, List<T>::s_size(this), 1, List<T>::s_unsafe_get(this, 0));
    }

    method {when T KeyType} tryMin(): T? {
        return List<T>::s_size(this) != 0 ? List<T>::s_min[recursive](this, List<T>::s_size(this), 1, List<T>::s_unsafe_get(this, 0)) : none;
    }

    method {when T KeyType} max(): T 
        requires release List<T>::s_size(this) != 0;
    {
        return List<T>::s_max[recursive](this, List<T>::s_size(this), 1, List<T>::s_unsafe_get(this, 0));
    }

    method {when T KeyType} tryMax(): T? {
        return List<T>::s_size(this) != 0 ? List<T>::s_max[recursive](this, List<T>::s_size(this), 1, List<T>::s_unsafe_get(this, 0)) : none;
    }

    recursive? method argMin<K=? where KeyType>(vf: recursive? fn(_: T) -> K): T {
        //TODO: fill in
    }

    recursive? method tryArgMin<K=? where KeyType>(vf: recursive? fn(_: T) -> K): T? {
        //TODO: fill in
    }

    recursive? method argMax<K=? where KeyType>(vf: recursive? fn(_: T) -> K): T {
        //TODO: fill in
    }

    recursive? method tryArgMax<K=? where KeyType>(vf: recursive? fn(_: T) -> K): T? {
        //TODO: fill in
    }

    method {when T Int || T BigInt} sum(): T {
        return List<T>::s_sum[recursive](this, List<T>::s_size(this), 0, 0);
    }

    recursive? method find(p: recursive? fn(_: T) -> Bool): T {
        let idx = List<T>::s_indexof[recursive](this, 0, List<T>::s_size(this), p);
        check idx != List<T>::s_size(this);
        return List<T>::s_unsafe_get(this, idx);
    }

    recursive? method tryFind(p: recursive? fn(_: T) -> Bool): T? {
        let idx = List<T>::s_indexof[recursive](this, 0, List<T>::s_size(this), p);
        return idx != List<T>::s_size(this) ? List<T>::s_unsafe_get(this, idx) : none;
    }

    recursive? method findNot(p: recursive? fn(_: T) -> Bool): T {
        let idx = List<T>::s_indexofnot[recursive](this, 0, List<T>::s_size(this), p);
        check idx != List<T>::s_size(this);
        return List<T>::s_unsafe_get(this, idx);
    }

    recursive? method tryFindNot(p: recursive? fn(_: T) -> Bool): T? {
        let idx = List<T>::s_indexofnot[recursive](this, 0, List<T>::s_size(this), p);
        return idx != List<T>::s_size(this) ? List<T>::s_unsafe_get(this, idx) : none;
    }

    recursive? method findLast(p: recursive? fn(_: T) -> Bool): T {
        let idxlast = List<T>::s_indexoflast[recursive](this, -1, List<T>::s_size(this) - 1, p);
        check idxlast != -1;
        return List<T>::s_unsafe_get(this, idxlast);
    }

    recursive? method tryFindLast(p: recursive? fn(_: T) -> Bool): T? {
        let idxlast = List<T>::s_indexoflast[recursive](this, -1, List<T>::s_size(this) - 1, p);
        return idxlast != -1 ? List<T>::s_unsafe_get(this, idxlast) : none;
    }

    recursive? method findLastNot(p: recursive? fn(_: T) -> Bool): T {
        let idxlast = List<T>::s_indexoflastnot[recursive](this, -1, List<T>::s_size(this) - 1, p);
        check idxlast != -1;
        return List<T>::s_unsafe_get(this, idxlast);
    }

    recursive? method tryFindLastNot(p: recursive? fn(_: T) -> Bool): T? {
        let idxlast = List<T>::s_indexoflastnot[recursive](this, -1, List<T>::s_size(this) - 1, p);
        return idxlast != -1 ? List<T>::s_unsafe_get(this, idxlast) : none;
    }

    recursive? method findIndexOf(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::s_size(this);

        let idx = List<T>::s_indexof[recursive](this, s, e, p);
        check idx != e;
        return idx;
    }

    recursive? method tryFindIndexOf(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::s_size(this);

        let idx = List<T>::s_indexof[recursive](this, s, e, p);
        return idx != e ? idx : none;
    }

    recursive? method findIndexOfNot(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::s_size(this);

        let idx = List<T>::s_indexofnot[recursive](this, s, e, p);
        check idx != e;
        return idx;
    }

    recursive? method tryFindIndexOfNot(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::s_size(this);

        let idx = List<T>::s_indexofnot[recursive](this, s, e, p);
        return idx != e ? idx : none;
    }

    recursive? method findLastIndexOf(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = (start ?| 0) - 1, (end ?| List<T>::s_size(this)) - 1;

        let idxlast = List<T>::s_indexoflast[recursive](this, s, e, p);
        check idxlast != s;
        return idxlast;
    }

    recursive? method tryFindLastIndexOf(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = (start ?| 0) - 1, (end ?| List<T>::s_size(this)) - 1;

        let idxlast = List<T>::s_indexoflast[recursive](this, s, e, p);
        return idxlast != s ? idxlast : none;
    }

    recursive? method findLastIndexOfNot(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = (start ?| 0) - 1, (end ?| List<T>::s_size(this)) - 1;

        let idxlast = List<T>::s_indexoflastnot[recursive](this, s, e, p);
        check idxlast != s;
        return idxlast;
    }

    recursive? method tryFindLastIndexOfNot(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = (start ?| 0) - 1, (end ?| List<T>::s_size(this)) - 1;

        let idxlast = List<T>::s_indexoflastnot[recursive](this, s, e, p);
        return idxlast != s ? idxlast : none;
    }

    method {when T KeyType} indexOf(v: T, start?: Int, end?: Int): Int
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::s_size(this);

        let idx = List<T>::s_indexof_keytype[recursive](this, s, e, v);
        check idx != e;
        return idx;
    }

    method {when T KeyType} tryIndexOf(v: T, start?: Int, end?: Int): Int?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::s_size(this);

        let idx = List<T>::s_indexof_keytype[recursive](this, s, e, v);
        return idx != e ? idx : none;
    }

    method {when T KeyType} lastIndexOf(v: T, start?: Int, end?: Int): Int
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = (start ?| 0) - 1, (end ?| List<T>::s_size(this)) - 1;

        let idx = List<T>::s_indexoflast_keytype[recursive](this, s, e, v);
        check idx != s;
        return idx;
    }

    method {when T KeyType} tryLastIndexOf(v: T, start?: Int, end?: Int): Int?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = (start ?| 0) - 1, (end ?| List<T>::s_size(this)) - 1;

        let idx = List<T>::s_indexoflast_keytype[recursive](this, s, e, v);
        return idx != s ? idx : none;
    }

    recursive? method filter(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::s_filter[recursive](this, List<T>::s_size(this), List<T>@{}, 0, p);
    }

    recursive? method filterNot(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::s_filternot[recursive](this, List<T>::s_size(this), List<T>@{}, 0, p);
    }

    method ofType<U>(): List<U> {
        return List<T>::s_oftype<U>[recursive](this, List<T>::s_size(this), List<U>@{}, 0);
    }

    method cast<U>(): List<U> {
        return List<T>::s_cast<U>[recursive](this, List<T>::s_size(this), List<U>@{}, 0);
    }

    method slice(start?: Int, end?: Int): List<T> 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::s_size(this);

        if(s == e) {
            return List<T>@{};
        }
        else {
            return List<T>::s_slice[recursive](this, s, e);
        }
    }

    method removeFirst(k: Int): List<T> 
        requires release List<T>::s_rangeInBounds(this, k, List<T>::s_size(this));
    {
        return List<T>::s_slice[recursive](this, k, List<T>::s_size(this));
    }

    method removeLast(k: Int): List<T> 
        requires release List<T>::s_rangeInBounds(this, k, List<T>::s_size(this));
    {
        return List<T>::s_slice[recursive](this, 0, List<T>::s_size(this) - k);
    }

    recursive? method takeWhile(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::s_takewhile[recursive](this, List<T>::s_size(this), List<T>@{}, 0, p);
    }

    recursive? method discardWhile(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::s_discardwhile[recursive](this, List<T>::s_size(this), 0, p);
    }

    recursive? method takeUntil(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::s_takeuntil[recursive](this, List<T>::s_size(this), List<T>@{}, 0, p);
    }

    recursive? method discardUntil(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::s_discarduntil[recursive](this, List<T>::s_size(this), 0, p);
    }

    method {when T KeyType} unique(): List<T> {
        return List<T>::s_unique[recursive](this, List<T>::s_size(this), List<T>@{}, 0);
    }

    method reverse(): List<T> {
        return List<T>::s_reverse[recursive](this, List<T>::s_size(this), this, 0);
    }

    recursive? method map<U=?>(f: recursive? fn(_: T) -> U): List<U> {
        return List<T>::s_map<U>[recursive](this, List<T>::s_size(this), List<U>@{}, 0, f);
    }

    recursive? method mapIndex<U=?>(f: recursive? fn(_: T, _: Int) -> U): List<U> {
        return List<T>::s_mapIndex<U>[recursive](this, List<T>::s_size(this), List<U>@{}, 0, f);
    }

    method {when T KeyType} projectWithMap<U=?>(m: Map<T, U>): List<U> {
        return List<T>::s_projectWMap<U>[recursive](this, List<T>::s_size(this), List<U>@{}, 0, m); 
    }

    method {when T KeyType} tryProjectWithMap<U=?>(m: Map<T, U>): List<U?> {
        return List<T>::s_tryProjectWMap<U>[recursive](this, List<T>::s_size(this), List<U?>@{}, 0, m);
    }

    method {when T KeyType} defaultProjectWithMap<U=?>(default: U, m: Map<T, U>): List<U> {
        return List<T>::s_defaultProjectWMap<U>[recursive](this, List<T>::s_size(this), List<U>@{}, 0, m, default);
    }

    method zipIndex(): List<#[Int, T]> {
        return List<T>::s_zipIndex[recursive](this, List<T>::s_size(this), List<#[Int, T]>@{}, 0);
    }

    recursive? method join<U=?>(ol: List<U>, p: recursive? fn(_: T, _: U) -> Bool): List<#[T, U]> {
        return List<T>::s_join<U>[recursive](this, List<T>::s_size(this), ol, List<T>::s_size(ol), List<#[T, U]>@{}, 0, p);
    }

    recursive? method joinGroup<U=?>(ol: List<U>, p: recursive? fn(_: T, _: U) -> Bool): List<#[T, List<U>]> {
        return List<T>::s_joinGroup<U>[recursive](this, List<T>::s_size(this), ol, List<T>::s_size(ol), List<#[T, List<U>]>@{}, 0, p);
    }

    method append(l: List<T>): List<T> {
        return List<T>::s_append[recursive](l, List<T>::s_size(l), this, 0);
    }

    method prepend(l: List<T>): List<T> {
        return List<T>::s_append[recursive](this, List<T>::s_size(this), l, 0);
    }

    recursive? method partition<K=? where KeyType>(pf: recursive? fn(_: T) -> K): Map<K, List<T>> {
        return List<T>::s_partition<K>[recursive](this, List<T>::s_size(this), Map<K, List<T>>@{}, 0, pf);
    }

    recursive? method sort(cmp: recursive? fn(_: T, _: T) -> Bool): List<T> {
        return List<T>::s_sort[recursive](this, List<T>::s_size(this), cmp);
    }

    method toIndexMap(): Map<Int, T> {
        return List<T>::s_toIndexMap[recursive](this, List<T>::s_size(this), Map<Int, T>@{}, 0);
    }

    recursive? method transformToIndexMap<V=?>(vf: recursive? fn(_: T) -> V): Map<Int, V> {
        return List<T>::s_transformIndexMap<V>[recursive](this, List<T>::s_size(this), Map<Int, V>@{}, 0, vf);
    }

    recursive? method transformToMap<K=? where KeyType, V=?>(kf: recursive? fn(_: T) -> K, vf: recursive? fn(_: T) -> V): Map<K, V> {
        return List<T>::s_transformMap<K, V>[recursive](this, List<T>::s_size(this), Map<K, V>@{}, 0, kf, vf);
    }
    
    private recursive static s_zip<T, U>(size: Int, l1: List<T>, l2: List<U>, lp: List<#[T, U]>, idx: Int): List<#[T, U]> {
        if(idx == size) {
            return lp;
        }
        else {
            let vt = List<T>::s_unsafe_get(l1, idx);
            let vu = List<U>::s_unsafe_get(l2, idx);
            return List::s_zip<T, U>[recursive](size, l1, l2, List<[T, U]>::s_unsafe_push(lp, #[vt, vu]), idx + 1);
        }
    }

    private recursive static s_unzip<T, U>(l: List<#[T, U]>, lsize: Int, lt: List<T>, lu: List<U>, idx: Int): List<T>, List<U> {
        if(idx == lsize) {
            return lt, lu;
        }
        else {
            let vp = List<[T, U]>::s_unsafe_get(l, idx);
            return List::s_unzip<T, U>[recursive](l, lsize, List<T>::s_unsafe_push(lt, vp.0), List<U>::s_unsafe_push(lu, vp.1), idx + 1);
        }
    }

    private recursive static {when T Int} s_range(start: Int, end: Int, lp: List<Int>): List<Int> {
        if(start == end) {
            return lp;
        }
        else {
            return List::s_range[recursive](start + 1, end, List<Int>::s_unsafe_push(lp, start));
        }
    }

    static zip<T=?, U=?>(l1: List<T>, l2: List<U>): List<#[T, U]>
        requires release List<T>::s_size(l1) == List<U>::s_size(l2);
    {
        return List::s_zip<T, U>[recursive](List<T>::s_size(l1), l1, l2, List<#[T, U]>@{}, 0);
    }

    static unzip<T=?, U=?>(l: List<#[T, U]>): List<T>, List<U> {
        return List::s_unzip<T, U>[recursive](l, List<#[T, U]>::s_size(l), List<T>@{}, List<U>@{}, 0);
    }

    static {when T Int} range(start: Int, end: Int): List<Int>
        requires release start <= end;
    {
        return List::s_range[recursive](start, end, List<Int>@{});
    }

    method {when T Float64} sigmaSum(): List<Float64> {
        //TODO: fill in
    }

    method {when T Float64} product(): List<Float64> {
        //TODO: fill in
    }

    method {when T Float64} floatMax(): List<Float64> {
        //TODO: fill in
    }

    method {when T Float64} floatMin(): List<Float64> {
        //TODO: fill in
    }

    recursive? method floatArgMax(vf: recursive? fn(_: T) -> Float64): T {
        //TODO: fill in
    }

    recursive? method floatArgMin(vf: recursive? fn(_: T) -> Float64): T {
        //TODO: fill in
    }
}
